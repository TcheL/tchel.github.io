<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一堆儿公式]]></title>
    <url>%2F2019%2F08%2F15%2FHandbook-of-Formulas%2F</url>
    <content type="text"><![CDATA[数学三角函数欧拉公式$$e^{i\theta} = \cos \theta + i \sin \theta$$ $$\sin \theta = \frac{e^{i \theta} - e^{- i \theta}}{2i}$$ $$\cos \theta = \frac{e^{i \theta} + e^{- i \theta}}{2}$$ 诱导公式基本关系：$\sin^2 a + \cos^2 a = 1$, $\tan a = \frac{\sin a}{\cos a}$, $\cot a = \frac{\cos a}{\sin a}$, $\sec a = \frac{1}{\cos a}$, $\csc a = \frac{1}{\sin a}$. 扩展关系：$\sec^2 a - \tan^2 a = 1$, $\csc^2 a - \cot^2 a = 1$. $\sin$ $\cos$ $\tan$ $\cot$ $\sec$ $\csc$ $- a$ $- \sin a$ $\cos a$ $- \tan a$ $ - \cot a$ $\sec a$ $- \csc a$ $\frac{\pi}{2} \pm a$ $\cos a$ $\mp \sin a$ $\mp \cot a$ $\mp \tan a$ $\mp \csc a$ $\sec a$ $\pi \pm a$ $\mp \sin a$ $- \cos a$ $\pm \tan a$ $\pm \cot a$ $- \sec a$ $\mp \csc a$ $\frac{3\pi}{2} \pm a$ $- \cos a$ $\pm \sin a$ $\mp \cot a$ $\mp \tan a$ $\pm \csc a$ $- \sec a$ $2\pi \pm a$ $\pm \sin a$ $\cos a$ $\pm \tan a$ $\pm \cot a$ $\sec a$ $\pm \csc a$ 两角和差公式$$\sin(a \pm b) = \sin a \cos b \pm \cos a \sin b$$ $$\cos(a \pm b) = \cos a \cos b \mp \sin a \sin b$$ $$\tan(a \pm b) = \frac{\tan a \pm \tan b}{1 \mp \tan a \tan b}$$ $$\cot (a \pm b) = \frac{\cot a \cot b \mp 1}{\cot b \pm \cot a}$$ 半角公式$$\sin^2 \frac{a}{2} = \frac{1 - \cos a}{2}$$ $$\cos^2 \frac{a}{2} = \frac{1 + \cos a}{2}$$ $$\tan^2 \frac{a}{2} = \frac{1 - \cos a}{1 + \cos a}$$ 万能公式$$\sin a = \frac{2 \tan \frac{a}{2}}{1 + \tan^2 \frac{a}{2}}$$ $$\cos a = \frac{1 - \tan^2 \frac{a}{2}}{1 + \tan^2 \frac{a}{2}}$$ $$\tan a = \frac{2 \tan \frac{a}{2}}{1 - \tan^2 \frac{a}{2}}$$ 三倍角公式$$\sin 3a = 3 \sin a - 4 \sin^3 a$$ $$\cos 3 a = 4 \cos^3 a - 3 \cos a$$ $$\tan 3a = \frac{3 \tan a - \tan^3 a}{1 - 3 \tan^2 a} = \tan a \tan (\frac{\pi}{3} + a) \tan (\frac{\pi}{3} - a)$$ $$\cot 3a = \frac{\cot^3 a - 3 \cot a}{3 \cot^2 a - 1}$$ 降冪公式 $\sin^2 a = \frac{1}{2} (1 - \cos 2a)$ $\sin^3 a = \frac{1}{4} (3 \sin a - \sin 3a)$ $\sin^4 a = \frac{1}{8} (3 - 4 \cos 2a + \cos 4a)$ $\cos^2 a = \frac{1}{2} (1 + \cos 2a)$ $\cos^3 a = \frac{1}{4} (3 \cos a + \cos 3a)$ $\cos^4 a = \frac{1}{8} (3 + 4 \cos 2a + \cos 4a)$ 和差化积 $\sin a + \sin b = 2 \sin \frac{a + b}{2} \cos \frac{a - b}{2}$ $\sin a - \sin b = 2 \sin \frac{a - b}{2} \cos \frac{a + b}{2}$ $\sin^2 a - \sin^2 b = \sin (a + b) \sin (a - b)$ $\cos a + \cos b = 2 \cos \frac{a + b}{2} \cos \frac{a - b}{2}$ $\cos a - \cos b = - 2 \sin \frac{a + b}{2} \sin \frac{a - b}{2}$ $\cos^2 a - \cos^2 b = - \sin (a + b) \sin (a - b)$ $\tan a + \tan b = \frac{\sin (a + b)}{\cos a \cos b}$ $\tan a - \tan b = \frac{\sin (a - b)}{\cos a \cos b}$ $\cos^2 a - \sin^2 b = \cos (a + b) \cos (a - b)$ $\cot a + \cot b = \frac{\sin (a + b)}{\sin a \sin b}$ $\cot a - \cot b = - \frac{\sin (a - b)}{\sin a \sin b}$ $\sin^2 - \cos^2 b = - \cos (a + b) \cos (a - b)$ 积化和差$$\sin a \sin b = - \frac{1}{2} [ \cos (a + b) - \cos (a - b) ]$$ $$\sin a \cos b = \frac{1}{2} [ \sin (a + b) + \sin (a - b) ]$$ $$\cos a \cos b = \frac{1}{2} [ \cos (a + b) + \cos (a - b) ]$$ $$\cos a \sin b = \frac{1}{2} [ \sin (a + b) - \sin (a - b) ]$$ 微积分导数公式 $f(x)$ $f’(x)$ $f(x)$ $f’(x)$ $f(x)$ $f’(x)$ $x^n$ $n x^{n -1}$ $a^x$ $a^x \ln a$ $e^x$ $e^x$ $x^x$ $x^x (1 + \ln x)$ $\log_a x$ $\frac{1}{x \ln a}$ $\ln x$ $\frac{1}{x}$ $\sin x$ $\cos x$ $\arcsin x$ $\frac{1}{\sqrt{1 - x^2}}$ $\sinh x$ $\cosh x$ $\cos x$ $- \sin x$ $\arccos x$ $- \frac{1}{\sqrt{1 - x^2}}$ $\cosh x$ $\sinh x$ $\tan x$ $\frac{1}{\cos^2 x}$ $\arctan x$ $\frac{1}{1 + x^2}$ $\tanh x$ $\frac{1}{\cosh^2 x}$ $\cot x$ $- \frac{1}{\sin^2 x}$ $\text{arccot}~x$ $- \frac{1}{1 + x^2}$ $\coth x$ $- \frac{1}{\sinh^2 x}$ $\sec x$ $\frac{\sin x}{\cos^2 x}$ $\text{arcsec}~x$ $\frac{1}{x \sqrt{x^2 - 1}}$ $\text{sech}~x$ $- \frac{\sinh x}{\cosh^2 x}$ $\csc x$ $- \frac{\cos x}{\sin^2 x}$ $\text{arccsc}~x$ $- \frac{1}{x \sqrt{x^2 - 1}}$ $\text{csch}~x$ $- \frac{\cosh x}{\sinh^2 x}$ 傅里叶变换定义$$F(\omega) = \int_{-\infty}^{+\infty} f(t) e^{-j \omega t} dt$$ $$f(t) = \frac{1}{2\pi} \int_{-\infty}^{+\infty} F(\omega) e^{j \omega t} dt$$ 性质 性质 像原函数 像函数 线性 $a f_1(t) + b f_2(t)$ $a F_1(\omega) + b F_2(\omega)$ 位移 $f(t-t_0)$$e^{j \omega_0 t} f(t)$ $e^{-j \omega t_0} F(\omega)$$F(\omega - \omega_0)​$ 相似 $f(a t)$ $\frac{1}{\vert a \vert} F(\frac{\omega}{a})$ 对称 $F(\pm t)$ $2\pi f(\mp \omega)$ 微分 $f^{(n)} (t)$$(-j t)^n f(t)$ $(j \omega)^n F(\omega)$$F^{(n)}(\omega)$ 积分 $\int_{-\infty}^t \int_{-\infty}^t \cdots \int_{-\infty}^t f(t) dt \cdots dt dt$ $\frac{1}{(j \omega)^n} F(\omega)$ 卷积 $(f_1 \ast f_2) (t)$$f_1 (t) \cdot f_2 (t)​$ $F_1(\omega) F_2(\omega)$$\frac{1}{2\pi} (F_1 \ast F_2) (\omega)$ 能量积分： $$\int_{-\infty}^{+\infty} f_1(t) f_2(t) dt = \frac{1}{2\pi} \int_{-\infty}^{+\infty} \overline{F_1 (\omega)} F_2 (\omega) d\omega$$ $$\int_{-\infty}^{+\infty} f^2 (t) dt = \frac{1}{2\pi} \int_{-\infty}^{+\infty} \vert F(\omega) \vert ^2 d\omega​$$ 常见变换对 像原函数 像函数 矩形单脉冲 $f(t) = \begin{cases} E, &amp; \vert t \vert \leq \frac{\tau}{2} \newline 0, &amp; \text{other} \newline \end{cases}$ $2E \frac{\sin \frac{\omega \tau}{2}}{\omega}$ 指数衰减函数 $f(t) = \begin{cases} 0, &amp; t &lt; 0 \newline e^{-\beta t}, &amp; t \geq 0 \end{cases}, (\beta &gt; 0)$ $\frac{1}{\beta + j \omega}$ 单位函数 $f(t) = u(t)$ $\frac{1}{j \omega} + \pi \delta(\omega)$ 三角形脉冲 $f(t) = \begin{cases} \frac{2A}{\tau} (\frac{\tau}{2} + t), &amp; -\frac{\tau}{2} \leq t &lt; 0 \newline \frac{2A}{\tau} (\frac{\tau}{2} - t), &amp; 0 \leq t &lt; \frac{\tau}{2} \end{cases}$ $\frac{4A}{\tau \omega^2} (1 - \cos \frac{\omega \tau}{2})$ 钟形脉冲 $f(t) = A e^{-\beta t^2}, (\beta &gt; 0)$ $\sqrt(\frac{\pi}{\beta}) A e^{- \frac{\omega^2}{4 \beta}}$ 傅里叶核 $f(t) = \frac{\sin \omega_0 t}{\pi t}$ $F(\omega) = \begin{cases} 1, &amp; \vert \omega \vert \leq \omega_0 \newline 0, &amp; \text{other} \end{cases}$ 高斯分布函数 $f(t) = \frac{1}{\sqrt{2\pi \sigma}} e^{-\frac{t^2}{2\sigma^2}}$ $e^{- \frac{\sigma^2 \omega^2}{2}}$ 单位脉冲函数 $f(t) = \delta(t)$ $1$ 周期性脉冲函数 $f(t) = \sum_{n=-\infty}^{+\infty} \delta(t - n T)$ $\frac{2\pi}{T} \sum_{n=-\infty}^{+\infty} \delta(\omega - \frac{2n\pi}{T})$ 符号函数 $f(t) = \mathrm{sgn~} t = 2 u(t) - 1$ $\frac{2}{j \omega}$ $f(t) = \cos \omega_0 t$ $\pi [ \delta(\omega + \omega_0) + \delta(\omega - \omega_0) ]$ $f(t) = \sin \omega_0 t$ $j \pi [ \delta(\omega + \omega_0) - \delta(\omega - \omega_0) ]$ $u(t - c)$ $\frac{1}{j \omega} e^{-j \omega c} + \pi \delta(\omega)$ $u(t) \cdot t^n$ $\frac{n!}{(j \omega)^{n + 1}} + \pi j^n \delta^{(n)} (\omega)$ $u(t) \sin at$ $\frac{a}{a^2 - \omega^2} + \frac{\pi}{2 j} [ \delta(\omega - a) - \delta(\omega + a) ]$ $u(t) \cos at$ $\frac{j \omega}{a^2 - \omega^2} + \frac{\pi}{2} [ \delta(\omega - a) + \delta(\omega + a) ]$ $u(t) e^{j a t}$ $\frac{1}{j (\omega - a)} + \pi \delta(\omega - a)$ $u(t - c) e^{j a t}$ $\frac{1}{j(\omega - a)} e^{-j (\omega - a) c} + \pi \delta(\omega - a)$ $u(t) e^{j a t} t^n$ $\frac{n!}{[j (\omega - a)]^{n + 1}} + \pi j^n \delta^{(n)}(\omega - a)$ $e^{a \vert t \vert}, \Re (a) &lt; 0$ $ - \frac{2a}{\omega^2 + a^2}$ $\delta(t - c)$ $e^{-j \omega c}$ $\delta^{(n)}(t)$ $(j \omega)^n$ $\delta^{(n)}(t - c)$ $(j \omega)^n e^{- j \omega c}$ $1$ $2 \pi \delta(\omega)$ $t^n$ $2 \pi j^n \delta^{(n)} (\omega)$ $e^{j a t}$ $2 \pi \delta(\omega - a)$ $t^n e^{j a t}$ $2 \pi j^n \delta^{(n)} (\omega - a)$ $\frac{1}{a^2 + t^2}, \Re (a) &lt; 0$ $- \frac{\pi}{a} e^{a \vert \omega \vert}$ $\frac{t}{(a^2 + t^2)^2}, \Re (a) &lt; 0$ $\frac{j \omega \pi}{2a} e^{a \vert \omega \vert}$ $\frac{\sin bt}{a^2 + t^2}, \Re (a) &lt; 0, b \in \mathscr{R}$ $ - \frac{\pi}{a} e^{a \vert \omega - b \vert}$ $\frac{\cos bt}{a^2 + t^2}, \Re (a) &lt; 0, b \in \mathscr{R}$ $ - \frac{\pi}{2a} [ e^{a \vert \omega - b \vert} + e^{a \vert \omega + b \vert} ]$ $\frac{e^{j b t}}{a^2 + t^2}, \Re (a) &lt; 0, b \in \mathscr{R}$ $ - \frac{\pi}{2 a j} [ e^{a \vert \omega - b \vert} - e^{a \vert \omega + b \vert} ]$ $\frac{\sinh at}{\sinh \pi t}, - \pi &lt; a &lt; \pi$ $\frac{\sin a}{\cosh \omega + \cos a}$ $\frac{\sinh at}{\cosh \pi t}, - \pi &lt; a &lt; \pi$ $-2j \frac{\sin \frac{a}{2} \sinh \frac{\omega}{2}}{\cosh \omega + \cos a}$ $\frac{\cosh at}{\cosh \pi t}, - \pi &lt; a &lt; \pi$ $2 \frac{\cos \frac{a}{2} \cosh \frac{\omega}{2}}{\cosh \omega + \cos a}$ $\frac{1}{\cosh at}$ $\frac{\pi}{a} \frac{1}{\cosh \frac{\pi \omega}{2a}}$ $\sin at^2$ $\sqrt{\frac{\pi}{a}} \cos \Big( \frac{\omega^2}{4a} + \frac{\pi}{4} \Big)$ $\cos at^2$ $\sqrt{\frac{\pi}{a}} \cos \Big( \frac{\omega^2}{4a} - \frac{\pi}{4} \Big)$ $\frac{1}{t} \sin at$ $\begin{cases} \pi, &amp; \vert \omega \vert \leq a \newline 0, &amp; \vert \omega \vert &gt; a \end{cases}$ $\frac{1}{t^2} \sin^2 at$ $\begin{cases} \pi \Big( a - \frac{\vert \omega \vert}{2} \Big), &amp; \vert \omega \vert \leq 2a \newline 0, &amp; \vert \omega \vert &gt; 2a \end{cases}$ $\frac{\sin at}{\sqrt{\vert t \vert}}$ $j \sqrt{\frac{\pi}{2}} \Big( \frac{1}{\sqrt{\vert \omega + a \vert}} - \frac{1}{\sqrt{\vert \omega - a \vert}} \Big)$ $\frac{\cos at}{\sqrt{\vert t \vert}}$ $\sqrt{\frac{\pi}{2}} \Big( \frac{1}{\sqrt{\vert \omega + a \vert}} + \frac{1}{\sqrt{\vert \omega - a \vert}} \Big)$ $\frac{1}{\sqrt{\vert t \vert}}$ $\sqrt{\frac{2\pi}{\vert \omega \vert}}$ $e^{- at^2}, \Re(a) &gt; 0$ $\sqrt{\frac{\pi}{a}} e^{- \frac{\omega^2}{4a}}$ $\vert t \vert$ $- \frac{2}{\omega^2}$ $\frac{1}{\vert t \vert}$ $\frac{\sqrt{2\pi}}{\vert \omega \vert}$ 幂级数展开$$\frac{1}{1 - x} = 1 + x + x^2 + \cdots + x^n + \cdots, |x| &lt; 1$$ $$\sin x = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \cdots + (- 1)^n \frac{x^{2n + 1}}{(2n + 1)!} + \cdots, |x| &lt; \infty$$ $$\cos x = 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \cdots + (- 1)^n \frac{x^{2n}}{(2n)!} + \cdots, |x| &lt; \infty$$ $$e^x = 1 + \frac{x}{1!} + \frac{x^2}{2!} + \cdots + \frac{x^n}{n!} + \cdots, |x| &lt; \infty$$ $$\ln (1 + x) = x - \frac{x^2}{3} + \frac{x^3}{3} - \cdots + (- 1)^{n + 1} \frac{x^n}{n} + \cdots, - 1 &lt; x \leq 1$$ 泰勒展开$$f(x) = f(x_0) + f’(x_0) (x - x_0) + \frac{f’’(x_0)}{2!} (x - x_0)^2 + \cdots + \frac{f^{(n)}(x_0)}{n!} (x - x_0)^n + R_n(x)$$ 物理地震学弹性参数转换纵波波速 $\alpha$ 和横波波速 $\beta$： $$\alpha = \sqrt{ \frac{ \lambda + 2\mu }{ \rho} }$$ $$\beta = \sqrt{ \frac{\mu}{\rho} }$$ 泊松比 $\nu$： $$\nu = \frac{\lambda}{ 2(\mu + \lambda) }$$ 弹性常数 $c_{jklm}$，体积模量 $\kappa$ 和弹性模量 $E$： $$c_{jklm} = \Big(\kappa - \frac{2\mu}{3}\Big) \delta_{jk}\delta_{lm} + \mu (\delta_{jl}\delta_{km} + \delta_{jm}\delta_{kl})$$ $$\kappa = \lambda + \frac{2}{3} \mu$$ $$E = \frac{\mu (3\lambda + 2\mu)}{\lambda + \mu}$$ 其中，$\rho$ 为密度，$\lambda$ 和 $\mu$ 为拉梅参数。 波动方程弹性波在各向同性介质中，弹性波波动方程有以下几种形式： 二阶位移方程组：$\rho u_{i,tt} = (\lambda u_{k,k})_{,i} + (\mu u_{i,j})_{,j} + (\mu u_{j,i})_{,j} + f_i$ 位移-应力方程组：$\begin{cases} \rho u_{i,tt} = \sigma_{ij,j} + f_i \newline \sigma_{ij} = \lambda u_{k,k} \delta_{ij} + \mu (u_{i,j} + u_{j,i}) \end{cases}$ 一阶速度-应力方程组：$\begin{cases} \rho v_{i,t} = \sigma_{ij,j} + f_i \newline \sigma_{ij,t} = \lambda v_{k,k} \delta_{ij} + \mu (v_{i,j} + v_{j,i}) \end{cases}$ 其中，$u$ 为位移场，$v$ 为速度场，$\sigma$ 为应力场，$f$ 为力源项，$\rho$ 为介质密度，$\lambda$ 和 $\mu$ 为介质的拉梅参数。]]></content>
      <categories>
        <category>Math, Physics</category>
      </categories>
      <tags>
        <tag>Basic formula</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造一个简单的滤波器]]></title>
    <url>%2F2019%2F06%2F24%2FCreate-a-Filter%2F</url>
    <content type="text"><![CDATA[一个简单的低通滤波器本文译自 How to Create a Simple Low-Pass Filter。 低通意即仅允许低频通过，阻滞高频。sinc 滤波器就是一个理想的低通滤波器。信号处理中常用的、正则化的 sinc 函数定义为： $$\text{sinc} (x)=\frac{\sin(\pi x)}{\pi x}$$ 由于 sinc 函数的傅里叶变换的结果即是关于 $y$ 轴对称的矩形函数（rectangular function），在 $x$ 轴正半部分即为一个理想的低通滤波时窗，当与输入信号褶积时，sinc 滤波器即可得到一个仅包含所有截止频率以下成分的输出信号。 sinc 滤波器为设计一个数字滤波器，需要先将连续的 sinc 函数归一化，再逐点采样生成一个序列。定义 sinc 滤波器的脉冲响应： $$h[n] = 2f_c \text{sinc} (2 f_c n)$$ 这里的 $f_c$ 是经采样频率分数特征化后的截止频率。例如，采样频率为 1000 Hz ，取 $f_c = 0.01 = 10/1000$ 时即将去除信号中高于 10 Hz 的频率成分。 然而，由于 sinc 函数是无限长的，在设计滤波器时，需要将其在某处截断，这就会在滤波结果中引起持续的振荡。这时，最容易想到的解决方法就是，在 sinc 滤波器上叠加一个时窗，使滤波器在时窗边界处趋近于 $x$ 轴。 时窗窗函数即一个在某一区间外值全为 0 的函数。作为其中比较常用的一种，Blackman 窗的定义为： $$w[n] = 0.42 - 0.5 \cos\Big(\frac{2 \pi n}{N - 1}\Big) + 0.08 \cos\Big(\frac{4 \pi n}{N - 1}\Big)$$ 其中 $n\in [0, N - 1]$。 时窗 sinc 滤波器根据上面给出的定义，可以得到时窗 sinc 滤波器在区间 $[0, N - 1]$ 内的表达式为： $$h[n] = \text{sinc} \Big(2 f_c \big(n - \frac{N - 1}{2}\big)\Big) \Big(0.42 - 0.5 \cos\big(\frac{2 \pi n}{N - 1}\big) + 0.08 \cos\big(\frac{4 \pi n}{N - 1}\big) \Big)$$ 对于 $n \notin [0, N - 1]$，$h[n] = 0$。这里省略了 sinc 滤波器的系数 $2 f_c$，因为还需要进行正则化，以得到单位滤波增益： $$h_{\text{normalized}} [n] = \frac{h[n]}{\sum_{i=0}^{N - 1} h[i]}$$ 过渡带宽采样频率分数特征化的过渡带宽 $b$ 和滤波器长度 $N$ 之间有一个近似关系： $$b \approx \frac{4}{N}$$ 根据此式，在设定过渡带宽后，即可求出合适的滤波器长度。此外，一般取 N 为奇数，以确保滤波器峰值的两侧有相同的采样点数。例如，采样频率为 1000 Hz，欲得到 1 Hz 的过渡带宽，即 $b = 1/1000 = 0.001$，取 $N = 4001$ 即可。 Python 代码如下即是上述低通滤波器的示例生成代码： 1234567891011121314151617181920import numpy as np fc = 0.1 # Cutoff frequency as a fraction of the sampling rate (in (0, 0.5)).b = 0.08 # Transition band, as a fraction of the sampling rate (in (0, 0.5)).N = int(np.ceil((4 / b)))if not N % 2: N += 1 # Make sure that N is odd.n = np.arange(N) # Compute sinc filter.h = np.sinc(2 * fc * (n - (N - 1) / 2)) # Compute Blackman window.w = 0.42 - 0.5 * np.cos(2 * np.pi * n / (N - 1)) + \ 0.08 * np.cos(4 * np.pi * n / (N - 1)) # Multiply sinc filter by window.h = h * w # Normalize to get unity gain.h = h / np.sum(h) 通过将滤波器 $h$ 与信号 $s$ 褶积，即可得到低通滤波的结果：s = np.convolve(s, h)。 在实际信息处理过程中，褶积会导致输出信号与输入信号长度不一致，此时只需将输出信号向后时延 $(N - 1)/2​$ 个数据点后，再截取与输入信号等长的信号段即可。 另外，Blackman 窗也可通过语句 w = np.balckman(N) 直接生成。 一个简单的高通滤波器 本文译自 How to Create a Simple High-Pass Filter。 前面已经介绍了低通滤波器的构造，通过频谱反转（Spectral inversion）即可将一个低通滤波器转化为一个高通滤波器。 从低通到高通低通滤波会去除信号中的高频成分，如果我们从信号中减去低通滤波信号，剩下的便只是信号中的高频成分。据此，我们可以构造一个简单的高通滤波器。 首先，对信号作低通滤波： $$x_{\text{lpf}}[n] = x[n] * h_{\text{lpf}}[n]​$$ 其中，$x[n]$ 为原始信号，$h_{\text{lpf}}[n]$ 为低通滤波器，$x_{\text{lpf}}[n]$ 即低通滤波信号，$*$ 表示褶积。接着，从原始信号中减去低通滤波信号： $$x_{\text{hpf}}[n] = x[n] - x_{\text{lpf}}[n]$$ 得到的 $x_{\text{hpf}}[n]​$ 即为高通滤波信号。 从上述各式中，我们可以得到： $$x_{\text{hpf}}[n] = x[n] - x_{\text{lpf}}[n] = x[n] * \delta[n] - x[n] * h_{\text{lpf}}[n] = x[n] * (\delta[n] - h_{\text{lpf}}[n])$$ 因此，高通滤波器可以定义为： $$h_{\text{hpf}}[n] = \delta[n] - h_{\text{lpf}}[n]$$ 频谱反转上述即为频谱反转的理论原理，其具体做法为： 构造一个简单的低通滤波器 $h[n]$； 改变低通滤波器中所有元素的符号； 给滤波器中心的元素加上 1。 Python 代码如下即是上述高通滤波器的示例生成代码： 1234567891011121314151617import numpy as np fc = 0.1 # Cutoff frequency as a fraction of the sampling rate (in (0, 0.5)).b = 0.08 # Transition band, as a fraction of the sampling rate (in (0, 0.5)).N = int(np.ceil((4 / b)))if not N % 2: N += 1 # Make sure that N is odd.n = np.arange(N) # Compute a low-pass filter.h = np.sinc(2 * fc * (n - (N - 1) / 2))w = np.blackman(N)h = h * wh = h / np.sum(h) # Create a high-pass filter from the low-pass filter through spectral inversion.h = -hh[(N - 1) // 2] += 1 一个简单的带通滤波器本文译自 How to Create Simple Band-Pass and Band-Reject Filters。 前面已经介绍了低通和高通滤波器的构造，通过简单组合即可利用一个低通滤波器和一个高通滤波器构造出一个带通滤波器。 带通滤波带通滤波即保留下截止频率 $f_L$ 和上截止频率 $f_H$ 之间的频率成分，阻滞区间外的所有频率。为此，我们首先以 $f_H$ 为截止频率对原始信号进行低通滤波： $$x_{\text{lpf,H}}[n] = x[n] * h_{\text{lpf,H}}[n]$$ 其中，$x[n]$ 为原始信号， $h_{\text{lpf,H}}[n]$ 为以 $f_H$ 为截止频率的低通滤波器，$x_{\text{lpf,H}}[n]$ 为低通滤波信号，$*$ 表示褶积。再以 $f_L$ 为截止频率对低通滤波信号进行高通滤波： $$x_{\text{bpf,LH}}[n] = x_{\text{lpf,H}}[n] * h_{\text{hpf,L}}[n]$$ 其中，$h_{\text{hpf,L}}[n]$ 为以 $f_L$ 为截止频率的高通滤波器，$x_{\text{bpf,LH}}[n]$ 即为最终的带通滤波信号。 根据褶积的结合律，由： $$x_{\text{bpf,LH}}[n] = (x[n] * h_{\text{lpf,H}}[n]) * h_{\text{hpf,L}}[n] = x[n] * (h_{\text{lpf,H}}[n] * h_{\text{hpf,L}}[n])$$ 定义带通滤波器为： $$h_{\text{bpf,LH}}[n] = h_{\text{lpf,H}}[n] * h_{\text{hpf,L}}[n]$$ Python 代码如下即是上述带通滤波器的示例生成代码： 1234567891011121314151617181920212223import numpy as np fL = 0.1 # Cutoff frequency as a fraction of the sampling rate (in (0, 0.5)).fH = 0.4 # Cutoff frequency as a fraction of the sampling rate (in (0, 0.5)).b = 0.08 # Transition band, as a fraction of the sampling rate (in (0, 0.5)).N = int(np.ceil((4 / b)))if not N % 2: N += 1 # Make sure that N is odd.n = np.arange(N) # Compute a low-pass filter with cutoff frequency fH.hlpf = np.sinc(2 * fH * (n - (N - 1) / 2))hlpf *= np.blackman(N)hlpf = hlpf / np.sum(hlpf) # Compute a high-pass filter with cutoff frequency fL.hhpf = np.sinc(2 * fL * (n - (N - 1) / 2))hhpf *= np.blackman(N)hhpf = hhpf / np.sum(hhpf)hhpf = -hhpfhhpf[(N - 1) // 2] += 1 # Convolve both filters.h = np.convolve(hlpf, hhpf) 一个简单的带阻滤波器本文译自 How to Create Simple Band-Pass and Band-Reject Filters。 前面已经介绍了低通和高通滤波器的构造，通过简单组合即可利用一个低通滤波器和一个高通滤波器构造出一个带通滤波器。 带阻滤波带阻滤波即保留下截止频率 $f_L$ 和上截止频率 $f_H$ 之外的频率成分，阻滞区间内的所有频率。为此，我们首先以 $f_L$ 为截止频率对原始信号进行低通滤波： $$x_{\text{lpf,L}}[n] = x[n] * h_{\text{lpf,L}}[n]$$ 其中，$x[n]$ 为原始信号，$h_{\text{lpf,L}}[n]$ 为以 $f_L$ 为截止频率的低通滤波器，$x_{\text{lpf,L}}[n]$ 为低通滤波信号，$*$ 表示褶积。再以 $f_H$ 为截止频率对原始信号进行高通滤波： $$x_{\text{hpf,H}}[n] = x[n] * h_{\text{hpf,H}}[n]$$ 其中，$h_{\text{hpf,H}}[n]$ 为以 $f_H$ 为截止频率的高通滤波器，$x_{\text{hpf,H}}[n]$ 为带通滤波信号。将低通滤波信号与高通滤波信号叠加： $$x_{\text{brf,LH}}[n] = x_{\text{lpf,L}}[n] + x_{\text{hpf,H}}[n]$$ 这里 $x_{\text{brf,LH}}[n]$ 即为最终的带阻滤波信号。 根据褶积的分配律，由： $$x_{\text{brf,LH}}[n] = x[n] * h_{\text{lpf,L}}[n] + x[n] * h_{\text{hpf,H}}[n] = x[n] * (h_{\text{lpf,L}}[n] + h_{\text{hpf,H}}[n])$$ 定义带阻滤波器： $$h_{\text{brf,LH}}[n] = h_{\text{lpf,L}}[n] + h_{\text{hpf,H}}[n]$$ Python 代码如下即是上述带阻滤波器的示例生成代码： 1234567891011121314151617181920212223import numpy as np fL = 0.1 # Cutoff frequency as a fraction of the sampling rate (in (0, 0.5)).fH = 0.4 # Cutoff frequency as a fraction of the sampling rate (in (0, 0.5)).b = 0.08 # Transition band, as a fraction of the sampling rate (in (0, 0.5)).N = int(np.ceil((4 / b)))if not N % 2: N += 1 # Make sure that N is odd.n = np.arange(N) # Compute a low-pass filter with cutoff frequency fL.hlpf = np.sinc(2 * fL * (n - (N - 1) / 2))hlpf *= np.blackman(N)hlpf /= np.sum(hlpf) # Compute a high-pass filter with cutoff frequency fH.hhpf = np.sinc(2 * fH * (n - (N - 1) / 2))hhpf *= np.blackman(N)hhpf /= np.sum(hhpf)hhpf = -hhpfhhpf[(N - 1) // 2] += 1 # Add both filters.h = hlpf + hhpf 一个简单的应用示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#!/usr/bin/env python3import numpy as np def lowFIR(fc = 0.1, b = 0.08): #fc: Cutoff frequency as a fraction of the sampling rate (in (0, 0.5)). #b: Transition band, as a fraction of the sampling rate (in (0, 0.5)). N = int(np.ceil((4 / b))) if not N % 2: N += 1 # Make sure that N is odd. n = np.arange(N) # Compute sinc filter. h = np.sinc(2 * fc * (n - (N - 1) / 2)) # Compute Blackman window. w = 0.42 - 0.5 * np.cos(2 * np.pi * n / (N - 1)) + \ 0.08 * np.cos(4 * np.pi * n / (N - 1)) # Multiply sinc filter by window. h = h * w # Normalize to get unity gain. h = h / np.sum(h) return N, h#-------------------------------------------------------------------------------def highFIR(fc = 0.1, b = 0.08): #fc: Cutoff frequency as a fraction of the sampling rate (in (0, 0.5)). #b: Transition band, as a fraction of the sampling rate (in (0, 0.5)). N = int(np.ceil((4 / b))) if not N % 2: N += 1 # Make sure that N is odd. n = np.arange(N) # Compute sinc filter. h = np.sinc(2 * fc * (n - (N - 1) / 2)) # Compute Blackman window. w = 0.42 - 0.5 * np.cos(2 * np.pi * n / (N - 1)) + \ 0.08 * np.cos(4 * np.pi * n / (N - 1)) # Multiply sinc filter by window. h = h * w # Normalize to get unity gain. h = h / np.sum(h) # Create a high-pass filter from the low-pass filter through spectral inversion. h *= - 1 h[(N - 1) // 2] += 1 return N, h#-------------------------------------------------------------------------------def passFIR(fL = 0.1, fH = 0.4, b = 0.08): N = int(np.ceil(4 / b)) if not N % 2: N += 1 n = np.arange(N) hlpf = np.sinc(2 * fH * (n - (N - 1) / 2)) hlpf *= np.blackman(N) hlpf /= np.sum(hlpf) hhpf = np.sinc(2 * fL * (n - (N - 1) / 2)) hhpf *= np.blackman(N) hhpf /= np.sum(hhpf) hhpf *= - 1 hhpf[(N - 1) // 2] += 1 h = np.convolve(hlpf, hhpf) return 2*N - 1, h#-------------------------------------------------------------------------------def stopFIR(fL = 0.1, fH = 0.4, b = 0.08): N = int(np.ceil(4 / b)) if not N % 2: N += 1 n = np.arange(N) hlpf = np.sinc(2 * fL * (n - (N - 1) / 2)) hlpf *= np.blackman(N) hlpf /= np.sum(hlpf) hhpf = np.sinc(2 * fH * (n - (N - 1) / 2)) hhpf *= np.blackman(N) hhpf /= np.sum(hhpf) hhpf *= - 1 hhpf[(N - 1) // 2] += 1 h = hlpf + hhpf return N, h#-------------------------------------------------------------------------------import matplotlib.pyplot as pltfs = 1000 # sampling frequency# generate properly the time vectort = np.arange(1000)/fssga = np.sin(2*np.pi*2*t) # signal with f = 2sgb = np.sin(2*np.pi*6*t) # signal with f = 6sgc = np.sin(2*np.pi*10*t) # signal with f = 10sgd = sga + sgcsge = sga + sgb + sgcif 1: plt.plot(t, sga, label = 'f = 2') plt.plot(t, sgc, label = 'f = 10') plt.plot(t, sgd, label = 'f = 2 + 10') N, h = lowFIR(fc = 5/fs, b = 2/fs) sgf = np.convolve(sgd, h) plt.plot(t, sgf[int(N/2):1000 + int(N/2)], label = 'low-pass') N, h = highFIR(fc = 5/fs, b = 2/fs) sgf = np.convolve(sgd, h) plt.plot(t, sgf[int(N/2):1000 + int(N/2)], label = 'high-pass')else: plt.plot(t, sgb, label = 'f = 6') plt.plot(t, sgd, label = 'f = 2 + 10') plt.plot(t, sge, label = 'f = 2 + 6 + 10') N, h = passFIR(fL = 4/fs, fH = 8/fs, b = 1/fs) sgf = np.convolve(sge, h) plt.plot(t, sgf[int(N/2):1000 + int(N/2)], label = 'band-pass') N, h = stopFIR(fL = 4/fs, fH = 8/fs, b = 1/fs) sgf = np.convolve(sge, h) plt.plot(t, sgf[int(N/2):1000 + int(N/2)], label = 'band-stop')plt.legend()plt.show()]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Singal Process</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地空系并行集群管理]]></title>
    <url>%2F2019%2F04%2F05%2FESS-Cluster%2F</url>
    <content type="text"><![CDATA[创建或删除用户先以命令 [root@mn01 ~]$ adduser username 创建新用户 username 生成相应的用户信息，或以命令 [root@mn01 ~]$ userdel -rf username 删除原用户 username 并删除该用户的用户信息，再以命令 [root@mn01 ~]$ make -C /var/yp 将管理节点（mn01）的用户信息发送到所有计算节点。 修改用户密码先以命令 [root@mn01 ~]$ passwd username 修改管理节点的用户密码，再以命令 [root@mn01 ~]$ make -C /var/yp 将新的用户信息发送出去。 集群系统关机 [root@mn01 ~]$ psh compute poweroff 关闭所有计算节点； [root@mn01 ~]$ mmshutdown -N io01,io02,mn01 关闭 io 节点和管理节点的 GPFS 服务； [root@mn01 ~]$ psh io poweroff 关闭 io 节点； [root@mn01 ~]$ poweroff 关闭管理节点。 重新启动集群启动顺序启动时，先启动管理节点（mn01），再启动 io 节点（io*），最后启动计算节点（c0* 和 s0*）。为保险起见，不同类型节点启动适当间隔一段时间，以等待相应的依赖服务启动完成。 重启检查先以命令 [user@mn01 ~]$ lnodes 查看各计算节点连接情况，保证无异常状态（unavail 或 unreach）节点。 若上述命令长时间无响应，说明 LSF 作业系统未完成启动，尝试以如下命令完成启动： [root@mn01 ~]$ mmstartup -a 确保 GPFS 服务已经启动； [root@mn01 ~]$ source /share/lsf/lsf/conf/profile.lsf 导入 LSF 系统配置； [root@mn01 ~]$ systemctl restart lsfd 启动管理节点的 LSF 服务； [root@mn01 ~]$ psh compute &quot;systemctl restart lsfd&quot; 启动计算节点的 LSF 服务。 待所有节点连接正常后，再以 test 身份登录至管理节点，以命令 [test@mn01 ~]$ /share/apps/matlab/etc/lmstart 启动 matlab 的 License 管理器，激活该软件的正版授权。 排查错误集群启动完成后，登录管理节点，若出现告错 12-bash: /opt/ibm/lsfsuite/lsf/conf/profile.lsf: No such file or directory-bash: /opt/ibm/lsfsuite/ext/ppm/conf/profile.js: No such file or directory 则说明 GPFS 服务没有启动，以命令 [root@mn01 ~]$ mmstartup -a 启动该服务即可。 集群启动完成后，若以命令 [user@mn01 ~]$ lnodes 查看节点连接情况，发现部分节点为 unavil 状态，则先以命令 [root@mn01 ~]$ mmstartup -N nodename 启动该节点的 GPFS 服务后，再以命令 [root@mn01 ~]$ psh nodename &quot;systemctl restart lsfd&quot; 启动该节点的 LSF 服务即可。或者以 root 身份登录至相应节点，分别以命令 [root@A ~]$ mmstartup 和 [root@A ~]$ systemctl restart lsfd 重启这两个系统服务也可。 LSF 队列管理队列状态通过命令 [user@mn01 ~]$ bqueues 可查看各个队列的当前状态。队列状态描述的是队列接收和派发作业的能力，有如下组合： 状态 描述 Open: Active 接收并派发作业，正常处理中 Open: Inactive 只接收但不派发作业，正在收集作业 Closed: Active 只派发但不接收作业，正在排空队列 Closed: Inactive 既不接收也不派发作业，停止所有活动 队列控制LSF 管理员或 root 用户可以通过以下命令来控制队列 queuename： 以命令 [root@mn01 ~]$ badmin qopen queuename 开启队列，该队列开始接收新的作业； 以命令 [root@mn01 ~]$ badmin qclose queuename 关闭队列，该队列不再接收新的作业； 以命令 [root@mn01 ~]$ badmin qact queuename 激活队列，该队列开始派发作业； 以命令 [root@mn01 ~]$ badmin qinact queuename 阻塞队列，该队列停止派发作业。 LSF 作业系统的配置LSF 作业系统的主要配置文件位于 /share/lsf/lsf/conf 目录下，该目录已软链接到 LSF 的安装目录下，修改配置并重新启动相应的 LSF 服务后，新的配置参数即可生效。具体地， 用户群组配置文件为 /share/lsf/lsf/conf/lsbatch/sustc_ess/configdir/lsb.users； 主机群组配置文件为 /share/lsf/lsf/conf/lsbatch/sustc_ess/configdir/lsb.hosts； 调度参数配置文件为 /share/lsf/lsf/conf/lsbatch/sustc_ess/configdir/lsb.params； 队列配置文件为 /share/lsf/lsf/conf/lsbatch/sustc_ess/configdir/lsb.queues； LSF 主配置文件为 /share/lsf/lsf/conf/lsf.conf。 LSF 系统动态优先级的计算LSF 作业系统会根据用户作业的作业槽数、运行时间和累积核时等资源占用情况，实时调整用户在队列的优先级，即动态优先级。 LSF 系统默认的动态优先级计算公式为： dynamic_priority = number_shares/(cpu_time*CPU_TIME_FACTOR + run_time*RUN_TIME_FACTOR + (1 + job_slots)*RUN_JOB_FACTOR + fairshare_adjustment*FAIRSHARE_ADJUSTMENT_FACTOR) 其中，cpu_time、run_time 和 job_slots 是 LSF 系统收集的用户总资源消耗；CPU_TIME_FACTOR、RUN_TIME_FACTOR 和 RUN_JOB_FACTOR 为权重因子，默认值分别为 0.7、0.7 和 3，可在 lsb.queues 或 lsb.params 中设置。 另外，lsb.queues 或 lsb.params 中的 HIST_HOURS 参数为 LSF 系统收集资源消耗历史的时间间隔，默认值为 5。 GPFS 文件系统磁盘配额在创建新的 GPFS 文件系统时，可在 mmcrfs 命令中加入 -Q yes 选项，以激活该文件系统的磁盘配额设置。对于原有的 GPFS 文件系统，可以命令 [root@mn01 ~]$ mmchfs -Q yes 重新激活该系统的磁盘配额设置。若想针对目录进行磁盘配额，需指定 –perfileset-quota 选项。 GPFS 文件系统可以 mmsetquota 命令设置磁盘配额，具体可根据该命令的帮助（以命令 [user@mn01 ~]$ man mmsetquota 查看）来进行详细的配置。 当前 fs01 文件系统的用户默认磁盘配额是由 stanza 文件 /share/system/conf/quoatesetting 设置的（设置命令为 [root@mn01 ~]$ mmsetquota -F /share/system/conf/quotasetting）。 通过命令 [root@mn01 ~]$ mmsetquota filesystemname --user username --block 2T:2560G，可对 username 用户单独设置 filesystemname 文件系统的磁盘配额。 在设置软硬限制时，指定 0: 即为无任何限制，可用于取消原有限制。 通过命令行执行命令生效的 GPFS 文件系统的磁盘配置，即永久生效，即使重启集群系统也不会失效。 注意，当针对整个文件系统进行配额设置（即 mmcrfs 或 mmchfs 命令中不指定 –perfileset-quota 选项）时，则不可在 mmsetquota 命令中指定 fileset 选项，否则该命令不会生效。 一些疑问zsh 启动时报错找不到 complete 命令，该如何解决？ 这个命令是 bash 的内建命令，而调用该命令的脚本是用来收集系统管理信息的，若禁止加载该脚本，会导致部分管理功能的缺失。考虑到 zshell 的使用者不多，不建议禁止该脚本的加载。 LSF 系统在识别计算节点的 CPU 核数跟 htop 工具识别出来的核数有区别，这是为什么？ 这应该是因为 LSF 系统识别出来的是物理核数，而 htop 识别出来的是逻辑核数，而有些节点可能没有开启超线程设置。不过无论如何，LSF 系统调用的核数皆以该系统自动识别出来的核数为准。 存储节点只连接一根网线会影响使用吗？ 不影响使用，但会影响性能。在硬件允许的情况下，应把两根网线都连接上。 集群系统关机后存储节点指示灯依然常亮，此时若突然断电会对所存储的数据造成影响吗？ 在集群系统已关机的情况下，已停止了所有节点对存储节点的读写操作，即断电不再会对数据安全构成威胁。另外，存储节点也没有单独的关机指令，也就没有其他可执行的额外操作了。 计算节点的硬盘可以利用起来吗？ 计算节点的硬盘只能用来安装系统，无法共享出来供用户使用。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神奇的贝叶斯理论]]></title>
    <url>%2F2018%2F12%2F08%2FBayes-theorem%2F</url>
    <content type="text"><![CDATA[概率论只不过是把常识用数学公式表达了出来。（From Laplace） 历史根据维基，所谓的贝叶斯方法起源于逆向概率问题。正向概率问题很常见，如「已知一个袋内有 N 个白球和 M 个黑球，伸手进去摸一球，问摸出黑球的概率几何」；而反过来，一个相应的逆向概率问题可以是「现不知袋中黑白球的个数，在经过多次取出放入后，根据取出球的颜色求袋中黑白球的比例」。可见，逆概问题即，不知实际模型如何，但知观测数据怎样，求模型。 对于逆概问题，我们可以先给出若干个假设，然后求出不同假设的可能性（假设本身成立的概率，即先验概率）和可靠性（由假设得到观测的概率，即似然），其中最可能又可靠的假设即为所求。 第一个例子在使用 Office Word 写作时，我们会发现一个非常人性化的功能，叫拼写纠正。 在攻城狮实现这一功能时就涉及到一个概率问题，比如用户输入 thwn，那么可以猜测用户本意输入 than 或者 then，讲道理，在显示这两个纠正选项时应该按可能性排序，那么问题来了，到底哪个纠正选项可能性更大呢？怎么看起来好像两个选项是等可能的？ 又一个例子下面展示的是自然语言的歧义性： 1The girl saw the boy with a telescope. 作者想通过这句话表达什么意思呢？这个句子该如何理解？「那个女孩用望远镜看见了那个男孩 (The girl saw-with-a-telescope the boy) 」？也可以吧，但有没有另一种可能？「那个女孩看见了那个拿着望远镜的男孩 (The girl saw the-boy-with-a-telescope) 」怎样呢？ 那么问题也来了，为什么我们大部分人在这两种理解中优先选择了前者？其实，我们的选择过程中就隐藏着一个贝叶斯理论的应用。 还有一个例子这里在平面上给出 $N$ 个点，求一个函数拟合这些离散点。 贝叶斯公式贝叶斯理论有一个很简单的公式，绝不是「非专人所不能理解」的那种： $$P(B|A)=\frac{P(A|B)\times P(B)}{P(A)}=\frac{P(A|B)\times P(B)}{P(A|B)\times P(B)+P(A|\sim B)\times P(\sim B)}$$ 也就是，$P(B|A)=\frac{P(AB)}{P(A)}$ 或者 $P(B|A)\times P(A)=P(AB)$。 是的，贝叶斯理论就是一个简单而又深刻的生活道理：两件事同时发生的可能性，就是一件事发生的可能性和一件事发生的情况下另一件事发生的可能性的乘积。 基本的贝叶斯公式给出了一个启示：我们现在有一个观测数据 A 和一个假设模型 B，对于不同的假设模型都有一个恒定不变的观测数据的可能性 $P(A)$（在只有实际模型才会影响观测结果的提前下，可认为这个概率为 1），那么 $P(B|A)\propto P(B)\times P(A|B)$，即这个观测数据是由这个假设模型产生的的可能性 $P(B|A)$，由这个模型本身的可能性 $P(B)$（我们常常忽略这一点）和这个模型产生这个数据的可能性 $P(B|A)$（我们常常用拟合度来表征）的乘积决定。 也就是说： 对于给定的观测数据，一个假设模型是好是坏，取决于「这个假设模型本身独立的可能性大小（先验概率，Prior ）」和「这个假设模型生成我们的观测数据的可能性大小（似然，Likelihood ）」的乘积。 奥卡姆剃刀与最大似然我们总是希望透过表象看本质，却又往往容易被表象所迷惑而看不到本质。总结起来，在这里迷惑我们的就是奥卡姆剃刀或最大似然。 奥卡姆剃刀回到前述第一个例子，为什么我们觉得两个猜测 than 或 then 是等可能的？因为这两个单词的常见程度相近。在这里，迷惑我们的就是奥卡姆剃刀。 奥卡姆剃刀认为，先验概率最大的模型具有最大的优势，即 $P(B|A)\propto P(B)$。一个假设模型越平凡，越常见，它本身的概率越大，这个模型就越好，越可能是隐藏在观测数据背后的真实模型。 是的，我们很容易发觉，奥卡姆剃刀太片面了。就在上述的拼写纠正的例子中，两个猜测的常见程度相近，先验概率约等，这可让有强迫症的攻城狮们如何是好？就算两个纠正选项的好坏程度相同，也不能把两个排布在候选列表的同一个位置啊。对，这就是一个奥卡姆剃刀应用失败的例子，因为它回答不了我们的问题，比较不出两个假设模型的好坏差异（那么一个问题，如何才能合理地对这两个猜测作出一个优胜劣汰的评断呢？留给后面作讨论）。 对于上述的函数拟合的例子，奥卡姆剃刀告诉我们，要用最常见最普通的函数，也即一阶多项式（直线）。虽然在这些离散点趋于共线的情况下，奥卡姆剃刀给了我们一个简单直接而又合理的方案，这时的直线拟合已经能我们满意了；但对于离散点趋于呈拋物线，甚至更高阶多项式分布的情况下，我们就不能在奥卡姆剃刀的指导下用再去用一条直线去拟合离散点了。在第一种情况下，直线并不能保证精确地穿过所有离散点，即数据还不能完美匹配，但我们却觉得这样做还是可靠的，为什么呢？因为实践告诉我们，在一个直线上随意地取一些离散点，在拾取这些点位坐标时存在着不可避免的观测误差，这些误差会导致拾取到的离散点不再共线。 最大似然回到前述第二个例子，为什么我们很习惯地就形成了第一种理解呢？因为采用第二种语句结构不太可能恰好形成如上的表述。在这里，迷惑我们的又是最大似然。 最大似然认为，似然程度最大的模型具有最大的优势，即 $P(B|A)\propto P(A|B)$。一个假设模型越可能生成我们的观测数据（常用假设模型的仿真数据和观测数据的契合程度来表征），这个模型就越好。 在上述的语言歧义的例子中，若作者真正想表述的是第一种理解，那么这个 telescope 就必须是一个可以「目光透过」的东西，即第一种语句结构形成如上表述的可能性就大概是，从一堆可以「目光透过」的东西中取出 telescope 的可能性；若是第二种理解，男孩手里的几近是任何可以随身的东西，这种语句结构的可能性就差不多为，从大千世界的琳琅满目的几乎不受限定的东西中取出 telescope 的可能性，即接近零。就这样，最大似然诱导我们悄悄地做出了选择。 这里扩展一下，如果把前述语句中的 telescope 换成 telephone 又该如何理解？我们的直觉很快告诉我们，应该是第二种理解。继续，为什么呢？因为此时第一种语句结构是要从一堆可以「目光透过」的东西中取出 telephone，这种可能性直直地为零，telephone 明明不能「目光透过」的嘛。 是的，该轮到批评最大似然了，即使它在语言歧义的例子中应用得很成功（那么又一个问题，为什么它在这里这么成功？后面再讨论）。 同样地，对于函数拟合的例子，最大似然告诉我们，要用与离散点拟合效果最好的函数，也即 $N-1$ 阶多项式。虽然在离散点的离散程度很大的情况下，这样拟合会可能得到一个比较合理的方案；但在离散点本就近似共线的情况下，再用高阶多项式去拟合，就不大合适了。在第二种情况下，高阶函数曲线能精确地穿过所有离散点，即数据能完美匹配，但我们却觉得这样做并不可靠，为什么呢？因为实践告诉我们，从一个高阶函数曲线上随意地取一些离散点，而这些点恰好近似共线的可能性却几乎为零。就是最大似然所谓的数据过配（overfitting）问题，即过分地寻求能够完美解释观测数据的模型。 这里告诉我们，数据过配不好，但从理论上来说，为什么不好？因为实践中数据的观测存在误差，在我们离散取点拾取坐标时会引入人为误差，如果过分地追求数据完美匹配，也就在用模型解释观测的同时，努力地用部分模型贡献去解释这些误差，而误差却不是由模型产生的，这就会导致我们的假设模型偏离真实模型。 问题的最终解决对于由观测到模型的问题，前面介绍了两种简单方便却都以偏盖全的方法。到这里，问题的最终解决，就要依靠贝叶斯理论了。 第一个例子前面提到，奥卡姆剃刀在拼写纠正中应用失败，那我们在这里应该如何安排两个猜测 than 和 then 在候选列表里的先后顺序呢？随便，谁先谁后都一样？那不科学。非要排个坐次？那就需要贝叶斯理论出场了。 在这个例子中，奥卡姆剃刀说，两个猜测的先验概率基本相同，那我们再考虑一下两个猜测的似然程度。经常使用键盘就会发现，e 键比 a 键离 w 键更近，我们更可能在手指抽动的时候将 e（而非 a）错敲成 w，所以相比之下，thwn 更可能是 then 的错误拼写，也就是说，then 的似然程度更高。根据贝叶斯理论 ，先验概率相同，似然越大，二者相乘，则模型越好。进一步地，我们就可以心安理得地在候选列表里将 then 安排在 than 的前面了。 还是那个例子前面说到，最大似然在语言歧义的例子中应用得很成功，但是为什么它在这里就成功了呢？其实也还是因为贝叶斯理论。 在这个例子中，最大似然说，两种语句结构的似然程度不同，不过我们还是来考虑一下两种语句结构的先验概率。咦，两种语句结构（see-with-sth. sb. 和 see sb.-with-sth.）所表达的场景的常见程度差不多唉，那就是说它俩的先验概率也基本相同呀。对，在先验概率 $P(B)$ 相同的情况下，贝叶斯理论 $P(B|A)\propto P(B)\times P(A|B)$ 也就退化成了最大似然 $P(B|A)\propto P(A|B)$。所以，最大似然才会在这个例子中应用得如此成功。 最后一个例子我们已经在前面看到了，在函数拟合时，既不能单纯地采用奥卡姆剃刀也不能单纯地采用最大似然来指导我们的工作。这时候，就得祭出大杀器贝叶斯理论了。 函数拟合这个例子比较复杂，我们应该始终秉承贝叶斯理论的思想，即同时考虑模型的先验概率和似然程度。在离散点分布有一定规律时，先用不同阶的多项式拟合，计算得到拟合误差（似然程度），再在可容忍的误差范围内的不同阶中选择更低阶的多项式（先验概率）。 至此，贝叶斯理论就完美解决了上述所有困扰我们的问题。]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Ubuntu 的陈年往事]]></title>
    <url>%2F2018%2F11%2F28%2FTips-of-Ubuntu%2F</url>
    <content type="text"><![CDATA[Ubuntu 启动栏图标自定义设置个人有时的误操作会导致 Ubuntu 启动栏某些软件的图标消失，变成一个大大的问号「？」，为了挽救难看的启动栏，这里学习一下 Ubuntu 启动栏图标的实现原理： 在目录 /usr/share/applications 下可以看到，这里有很多以 .desktop 结尾的文件，其实这些文件就是 Ubuntu 启动栏各个软件图标的设置文件。 这里以 firefox 火狐浏览器（是的，我就是把它的图标搞丢了 😐）为例介绍启动图标的设置。可自行新建或修改一个以 firefox.desktop 文件，写入或修改内容： 12345678[Desktop Entry]Name=Firefox 63.0.3Comment=this is firefoxExec=/opt/firefox/firefoxIcon=/opt/firefox/browser/chrome/icons/defaults/default128.pngTerminal=falseType=ApplicationCategories=Application;Network; 其中，较为重要的几个，Name 字段即启动图标鼠标悬停提示，Exec 字段即启动图标对应的可执行程序，Icon 字段为启动图标的 icon 文件。 修改 Ubuntu 默认终端在考虑到多终端窗口分屏显示时，可以采用命令 [root@A ~]$ apt-get install terminator 安装新的终端工具 Terminator 。但在安装该工具后会自动设置默认终端为 Terminator，可通过如下命令重置默认终端为系统自带的 gnome-terminal： gsettings set org.gnome.desktop.default-applications.terminal exec /usr/bin/gnome-terminal gsettings set org.gnome.desktop.default-applications.terminal exec-arg &quot;-x&quot; FoxitReader 支持中文输入在安装完 Linux 平台的 FoxitReader （版本号：2.4.4.0910）后，FoxitReader 默认是不支持中文输入的。在 FoxitReader 安装目录下的 FoxitReader.sh 脚本文件中加入环境变量 GTK_IM_MODULE、QT_IM_MODULE 和 XMODIFIERS 的设置，即添加 gtk、qt 等对 fcitx 的支持： 12345678#!/bin/sh appname="FoxitReader" selfpath="/opt/foxitsoftware/foxitreader" export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=@im=fcitx exec "$selfpath/$appname" "$@" 注意，需将 export 语言添加在 exec 语句之前。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AWK 编程拾锦]]></title>
    <url>%2F2018%2F11%2F26%2FExamples-of-AWK%2F</url>
    <content type="text"><![CDATA[以相同的列首字段分割文件需求文件的第一列为分类标志，以相同的每行第一列内容为分隔，将文件分为不同的多个文件。 实现假设有文件 “run” 内容如下： 123456780 one0 two1 three1 four1 five2 six2 seven2 eigth 首先，需要一个变量 fs 来记录每相同首列部分的首列内容，在 BEGIN 阶段需要对此变量初始化，在判断出 fs 与当前行的首列内容 $1 不同时重新给 fs 赋值并创建新文件；同时，还需要一个变量 fn 记录不同部分对应的输出文件名。具体实现为： 123456789101112[user@A ~]$ cat run | awk 'BEGIN &#123;fs=""&#125; &#123;if(fs!=$1) &#123;fs=$1; fn="file" $1; print $1, $2 &gt; fn&#125; else &#123;print $1, $2 &gt;&gt; fn&#125;&#125;'[user@A ~]$ cat file00 one0 two[user@A ~]$ cat file11 three1 four1 five[user@A ~]$ cat file22 six2 seven2 eigth 同模式重复多行块重组需求文件按同一模式多行重复不同对象的内容，现需要将同一对象的信息以同一行内容保存。 实现假设有文件 “run” 内容如下： 12345678910111213141516学号姓名年龄成绩200101张三1874200102李四1739200103王二1956 可见，该文件以每四行分别为“学号”、“姓名”、“年龄”和“成绩”内容的模式呈多行重复，这里要将每四行重新整合为一行，借助内置变量已读记录数 NR 和输出记录分隔符 ORS ，可以如下命令实现： 12345[user@A ~]$ cat run | awk '&#123;if(NR%4!=0) ORS=" "; else ORS="\n"; print $0&#125;' 学号 姓名 年龄 成绩200101 张三 18 74200102 李四 17 39200103 王二 19 56]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地震学中那些可爱的人和事儿]]></title>
    <url>%2F2018%2F11%2F24%2FLove-of-Seismology%2F</url>
    <content type="text"><![CDATA[SLIM 研究组即 The University of British Columbia 的 Seismic Laboratory for Imaging and Modeling，此处为该研究组在 github 上的主页。 这里要介绍的是 JUDI (Julia Devito Inversion) 反演框架，这是一个采用 Julia 语言编写的勘探地震学正反演并行程序包，可以实现基于波动方程的反演应用，包括全波形反演和最小二乘逆时偏移。程序包中波动方程采用有限差分代码自动生成器 Devito 求解。另外，作者就此程序包发布了三篇使用指导，分别对正演模拟、伴随模拟和最优化作了说明。 SEG 开源数据SEG 维基开放数据版面中列出了一些可用的模型、数据、程序和研究机构，包括 SEAM open data, Phase I 2D Data Sets, 2D land seismic data, 2D marine seismic data, 3D land seismic data, 3D marine seismic data, SEG/DMEC Reference Mineral Exploration Data, New Zealand 3D, OpenGeoscience at British Geological Survey, Natural Resources Canada, National Petroleum Reserve Alaska, Norwegian Petroleum Directorate, 2D synthetic seismic data, SMAART models, 3D synthetic seismic data, Gravity and magnetic data, Chevron GOM Full Waveform Inversion Seismic CSEM and MT Synthetic, Topographic and bathymetric data, Dutch Ministry of Economic Affairs Data Release 和 Geophysical Software and Algorithms。 ETOPO1 全球地形模型ETOPO1 是一个 1 弧分的全球地表起伏模型，它整合了陆地地形和洋底测深的数据。对于南极洲和格陵兰岛的冰层，分别提供了层顶 (Ice Surface) 和层底 (Bedrock) 两种起伏数据。 gCAP 解gCAP采用 the generalized cut-and-paste method (L. Zhu and Y. Ben-Zion, 2013) 对宽频带波形滤波获得台湾地区的震源机制解。 SEIZMO 项目SEIZMO 项目收集了超 700 余个 Matlab 函数，提供了一个类似 SAC 的地震数据预处理、质量控制和分析框架，包括标准地震数据格式读写、元数据展示和编辑、地震成图、数据处理（互相关、卷积、反卷积、去势、微分、积分、插值、重采样、滤波、合并、旋转、叠加、谱分析和锥化等）与交互分析。另外，这里是该项目的 GitHub 主页。]]></content>
      <categories>
        <category>Seismology</category>
      </categories>
      <tags>
        <tag>Software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPI 二维切割子程序 MPI_CART_CREATE、MPI_CART_COORDS 和 MPI_CART_SHIFT]]></title>
    <url>%2F2018%2F11%2F03%2FMPI-Cartesian-Function%2F</url>
    <content type="text"><![CDATA[写在前面 注：这里只介绍了 MPI 二维切割在 Fortran 语言中的应用，于 C 语言，类似但略有差别。 专用词语转录说明如下： 原词 转录 程式 程序 副程式 子程序 阵列 数组 叫用 调用 引数 参数 communicator 通信域 CPU id 进程编号 整数阵列 整型数组 逻辑阵列 逻辑型数组 变数 变量 安排 排布 运作 运行 邻居 邻位 垂直坐标图示法则（Cartesian Topology）二维数组 A(NN, MM) 要做二维切割时，需先说明在第一维和第二维各切成几块。例如第一维要切成四块，第二维要切成三块，则切割后第一维的长度 N 为 NN/4，第二维的长度 M 为 MM/3，当然两者都必须能整除才行。如果 NN = 200 和 MM = 150，就可以使用 PARAMETER 来设定 M、N 的值，切割后数组的第一维和第二维都要预留前后各一个数组元素位置时，其参数可设定为：12PARAMETER (NN=200, MM=150, JP=4, IP=3, N=NN/JP, M=MM/IP,)DIMENSION A(0:N+1, 0:M+1) 数组 A 切成 4×3 十二块，第一块由一个 CPU 来执行时，则需要十二个 CPU。这十二个 CPU 的编号和坐标如下图所示：十二个 CPU 之中每一个 CPU 的上、下、左、右邻位关系如上图所示。水平方向 X 轴为第一维 (J) ，垂直方向 Y 轴为第二维 (I) 。 MPI_CART_CREATE二维切割方式必须在调用 MPI_CART_SIZE、MPI_COMM_RANK 分别取得通信域的进程数和进程编号等之后，再调用 MPI 子程序 MPI_CART_CREATE 来加以设定。如上图所示的二维切割方式，其相应的参数设定如下：123456789101112131415PARAMETER (NDIM=2, JP=4, IP=3)INTEGER NPROC, MYIDINTEGER IPART(NDIM), COMM2D, MY_CID, MY_COORD(NDIM)INTEGER SIDEWAYS, UPDOWN, RIGHT, UP, L_NBR, R_NBR, T_NBR, B_NBRLOGICAL PERIODS(NDIM), REORDER...CALL MPI_INIT (IERR)CALL MPI_COMM_SIZE (MPI_COMM_WORLD, NPROC, IERR)IPART(1)=JPIPART(2)=IPPERIODS(1)=.FALSE.PERIODS(2)=.FALSE.REORDER=.TRUE.CALL MPI_CART_CREATE (MPI_COMM_WORLD, NDIM, IPART, PERIODS, REORDER, COMM2D, IERR) 参数 含义 MPI_COMM_WORLD 原来的通信域 NDIM 切割的维数，上图中二维切割的例子需设定为 2 IPART NDIM 个元素的整型数组 IPART(1) 第一维切成的块数，上图中的例子需设定为 4 IPART(2) 第二维切成的块数，上图中的例子需设定为 3 PERIODS NDIM 个元素的逻辑型数组 PERIODS(1) 第一维首尾区块是否相邻，是为 .TRUE. 否为 .FALSE. ，上图中的例子需设定为 .FALSE. PERIODS(2) 第二维首尾区块是否相邻，是为 .TRUE. 否为 .FALSE. ，上图中的例子需设定为 .FALSE. REORDER 逻辑型变量，已排定的 CPU 是否重排，是为 .TRUE. 否为 .FALSE. ，一般设为 .TRUE. COMM2D 切割后得到的新通信域 在调用 MPI_CART_CREATE 之前已经调用过 MPI_COMM_RANK，已经排布好各个 CPU 了，这是一种线性排布。在调用 MPI_CART_CREATE 时，是一种平面排布，当 REORDER 的值设定为 .TRUE. 时，允许系统重新排布各个 CPU，使得相邻的 CPU 排布在相邻的位置上，从而得到最佳的传输效率。 MPI_CART_COORDS此后，程序在新的的通信域 COMM2D 中运行，之前获取的进程编号已经不再适用。必须重新调用 MPI_COMM_RANK 获取当前 CPU 在新的通信域中的进程号。MPI_COMM_RANK 的调用格式如下：1CALL MPI_COMM_RANK (COMM2D, MYID, IERR) 参数 含义 COMM2D 新设定的通信域 MYID 在通信域 COMM2D 中的新的进程号 MYID 的排布方式如上图中的 CPU0、CPU1、CPU2 等所示。接下来就须调用 MPI_CART_COORDS 获取当前 CPU 在二维 CPU 数组中的坐标 MY_COORD。调用格式如下：1CALL MPI_CART_COORDS (COMM2D, MY_CID, NDIM, MY_COORD, IERR) 参数 含义 COMM2D 新设定的通信域 MY_CID 在通信域 COMM2D 中的进程号 NDIM 切割的维数，如上图中的例子需设定为 2 MY_COORD NDIM 个元素的整型数组，进程号为 MY_CID 的 CPU 的 CPU 数组坐标 MY_COORD(1) 第一维方向上的坐标，从 0 起算 MY_COORD(2) 第二维方向上的坐标，从 0 起算 CPU 坐标 MY_COORD 的排布方式如上图中 CPU0、CPU1、CPU2 等进程号下的括号内的数字。由上图易知：当 MY_COORD(1) 为 0 时，该 CPU 位于 CPU 数组的最左边；当 MY_COORD(1) 为 JP - 1 时，该 CPU 位于 CPU 数组的最右边；当 MY_COORD(2) 为 0 时，该 CPU 位于 CPU 数组的最下面（底边）；当 MY_COORD(2) 为 IP - 1 时，该 CPU 位于 CPU 数组的最上面（顶边）。 MPI_CART_SHIFT现在，还须调用 MPI_CART_SHIFT 来获取当前 CPU 的上、下、左、右邻位的进程号。调用格式如下：12345678INTEGER SIDEWAYS, UPDOWN, RIGHT, UPSIDEWAYS=0UPDOWN=1RIGHT=1UP=1CALL MPI_CART_SHIFT (COMM2D, SIDEWAYS, RIGHT, L_NBR, R_NBR, IERR)CALL MPI_CART_SHIFT (COMM2D, UPDOWN, UP, B_NBR, T_NBR, IERR) 参数 含义 COMM2D 新设定的通信域 SIDEWAYS 整型变量，其值为 0 表示获取第一维 (J) 方向的邻位 RIGHT 整型变量，其值为 1 表示获取左、右邻位 L_NBR 整型变量，其值为获取的当前 CPU 的左邻位的进程号 R_NBR 整型变量，其值为获取的当前 CPU 的右邻位的进程号 参数 含义 UPDOWN 整型变量，其值为 1 表示获取第二维 (I) 方向的邻位 UP 整型变量，其值为 1 表示获取下、上邻位 B_NBR 整型变量，其值为获取的当前 CPU 的下邻位的进程号 T_NBR 整型变量，其值为获取的当前 CPU 的上邻位的进程号 这里，L_NBR、R_NBR、B_NBR 和 T_NBR 分别代表 left_neighbor、right_neighbor、bottom_neighbor 和 top_neighbor。 参考 郑守成，2002，《Fortran 語言 MPI 平行计算程式设计》第五章 5.4 节]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>MPI</tag>
        <tag>Parallel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些不可吿人的小东西]]></title>
    <url>%2F2018%2F11%2F03%2FPassword%2F</url>
    <content type="text"><![CDATA[Welcome but enter password to read Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>NOpen</category>
      </categories>
      <tags>
        <tag>Secret</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二阶方阵的逆]]></title>
    <url>%2F2018%2F09%2F29%2FThe-Inverse-Matrix-of-2x2%2F</url>
    <content type="text"><![CDATA[基础知识逆矩阵方阵 $A$ 的逆矩阵： $$A^{-1}=\frac{1}{|A|}A^*$$ 其中，$|A|$ 为 $A$ 的行列式，$A^*$ 为 $A$ 的伴随矩阵。 行列式方阵 $A$ 的行列式： $$|A|=\left|\begin{array}{c} a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \newline a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \newline \vdots &amp; \vdots &amp; \ddots &amp; \vdots \newline a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn} \end{array}\right|=\sum_k(-1)^ka_{1k_1}a_{2k_2}\cdots a_{nk_n}$$ 其中，$k_1, k_2, \cdots, k_n$ 是将序列 $1, 2, \cdots, n$ 的元素次序交换 $k$ 次所得到的一个序列。 伴随矩阵方阵 $A$ 的伴随矩阵为： $$A^*=\left[\begin{array}{c} A_{11} &amp; A_{21} &amp; \cdots &amp; A_{n1} \newline A_{12} &amp; A_{22} &amp; \cdots &amp; A_{n2} \newline \vdots &amp; \vdots &amp; \ddots &amp; \vdots \newline A_{1n} &amp; A_{2n} &amp; \cdots &amp; A_{nn} \end{array}\right]$$ 其中，$A_{ij}$ 为矩阵 $A$ 的元素 $a_{ij}$ 的代数余子式。 代数余子式在 $n$ 阶行列式 $A$ 中任意选定的 $k$ 行 $k$ 列元素，其中在行列交点上的元素按原顺序排列组成的 $k$ 阶行列式，称为行列式 $A$ 的 $k$ 阶子式 $D$ 。 在 $n$ 阶行列式 $A$ 中划去任意选定的 $k$ 行 $k$ 列元素后，余下的元素按原顺序排列组成的 $n-k$ 阶行列式，称为行列式 $A$ 的 $k$ 阶子式 $D$ 的余子式 $M$ 。 如果所选定的行列在行列式 $A$ 中的行列序号分别为 $i_1, i_2, \cdots, i_k$ 和 $j_1, j_2, \cdots, j_k$ ，则行列式 $A$ 的 $k$ 阶子式 $D$ 的代数余子式为 $$(-1)^{(i_1+i_2+\cdots+i_k)+(j_1+j_2+\cdots+j_k)}\cdot M$$ 二阶矩阵的逆对于二阶矩阵 $A=\left[\begin{array}{c} a_{11} &amp; a_{12} \newline a_{21} &amp; a_{22} \end{array}\right]$ ： $|A|=a_{11}\cdot a_{22}-a_{12}\cdot a_{21}$ ， $A_{11} = (-1)^{(1+1)}\cdot a_{22}=a_{22}$ ， $A_{12}=(-1)^{(1+2)}\cdot a_{21}=-a_{21}$ ， $A_{21}=(-1)^{(2+1)}\cdot a_{12}=-a_{12}$ ， $A_{22}=(-1)^{(2+2)}\cdot a_{11}=a_{11}$ ， 则其伴随矩阵为 $$A^*=\left[\begin{array}{c} A_{11} &amp; A_{21} \newline A_{12} &amp; A_{22} \end{array}\right]=\left[\begin{array}{c} a_{22} &amp; -a_{12} \newline -a_{21} &amp; a_{11} \end{array}\right]$$ 其逆矩阵为 $$A^{-1}=\frac{1}{|A|}\cdot A^*=\frac{1}{a_{11}\cdot a_{22}-a_{12}\cdot a_{21}}\cdot\left[\begin{array}{c} a_{22} &amp; -a_{12} \newline -a_{21} &amp; a_{11} \end{array}\right]$$]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Inverse matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cuda C 学习之路]]></title>
    <url>%2F2018%2F09%2F02%2FTips-of-Cuda-C%2F</url>
    <content type="text"><![CDATA[C 相关 C 语言中函数形参默认传值，即函数内部修改形参不会改变实参的值；但可以通过指针形参传递实参地址，修改指针引用值可以改变实参的值。 在变量单双精度切换时，使用 scanf 函数读入数据到变量也需在格式字符串 %f 和 %lf 之间切换，但使用 printf 函数输出变量数据则不需切换。 Cuda 相关 Cuda kernel 函数不允许通过指针形参传递单变量地址，修改指针引用值不会改变外部实参的值。 在 Cuda kernel 函数内进行屏幕输出时，可在 host 端 kernel 函数之后加上 cudaDeviceReset(); 确保屏幕及时输出。 若运行时报错 “Too many resources requested for lanch”，可能是处理器上的 register 数超出了限制，可减少 the number of threads per block 后再次尝试运行。 在 C++ 类的构造函数中，不要 launch kernel，否则会发生不可预测的后果，在程序运行至某处时报错 “an illegal memory access was encountered” ？]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Cuda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些数学概念]]></title>
    <url>%2F2018%2F07%2F22%2FBasic-of-Math%2F</url>
    <content type="text"><![CDATA[Hilbert 变换定义参考 Wikipedia 。 The Hilbert transform of the function $u(t)$ can be thought of as the convolution of $u(t)$ with the function $h(t)=\frac{1}{\pi t}$. Because $h(t)$ is not integrable, the integrals defining the convolution do not converge. Instead, the Hilbert transform is defined using the Cauchy principal value (denoted here by $p$ ): $$\mathcal{H}\lbrace u(t)\rbrace=p\int_{-\infty}^{\infty}u(\tau)h(t-\tau)d\tau=\frac{1}{\pi}p\int_{-\infty}^{\infty}\frac{u(\tau)}{t-\tau}d\tau$$ 性质A property of Hilbert transform is: $\mathcal{H}\lbrace\mathcal{H}\lbrace u(t)\rbrace\rbrace=-u(t)$. 解析信号The analytic signal is constructed from a real signal $f(t)$ and its Hilbert transform $\mathcal{H}\lbrace f(t)\rbrace$ : $$\tilde f(t)=f(t)-i\mathcal H\lbrace f(t)\rbrace$$ The analytic signal can be written in terms of the instantaneous amplitude $E(t)$ and the instantaneous phase $\phi(t)$ as $$\tilde f(t)=E(t)e^{i\phi(t)}$$ where $$\phi(t)=\arctan\frac{\mathfrak I\lbrace\tilde f(t)\rbrace}{\mathfrak R\lbrace\tilde f(t)\rbrace}=\arctan\frac{\mathcal H\lbrace f(t)\rbrace}{f(t)}$$ $$E(t)=\sqrt{\mathfrak R\lbrace\tilde f(t)\rbrace^2+\mathfrak I\lbrace\tilde f(t)\rbrace^2}=\sqrt{f(t)^2+\mathcal H\lbrace f(t)\rbrace^2}$$ 共轭转置定义又称 Hermitian 转置。参考 Wikipedia 。 In mathematics, the conjugate transpose and Hermitian transpose of an $m\times n$ matrix $A$ with complex entries is the $n\times m$ matrix $A^*$ obtained from $A$ by taking the transpose and then taking the complex conjugate of each entry. The definition can also be written as $$A^*=(\bar{A})^T=\overline{A^T}$$ The commonly used symbols for the conjugate transpose: $A^*$ or $A^H$ in linear algebra ; $A^\dagger$ in quantum mechanics ; $A^+$. 例子If $A=\begin{bmatrix} 1 &amp; -2-i \newline 1+i &amp; i \end{bmatrix} $, then $A^*=\begin{bmatrix} 1 &amp; 1-i \newline -2+i &amp; -i \end{bmatrix}$. Kronecker 乘积定义参考 Wikipedia 。 In mathematics, the Kronecker product, denoted by $\otimes$, is an operation on two matrices of arbitrary size resulting in a block matrix. It is a generalization of the outer product from vectors to matrices. If $A$ is an $m\times n$ matrix and $B$ is a $p\times q$ matrix, then the Kronecker product $A\otimes B$ is the $mp\times nq$ block matrix: $$A\otimes B=\left[\begin{array}{c} a_{11}B &amp; a_{12}B &amp; \cdots &amp; a_{1n}B \newline a_{21}B &amp; a_{22}B &amp; \cdots &amp; a_{2n}B \newline \vdots &amp; \vdots &amp; \ddots &amp; \vdots \newline a_{m1}B &amp; a_{m2}B &amp; \cdots &amp; a_{mn}B \end{array}\right]$$ where $$a_{ij}B=\left[ \begin{array}{c} a_{ij}b_{11} &amp; a_{ij}b_{12} &amp; \cdots &amp; a_{ij}b_{1q} \newline a_{ij}b_{21} &amp; a_{ij}b_{22} &amp; \cdots &amp; a_{ij}b_{2q} \newline \vdots &amp; \vdots &amp; \ddots &amp; \vdots \newline a_{ij}b_{p1} &amp; a_{ij}b_{p2} &amp; \cdots &amp; a_{ij}b_{pq} \end{array} \right]$$ 例子$$\left[\begin{array}{c} 1 &amp; 2 \newline 3 &amp; 4 \end{array}\right] \otimes \left[\begin{array}{c} 0 &amp; 5 \newline 6 &amp; 7 \end{array}\right]=\left[\begin{array}{c} 1\cdot \left[\begin{array}{c} 0 &amp; 5 \newline 6 &amp; 7 \end{array}\right] &amp; 2\cdot \left[\begin{array}{c} 0 &amp; 5 \newline 6 &amp; 7 \end{array}\right] \newline 3\cdot \left[\begin{array}{c} 0 &amp; 5 \newline 6 &amp; 7 \end{array}\right] &amp; 4\cdot \left[\begin{array}{c} 0 &amp; 5 \newline 6 &amp; 7 \end{array}\right] \end{array}\right]=\left[\begin{array}{c} 0 &amp; 5 &amp; 0 &amp; 10 \newline 6 &amp; 7 &amp; 12 &amp; 14 \newline 0 &amp; 15 &amp; 0 &amp; 20 \newline 18 &amp; 21 &amp; 24 &amp; 28 \end{array}\right]$$ Frobenius 范数定义也即 Hilbert-Schmidt 范数。参考 Wikipedia 。 The norm can be defined in various ways: $$||A||_F=\sqrt{\sum_{i=1}^m\sum_{j=1}^n|a_{ij}|^2}=\sqrt{trace(A^\dagger A)}=\sqrt{\sum_{i=1}^{\min\lbrace m,n\rbrace}\sigma_i^2(A)}$$ where $A^\dagger$ denotes the conjugate transpose of $A$, and $\sigma_i(A)$ are the singular value of $A$. Frobenius 内积参考 Wikipedia 。 $$||A||_F=\sqrt{\langle A,A\rangle_F}$$ where the Frobenius inner product is defined by: $$\langle A,B\rangle_F=\sum_{i,j}\overline{A_{ij}}B_{ij}=trace(\overline{A^T}B)$$ Hadamard 乘积定义也即 Hadamard matrices 。参考 Wikipedia https://en.wikipedia.org/wiki/Hadamard_product_(matrices) 。 For two matrices, $A, B$, of the same dimension, $m\times n$, the Hadamard product, $A\circ B$, is a matrix of the same dimension as the operands, with elements given by $$(A\circ B)_{i,j}=A_{i,j}B_{i,j}$$ The Hadamard division $A\oslash B$ is defined as: $$(A\oslash B)_{ij}=\frac{A_{ij}}{B_{ij}}$$ 性质 The Hadamard product is commutative, associative and distributive over addition, that is: $A\circ B=B\circ A$ $A\circ(B\circ C)=(A\circ B)\circ C$ $A\circ(B+C)=A\circ B+A\circ C$ For square matrices $A, B$, the row-sums of their Hadamard product are the diagonal elements of $AB^T$ or $B^TA$: $\sum_i(A\circ B)_{i,j}=(B^TA)_{j,j}$ $\sum_j(A\circ B)_{i,j}=(AB^T)_{i,i}$ Hilbert 矩阵定义参考 Wikipedia 。 In linear algebra, a Hilbert matrix is a square matrix with entries being the unit fractions: $$H_{ij}=\frac{1}{i+j-1}$$ For example, this is the $3\times 3$ Hilbert matrix: $$H=\left[\begin{array}{c} 1 &amp; \frac{1}{2} &amp; \frac{1}{3} \newline \frac{1}{2} &amp; \frac{1}{3} &amp; \frac{1}{4} \newline \frac{1}{3} &amp; \frac{1}{4} &amp; \frac{1}{5} \end{array}\right]$$ 应用The notoriously ill-conditioned Hilbert matrix can be defined as: $$J_{ij}:=\begin{cases} \frac{1}{i+j-1} &amp; \text{if }i\text{ mod }j=0\text{, or }j\text{ mod }i=0 \newline 0 &amp; \text{otherwise} \end{cases}$$ For example, if given by $n=5​$, the matrix $J​$ has the condition number of $4.9\times 10^3​$. 矩阵的条件数矩阵 $A$ 的条件数（condition number）可定义为： $$\kappa(A)=||A||\cdot ||A^{-1}||$$ 如果方阵 $A$ 是奇异的，那么 $A$ 的条件数为正无穷大。实际上，每一个可逆方阵都存在一个条件数。 条件数是一个矩阵（或它所描述的线性系统）的稳定性或敏感度的度量。 A problem with a low condition number is said to be well-conditioned, while a problem with a high condition number is said to be ill-conditioned. 积分函数表参考 Wikipedia。 有理函数 指数函数 对数函数 三角函数 反三角函数 双曲函数 反双曲函数 另外，这里还有在线数学笔记。 狄拉克梳状函数即 Dirac comb 或 Shah 函数，参考 Wikipedia 。 在数学上，Dirac comb 即一个由 Dirac delta 函数构成的周期性调和分布（periodic tempered distribution）。也即电子工程中的脉冲序列（impulse train）或采样函数（sampling function）。 A Dirac comb is an infinite series of Dirac delta functions spaced at intervals of $T$. 函数表达式为： $$III_T(t)=\sum_{k=-\infty}^\infty \delta (t-kT)$$ 函数图像如下：]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Hilbert</tag>
        <tag>Kronecker</tag>
        <tag>Frobenius</tag>
        <tag>Hadamard</tag>
        <tag>Condition number</tag>
        <tag>Dirac comb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些算法原理]]></title>
    <url>%2F2018%2F07%2F22%2FPrinciple-of-Algorithm%2F</url>
    <content type="text"><![CDATA[BFGS 算法也即 Broyden-Fletcher-Goldfarb-Shanno 算法。参考 Wikipedia 。 原理The search direction at stage $k$ is given by the Newton method: $$p_k=-B_k\nabla f(x_k)$$ where $B_k$ is an approximation of the Hessian matrix, and $\nabla f(x_k)$ is the gradient of the function at $x_k$ The quasi-Newton condition imposed on the update of $B_k$ is: $$B_{k+1}(x_{k+1}-x_k)=\nabla f(x_{k+1})-\nabla f(x_k)$$ Let $y_k=\nabla f(x_{k+1})-\nabla f(x_k)$ and $s_k=x_{k+1}-x_k$, then $B_{k+1}s_k=y_k$ which is the secant equation. The curvature condition $s_k^Ty_k&gt;0$ should be satisfied. In the BFGS method, instead of requiring the full Hessian matrix at $x_{k+1}$ to be computed, the approximate Hessian is given by: $$B_{k+1}=B_k+\frac{y_ky_k^T}{y_k^Ts_k}-\frac{B_ks_ks_k^TB_k}{s_k^TB_ks_k}$$ $$B_{k+1}^{-1}=\left(I-\frac{s_ky_k^T}{y_k^Ts_k}\right)B_k^{-1}\left(I-\frac{y_ks_k^T}{y_k^Ts_k}\right)+\frac{s_ks_k^T}{y_k^Ts_k}$$ or $$B_{k+1}^{-1}=B_k^{-1}+\frac{(s_k^Ty_k+y_k^TB_k^{-1}y_k)(s_ks_k^T)}{(s_k^Ty_k)^2}-\frac{B_k^{-1}y_ks_k^T+s_ky_k^TB_k^{-1}}{s_k^Ty_k}$$ 算法From an initial guess $x_0$ and an approximate Hessian matrix $B_0$ (generally the identity matrix), the following steps are repeated as $x_k$ converges to the solution: Obtain a direction: $p_k=-B_k^{-1}\nabla f(x_k)$; Perform a line search to find an acceptable stepsize $\alpha_k$ in the direction found in the first step; Set $s_k=\alpha_kp_k$ and update $x_{k+1}=x_k+s_k$; $y_k=\nabla f(x_{k+1})-\nabla f(x_k)$; $B_{k+1}=B_k+\frac{y_ky_k^T}{y_k^Ts_k}-\frac{B_ks_ks_k^TB_k}{s_k^TB_ks_k}$. Fixed point 迭代法Fixed point参考 Wikipedia https://en.wikipedia.org/wiki/Fixed_point_(mathematics) 。 Not to be confused with a stationary point where $f’(x)=0$ . In mathematics, $c$ is a fixed point of the function $f(x)$ if $f(c) = c$. Points that come back to the same value after a finite number of iterations of the function are called periodic points. A fixed point is a periodic point with period equal to one. Fixed point 迭代定义参考 Wikipedia 。 In numerical analysis, given a function $f$ defined on the real number with real values and given a point $x_0$ in the domain of $f$, the fixed point iteration is $$x_{n+1}=f(x_n), n=0,1,2,…$$ 应用Newton’s method for finding roots of a given differentiable function $f(x)$ is $$x_{n+1}=x_n-\frac{f(x_n)}{f’(x_n)}$$ If we write $g(x)=x-\frac{f(x)}{f’(x)}$, we may rewrite the Newton iteration as $$x_{n+1}=g(x_n)$$ If this iteration converges to a fixed point $x$ of $g$, then $$x=g(x)=x-\frac{f(x)}{f’(x)}$$ so that $$\frac{f(x)}{f’(x)}=0$$ The reciprocal of anything is nonzero, therefore $f(x)=0$: $x$ is a root of $f$. 非线性共轭梯度法参考 Wikipedia 。 In numerical optimization, the nonlinear conjugate gradient method generalizes the conjugate gradient method to nonlinear optimization. 线性共轭梯度法For a quadratic function $$f(x)=||Ax-b||^2$$ the minimum of $f$ is obtained when the gradient $\nabla_x f=2A^T(Ax-b)=0$. Linear conjugate gradient seeks a solution to the linear equation $A^T Ax=A^T b$. 非线性共轭梯度法The nonlinear conjugate gradient method is generally used to find the local minimum of a nonlinear function using its gradient $\nabla_x f$ alone. 算法步骤Given a function $f(x)$, one simply starts in the steepest descent direction: $$\Delta x_0=-\nabla_x f(x_0)$$ with an step length $\alpha$, and preforms a line search: $$\alpha_0:=argmin_\alpha f(x_0+\alpha\Delta x_0)$$ $$x_1=x_0+\alpha_0\Delta x_0$$ After the first iteration in $\Delta x_0$, the following steps continue along a subsequent conjugate direction $s_n$, where $s_0=\Delta x_0$: Calculate the steepest direction: $\Delta x_n=-\nabla_x f(x_n)$; Compute $\beta_n$ according to one of the formulas below; Update the conjugate direction: $s_n=\Delta x_n+\beta_n s_{n-1}$; Perform a line search: optimize $\alpha_n=argmin_\alpha f(x_n+\alpha s_n)$; Update: $x_{n+1}=x_n+\alpha_n s_n$. Subsequent search directions lose conjugacy requiring the searchdirection to be reset to the steepest descent direction at least every $N$ iterations, or sooner if progress stops. $\beta_n$ 的计算Four of the best known formulas for $\beta_n​$ are named after their developers: Fletcher-Reeves: $\beta_n^{FR}=\frac{\Delta x_n^T \Delta x_n}{\Delta x_{n-1}^T \Delta x_{n-1}}$; Polak-Ribiere: $\beta_n^{PR}=\frac{\Delta x_n^T (\Delta x_n-\Delta x_{n-1})}{\Delta x_{n-1}^T \Delta x_{n-1}}$; Hestenes-Stiefel: $\beta_n^{HS}=-\frac{\Delta x_n^T (\Delta x_n-\Delta x_{n-1})}{s_{n-1}^T (\Delta x_n-\Delta x_{n-1})}$; Dai-Yuan: $\beta_n^{DY}=-\frac{\Delta x_n^T \Delta x_n}{s_{n-1}^T (\Delta x_n-\Delta x_{n-1})}$. A popular choice is $\beta=\max\lbrace 0,\beta^{PR}\rbrace$, which provides a direction reset automatically.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>BFGS</tag>
        <tag>Fixed point</tag>
        <tag>Conjugate gradient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器管理]]></title>
    <url>%2F2018%2F07%2F21%2FTips-of-Server%2F</url>
    <content type="text"><![CDATA[dd 命令刻录系统启动盘若系统已自动挂载 U 盘，可以命令 [root@A ~]$ fdisk -l 查看 U 盘挂载设备号，如 /dev/sdb，但由于 Linux 中每个设备文件可能对应多个设备号，如主/次设备号，实际自动挂载的可能只是其中的一个设备号，如 /dev/sdb1，再以命令 [root@A ~]$ umount /dev/sdb1 卸载 U 盘；若系统未自动挂载 U 盘，同样可由 fdisk 命令查看 U 盘对应的设备号，如 /dev/sdb； 以命令 [root@A ~]$ mkfs.vfat /dev/sdb -I 格式化 U 盘； 最后以命令 [root@A ~]$ dd if=~/CentOS-7-x86_64-Minimal-xxxx.iso of=/dev/sdb 即可将 ~/CentOS-7-x86_64-Minimal-xxxx.iso 系统文件内容刻录入设备 /dev/sdb 对应的 U 盘。 SSH 免密登录以下实现主机 A 到主机 B 的免密登录： 在主机 A 下生成公钥/私钥对：执行 [user@A ~]$ ssh-keygen -t rsa 后，连按三次回车键即可。 把主机 A 下生成的公钥复制远程传输到主机 B 上，并添加到其 \$HOME/.ssh/authorized_keys 文件中：执行 [user@A ~]$ ssh-copy-id -i .ssh/id_rsa.pub user@B:~/ 即可。 注：设置主机 B 上的 $HOME/.ssh/authorized_keys 文件权限为 600 。 设置系统免密登录以命令 [root@A ~]$ systemctl stop firewalld.service 关闭防火墙；以命令 [root@A ~]$ systemctl disable firewalld.service 禁用防火墙。 以命令 [root@A ~]$ setenforce 0 关闭 SELinux；修改 /etc/selinux/config 文件：SELINUX=disabled， 以禁用 SELinux 。 CentOS minimal 首次安装后连接网络CentOS minimal 首次初始安装后是无法自动成功联网的，需手动配置网卡。即进入目录 /etc/sysconfig/network-scripts，对于多网口的机器，在该目录下会存在多个以 ifcfg- 开头的配置文件，在修改除 ifcfg-lo 以外的其他配置文件中的 ONBOOT 选项为 yes 后重启机器即可。 安装 EPEL 源EPEL，即 Extra Packages for Enterprise Linux，是为企业级 Linux 提供的一组高质量的额外软件包。 命令 [root@A ~]$ yum install epel-release 安装 rpm 包，命令 [root@A ~]$ yum clean all &amp;&amp; yum makecache 更新软件源。 安装 ELRepo 源ELRepo 包含了一些硬件相关的驱动程序，比如显卡、声卡驱动。可以如下命令进行安装： 12[root@A ~]$ rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org[root@A ~]$ rpm -Uvh http://www.elrepo.org/elrepo-release-x.x-x.el7.elrepo.noarch.rpm 注意将第二条命令中的版本号修改为自己机器相应的数字。 系统软件安装必要安装 gcc-gfortran: [root@A ~]$ yum install gcc-gfortran gcc-c++: [root@A ~]$ yum install gcc-c++.x86_64 autojump: 命令 [root@A ~]$ yum install autojump 安装，命令 [root@A ~]$ yum install autojump-zsh.noarch 添加对 zsh 的支持。 HDF5 库：[root@A ~]$ yum install hdf5-devel htop: [root@A ~]$ yum install htop vim: [root@A ~]$ yum install vim tmux: [root@A ~]$ yum install tmux sysstat: [root@A ~]$ yum install sysstat.x86_64 locate: [root@A ~]$ yum install mlocate zsh: [root@A ~]$ yum install zsh 可选安装 Xpm 库：[root@A ~]$ yum install libXpm-devel.x86_64 ifconfig: [root@A ~]$ yum install net-tools.x86_64 GNU Parallel: [root@A ~]$ yum install parallel.noarch eog: [root@A ~]$ yum install eog.x86_64 Xt 库：[root@A ~]$ yum install libXt-devel.x86_64 xauth: [root@A ~]$ yum install xauth （当 ssh -X 远程登录报错 X11 forwarding request failed on channel 0 时） xwindow 图形界面：[root@A ~]$ yum -y groupinstall &quot;X Window System&quot; GNU m4 宏处理器：[root@A ~]$ yum install m4.x86_64 ghostscript: [root@A ~]$ yum install ghostscript.x86_64 mail: [root@A ~]$ yum install mailx GPU 节点安装 nl 库：[root@A ~]$ yum install libnl-devel.x86_64 修改主机名hostnamectl set-hostname seislab 命令修改主机名为 seislab 。 修改系统时区先用 timedatectl set-timezone Asia/Shanghai 命令更新时区为亚洲上海时区，再用 timedatectl set-local-rtc 1 命令将硬件时钟与系统时钟调整一致。 添加用户到 sudoer 列表以下实现将 user 用户添加到 sudoer 列表： 进入 root 账户，在命令行键入：[root@A ~]$ visudo，打开 sudoer 的配置文件。 向下查找到 root ALL=(ALL) ALL 内容行，在下一行参照新建行内容user ALL=(ALL) ALL，保存后退出。 挂载本地磁盘查看本地已挂载磁盘文件系统格式以命令 [root@A ~]$ cat /etc/fstab 查看本地已挂载磁盘文件系统格式，如 ntfs 或 ext4 等。 格式化本地磁盘命令 [root@A ~]$ mkfs -t ext4 /dev/sdb 以 ext4 文件格式格式化本地磁盘 /dev/sdb。 挂载本地磁盘命令 [root@A ~]$ mount /dev/sdb /shdisk/lab 将本地磁盘 /dev/sdb 挂载至 /shdisk/sdb 目录下。 挂载 ntfs 硬盘并指定访问权限CentOS 系统默认不支持 ntfs 文件系统，需先行以命令 [root@A ~]$ yum install ntfs-3g 安装额外驱动 ntfs-3g。 若需指定挂载目录为 GID 为 1005 的用户组和 UID 为 1010 的用户所有，且访问权限为 750，则可以如下命令将硬盘 /dev/sdb 挂载在目录 /data 下： 1[root@A ~]$ mount -t ntfs -o rw,auto,umask=027,uid=1010,gid=1005 /dev/sdb /data 其中，访问权限设置选项 umask 采用八进制记法，对应关系如下： Octal Binary Permission 0 000 rwx 1 001 rw- 2 010 r-x 3 011 r– 4 100 -wx 5 101 -w- 6 110 –x 7 111 — 挂载远程目录以主机 B（ip 为 192.18.1.2）挂载远程主机 A（ip 为 192.18.1.1）的共享目录 /data/share 为例： 服务端 [root@A ~]$ yum install nfs-utils rpcbind 安装 nfs-utils 和 rpcbind 服务； [root@A ~]$ chkconfig nfs on 设置 nfs 服务开机自启，[root@A ~]$ chkconfig rpcbind on 设置 rpcbind 服务开机自启； [root@A ~]$ service rpcbind start 启动 rpcbind 服务，[root@A ~]$ service nfs start 启动 nfs 服务，注意这两条命令的执行顺序； 在文件 /etc/exports 中添加内容 /data/share 192.18.1.2(rw, no_root_squash, no_subtree_check) ； [root@A ~]$ exportfs -a 使配置文件生效； [root@A ~]$ showmount -e 查看是否共享成功。 客户端 [root@B ~]$ yum install nfs-utils rpcbind 安装 nfs-utils 和 rpcbind 服务； [root@A ~]$ chkconfig nfs on 设置 nfs 服务开机自启，[root@A ~]$ chkconfig rpcbind on 设置 rpcbind 服务开机自启； [root@A ~]$ service rpcbind start 启动 rpcbind 服务，[root@A ~]$ service nfs start 启动 nfs 服务，注意这两条命令的执行顺序； [root@B ~]$ showmount -e 192.18.1.1 查看是否检测到服务端的共享 [root@B ~]$ mkdir /data/share 创建映射目录； 在文件 /etc/fstab 中添加内容 192.18.1.1:/data/share /data/share nfs rw,defaults 0 0 ； 当前启动下，执行手动挂载 [root@B ~]$ mount -t nfs 192.18.1.1:/data/share /data/share 。 常见问题 若出现由于服务端偶然宕机而导致客户端执行 df 或 ls 等与远程挂载目录相关的操作时终端卡死的情况，可以在服务端依次执行如下命令手动重启 rpcbind 和 nfs 服务解决： 1234[root@A ~]$ service rpcbind stop[root@A ~]$ service nfs stop[root@A ~]$ service rpcbind start[root@A ~]$ service nfs start 有时候使用命令 [root@A ~]$ service rpcbind restart &amp;&amp; service nfs restart 重启服务也可解决该问题。 若在上一问题中，服务端暂时无法登陆，则在客户端以命令 [root@A ~]$ umount -fl /data/share 强制卸载该远程目录即可（ -f 即强制卸载；-l 为延迟卸载。仅 -f 可能提示目录繁忙，-l 即等待目录不繁忙时再卸载）。 若在服务端启动 nfs 服务时出现问题，有可能是该服务节点的本地磁盘未挂载，可手动挂载后再重新启动 nfs 服务。 若远程挂载过程中出现 mount.nfs: access denied by server while mounting (null) 告警，可能是先前自动挂载失败导致的，需先 umount 掉该挂载目录后再重新尝试远程挂载。 安装 Pbs Pro 作业调度系统准备机器假设如下两台机器（CentOS 7 系统）： 主机名 主机 IP pbsmaster 192.18.1.1 pbsslave 192.18.1.2 修改两台机器的 /etc/hosts 文件，确保两台机器可以 ssh 互相访问。 安装包此处下载安装包 pbspro-14.1.0.tar.gz 。 制作 RPM 包先提前安装依赖包： 123$ yum -y install rpm-build$ yum -y install gcc autoconf automake libtool hwloc-devel$ yum -y install libX11-devel libXt-devel libedit-devel libical-devel ncurses-devel postgresql-devel python-devel python-devel tcl-devel tk-devel swig expat-devel openssl-devel libXext libXft 执行以下命令，在 /root/rpmbuild/RPMS/x86_64 目录下生成 pbspro-[ client | debuginfo | execution | server ]-14.1.0-0.x86_64.rpm 包： 1234$ mkdir -p /root/rpmbuild/SOURCES/$ mv pbspro-14.1.0.tar.gz /root/rpmbuild/SOURCES/$ cd /root/rpmbuild/SOURCES &amp;&amp; tar zxvf pbspro-14.1.0.tar.gz$ cd /root/rpmbuild/SOURCES/pbspro-14.1.0 &amp;&amp; rpmbuild -ba pbspro.spec 安装安装 Master登录至 Master 节点，命令 [root@pbsmaster /root/rpmbuild/RPMS/x86_64]$ yum install -y pbspro-server-14.1.0-0.x86_64.rpm （或者 [root@pbsmaster /root/rpmbuild/RPMS/x86_64]$ rpm -ivh pbspro-server-14.1.0-0.x86_64.rpm ）安装作业调度系统，修改 /etc/pbs.conf 文件： 12PBS_SERVER=pbsmasterPBS_START_MOM=1 安装 Slave登录至 Slave 节点，命令 [root@pbsslave /root/rpmbuild/RPMS/x86_64]$ yum install -y pbspro-execution-14.1.0-0.x86_64.rpm （或者 [root@pbsslave /root/rpmbuild/RPMS/x86_64]$ rpm -ivh pbspro-execution-14.1.0-0.x86_64.rpm ）安装作业调度系统，修改 /etc/pbs.conf 文件： 12PBS_SERVER=pbsmasterPBS_START_MOM=1 修改 /var/spool/pbs/mom_priv/config 文件： 12$clienthost pbsmaster$restrict_user_maxsysid 999 启动 pbs以命令 $ /etc/init.d/pbs start 分别在 pbsmaster 和 pbsslave 节点上启动 pbs，以命令 [root@pbsmaster ~]$ qmgr -c &#39;create node pbsslave&#39; 在 pbsmaster 主节点上将 pbsslave 节点加入集群。 PBS Pro 队列管理PBS 队列主要分为两种：路由队列（route）和执行队列（execution）。前者只用于向其他队列移动作业（move jobs）；后者用于运行作业。 以下示例中，以 pbsmaster 为 PBS 主节点。 创建队列以如下命令创建一个执行队列 exec_queue： 1234[root@pbsmaster ~]$ qmgr -c 'create queue exec_queue'[root@pbsmaster ~]$ qmgr -c 'set queue exec_queue queue_type = execution'[root@pbsmaster ~]$ qmgr -c 'set queue exec_queue enabled = True'[root@pbsmaster ~]$ qmgr -c 'set queue exec_queue started = True' 如果要创建一个路由队列，设置 queue_type = route 即可。另外，设置 enable = True 表示允许该队列接收作业，设置 started = True 表示允许该队列里的作业执行。 可以命令 [root@pbsmaster ~]$ qmgr -c &#39;delete queue exec_queue&#39; 删除已创建的队列 exec_queue。 创建节点以命令 [root@pbsmaster ~]$ qmgr -c &#39;create node vnode1&#39; 创建一个节点 vnode1。 以命令 [root@pbsmaster ~]$ qmgr -c &#39;delete node vnode1&#39; 删除已创建的节点 vnode1。 以命令 [root@pbsmaster ~]$ qmgr -c &#39;set node vnode1 queue = exec_queue&#39; 将已创建的节点 vnode1 添加到已创建的队列 exec_queue 中。 记录配置以如下命令将当前 PBS 配置导出到 /tmp/ 目录下： 12[root@pbsmaster ~]$ qmgr -c 'print server' &gt; /tmp/server.out[root@pbsmaster ~]$ qmgr -c 'print node @default' &gt; /tmp/nodes.out 可以如下命令从 /tmp/ 目录下读取并重新配置 PBS 队列： 12[root@pbsmaster ~]$ qmgr &lt; /tmp/server.out[root@pbsmaster ~]$ qmgr &lt; /tmp/nodes.out 安装并配置 InfiniBand事前准备首先，在官网下载系统对应版本的驱动安装包（ tgz 压缩包即可）。注意操作系统子版本号和机器架构的选择。在下载页面底部，勾选接受 EULA 协议之后方可开始下载。 再以命令 [root@A ~]$ lspci | grep Mellanox 验证主机是否已安装 Mellanox 网络适配器 HCA/NIC，若屏幕输出 102:00.0 Infiniband controller: Mellanox Technologies MT27800 Family [ConnectX-5] 类似内容即表示该网络适配器已正确安装。若此处验证失败，则后序启动子网管理器 opensmd 也将失败，且通过命令 ip address 亦不能看到名称为 ib0 的 InfiniBand 网络连接。InfiniBand 网卡未正确安装可能导致此处验证失败。 驱动安装解压 tgz 安装包后，在解压目录下，以命令 [root@A ~]$ ./mlnxofedinstall 开始安装驱动。 在安装过程中，程序首先会检查操作系统版本的一致性，若这里检查失败，可参考「常见问题」给出的解决方案。其次，程序还会检查软件依赖（包括 perl、gtk2、atk、cairo、gcc-gfortran、libxml2-python、tcsh、lsof、tcl 和 tk），并会自动给出所缺依赖的安装命令，根据提示安装依赖后再重新安装驱动即可。 待驱动安装完成后，以如下命令启动 openibd 并设为开机自启： 12[root@A ~]$ service openibd start[root@A ~]$ chkconfig openibd on 再以如下命令启动子网管理器 opensmd 并设为开机自启： 12[root@A ~]$ service opensmd start[root@A ~]$ chkconfig opensmd on 最后，以命令 [root@A ~]$ ibstat 检查 HCA 端口状态，若 State 栏为 Active 则表示驱动安装正常。主机与 InfiniBand 交换机连接不正常可能导致 State 栏为 Down。 网络 IPoIB 配置在 ibstat 驱动安装检查正常后方可进行网络配置。 首先以如下内容创建文件 /etc/sysconfig/network-scripts/ifcfg-ib0 ： 12345678910111213141516ONNECTED_MODE=noTYPE=InfiniBandPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=noneIPADDR=192.18.2.1NETMASK=255.255.255.0PREFIX=24DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV4_DNS_PRIORITY=100IPV6INIT=noNAME=ib0DEVICE=ib0HWADDR=20:00:07:D2:FE:80:00:00:00:00:00:00:98:03:9B:03:00:16:4C:46ONBOOT=yes 这里，为主机手动配置静态 InfiniBand IP。其中，IPADDR 项可自由指定，HWADDR 应设为主机的 InfiniBand Mac 地址。若意欲实现多个主机间的互连，需在不同主机上将 IPADDR 的前三个字段设置为相同值，且第四个字段不能为 0。以命令 [user@A ~]$ ip address 可查看主机的网络连接情况，在名称为 ib0 的连接中，link/infiniband 字段后面的以冒号连接的内容即主机的 InfiniBand Mac 地址。为不同主机配置网络时，只需修改这两项的内容即可。 配置完成后再以如下命令重启网络接口 ib0： 12[root@A ~]$ ifdown ib0[root@A ~]$ ifup ib0 至此，已完成所有安装配置工作，即可在 InfiniBand 内网中通过 InfiniBand IP 访问不同主机。 常见问题 在驱动安装过程中若操作系统一致性检查失败，并报错系统 kernel 版本不匹配，可在安装包解压目录以命令 [root@A ~/software/MLNX_OFED_LINUX-x.x-x.x.x.x-rhel7.3-x86_64]$ ./mlnx_add_kernel_support.sh -m ./ --make-tgz 重新生成主机系统 kernel 对应的安装包。新安装包自动生成在目录 /tmp/ 下。 若在启动 openibd 服务时，出现如下告警： 12345678Please close all isert sessions and unload 'ib_isert' module.Please make sure module 'rpcrdma' is not in use and unload it.Please make sure module 'ib_srpt' is not in use and unload it.Error: Cannot unload the Infiniband driver stack due to the above issue(s)!To unload the blocking modules, you can run:# modprobe -rv ib_isert rpcrdma ib_srpt 以如上所示命令 [root@A ~]$ modprobe -rv ib_isert rpcrdma ib_srpt 卸载 ib_isert、rpcrdma 和 ib_srpt 模块后再重新启动即可。 以命令 [root@A ~]$ /usr/sbin/ofed_uninstall.sh 即可卸载已完成安装的驱动。 安装 NVIDIA 显卡驱动及 cuda 库前期准备在 NVIDIA 官网分别下载 NVIDIA 显卡驱动和 cuda 库 安装程序 run 文件。对于 CentOS 7 系统，显卡驱动下载 Linux 64-bit 对应版本即可，若下载 Linux 64-bit RHEL 7 对应版本可能会安装失败。 可先行以命令 [root@A ~]$ yum install --enablerepo=epel dkms 安装 DKMS (Dynamic Kernel Module Support) 模块，它可在 kernel 更新后自动为我们重装驱动。 执行安装 在 /usr/lib/modprobe.d/dist-blacklist.conf 中以 # 注释掉原有内容行 blacklist nvidiafb ，添加新建内容行 blacklist nouveau，以禁用 Linux 自带显卡驱动 nouveau 。 以命令 [root@A ~]$ mv /boot/initramfs-$(uname -r).img /root/initramfs-$(uname -r).img.bak 备份原 initramfs 文件，再以命令 [root@A ~]$ dracut -v /boot/initramfs-$(uname -r).img $(uname -r) 更新 initramfs 文件。 关机重启后，以命令 [root@A ~]$ lsmod | grep nouveau 查看是否成功将 nouveau 禁用。 以命令 [root@A ~]$ yum install kernel-devel 安装与系统版本对应的 kernel source。若不能找到对应的安装版本，可在添加第三方软件源，执行 [root@A ~]$ yum update 进行更新后，从头开始重试。 在给下载的显卡驱动安装文件添加可执行权限后，即可以管理员权限运行安装。若报错 kernel source tree，可以在添加 --kernel-source-path=/usr/src/kernels/$(uname -r)/ 选项后运行。若报错 nvidia.ko，可以在添加 -k $(uname -r) 选项后运行。 在给下载的 cuda 库安装文件添加可执行权限后，即可以管理员权限运行安装。 安装字体查看系统字体以命令 [user@A ~]$ fc-list 查看所有已安装的系统字体；以命令 [user@A ~]$ fc-list :lang=zh 查看系统中的中文字体，注意冒号前面的空格。 安装额外的字体 以管理员身份将字体文件拷贝到 /usr/share/fonts/ 目录下； [root@A ~]$ cd /usr/share/fonts ； [root@A ~]$ mkfontscale （若找不到该命令，可以命令 [root@A ~] yum install mkfontscale 安装）； [root@A ~]$ mkfontdir 。 修改系统登录提示（欢迎）信息Linux 系统 SSH 的欢迎信息可以通过修改 /etc/motd 的内容来进行自定义。 但是 /etc/motd 只支持纯文本的欢迎信息。想要实现彩色效果，可以通过修改 /etc/profile.d/motd.sh 来实现，如： 12345678910111213141516171819202122#!/bin/bashecho "==================================================="# ATTENTION:echo -en "\033[01;31m"echo -e "ATTENTION:"# 1. submitting your job at: seislab1, seislab2echo -en "\033[00m"echo -en " 1. submitting your job at: "echo -en "\033[01;32m"echo -e "seislab1, seislab2"# 2. GPU test at: seislab0echo -en "\033[00m"echo -en " 2. GPU test at: "echo -en "\033[01;32m"echo -e "seislab0"#echo -e "\033[00m" ~/.bashrc、/etc/bashrc 和 /etc/profile ~/.bashrc 为用户终端环境设置，仅影响当前用户；/etc/bashrc 和 /etc/profile 为系统终端环境设置，影响所有用户。 系统登录时，/etc/profile 最先被加载，而后它调用了 /etc/bashrc 以及 ~/.bashrc。 /etc/profile 对所有 shell 生效，/etc/bashrc 和 ~/.bashrc 仅对 bash 生效。 创建、修改、删除及限制用户本节涉及到的命令的调用格式均为： 1[root@A ~]$ command [option] username 创建用户创建新用户时使用 useradd 或 adduser 命令，其常用选项有： -c “comment”：指定一段注释性描述； -d directory：指定用户 HOME 目录，若该目录不存在，可同时使用 -m 选项以创建之； -g group：指定用户所属用户组； -G group：为用户添加附加组，group 设置为 &quot;&quot; 即删除该用户所有附加组； -s shell：指定用户的默认登录 SHELL； -e YYYY-MM-DD：指定用户账号失效的绝对时间； -u userid：指定用户的用户 ID，可同时使用 -o 选项以重复使用其他用户的 ID 号。 修改用户修改用户账号时使用 usermod 或 groupmod 命令，常用选项与 useradd 命令一致。以下例中使用该命令修改旧用户名 test 为新用户名 love： 修改用户信息及 HOME 目录：[root@A ~]$ usermod -l love -d /home/love -m test 修改用户组信息：[root@A ~]$ groupmod -n love test 删除用户以命令 [root@A ~]$ userdel -rf test 删除用户 test 。 限制用户可以命令 passwd 限制用户账号的使用，其常用选项有： -l：锁定登录密码，即禁止账号使用； -u：解锁登录密码，即解禁账号使用； -d：删除登录密码，即无登录密码，在某些系统中可以直接登录； -f：强制下次登录时修改密码。 发送广播消息mesg 命令 语法：[root@A ~]$ mesg [ny] 功能：设置终端机的写入权限 参数：n/y 允许/不允许系统用户将信息直接显示在屏幕上 write 命令 语法：[user@A ~]$ write 用户名 [终端串口] 功能：向系统某一用户发送消息 wall 命令 语法：[root@A ~]$ wall &lt; 文件名 功能：向系统所有已登录用户发送文件内容 关机/重启shutdown 命令 语法：[root@A ~]$ shutdown [-t sec] [-hkr] time &quot;WARNING INFO.&quot; 参数： h: 停止所有系统服务后立即关机； k: 只发送警告信息，实际不执行关机操作； r: 停止所有系统服务后重新启动。 实例： shutdown -h now: 立即关机； shutdown -h 20:30: 在下一个 20:30 时刻关机； shutdown +5 &quot;System will shutdown after 5 minutes: 向所有登入用户发送警告，在 5 分钟后关机。 另外，可以命令 [root@A ~]$ shutdown -a 取消已经提交的定时关机命令。 reboot 命令 语法：[root@A ~]$ reboot [-w] 参数：w 仅做测试，执行一个重开机模拟，并不真正将系统重启。 pip 指定安装目录临时方法安装模块 modulename 到目录 /path/to/directory 可以使用命令：[user@A ~]$ pip install --target=/path/to/directory modulename 此方法会直接在目标目录创建 module 文件夹，因此调用前只需将该目录加入 PYTHONPATH 系统环境变量即可。 永久方法若经常需要安装一些额外的 python 函数包到目录 /path/to/directory，则可以修改用户 HOME 目录下 .pip/pip.conf（若不存在则创建），加入以下内容： 12[install]install-option=--prefix=/path/to/directory 此方法会根据安装 module 版本的不同，在目标目录下进一步创建其他子文件夹，最终在子文件夹下创建 module 文件夹，因此调用前需将子文件夹目录加入到 PYTHONPATH 系统环境变量中。 强制踢出已登录用户以下实现踢出已登录用户 user： 先使用 w 命令查看用户 user 登录的 TTY 端口号，此处假设端口号为 pts/4； 再使用命令 [root@A ~]$ pkill -kill -t pts/4 踢出。 最后使用命令 [root@A ~]$ pkill -u user 杀死该用户的所有进程。 查看系统信息 查看系统版本号：[user@A ~]$ cat /etc/centos-release 查看系统内核版本号：[user@A ~]$ uname -r 查看操作系统位数：[user@A ~]$ getconf LONG_BIT 查看系统日志：[root@A ~]$ vim /var/log/messages 查看系统字体：[user@A ~]$ fc-list；查看系统中文字体：[user@A ~]$ fc-list :lang=zh 查看系统网卡的 UUID：[user@A ~]$ nmcli con show 查看系统网络 Mac 地址：[user@A ~]$ nmcli device show xz 压缩或解压使用 xz -z dir 命令压缩目录 dir，使用 xz -d file 命令解压文件 file。在解压以 .tar.xz 结尾的文件时，可以调用 tar -l xz -cxvf 命令。 rpm 查看系统安装包安装目录先用 rpm -qa | grep libname 命令查询 libname 安装包得到该包完整名字 libname-version.arch ，再用 rpm -ql libname-version.arch 命令查看该包安装位置。 查看 CPU 温度以命令 [root@A ~]$ yum install lm_sensors.x86_64 安装 lm_sensors，以 [root@A ~]$ sh -c &quot;yes|sensors-detect&quot; 检测传感器后，即可以命令 [user@A ~]$ sensors 查看 CPU 温度了。 查看已安装的软件包 以 rpm 包安装的：[root@A ~]$ rpm -qa | grep packagename 以 deb 包安装的：[root@A ~]$ dpkg -l | grep packagename 以 yum 命令安装的：[root@A ~]$ yum list installed | grep packagename 一次性定时任务 at检查运行状态以命令 [user@A ~]$ service atd status 查看 at 的守护进程 atd 是否正在运行。 黑白名单黑名单文件为 /etc/at.deny，白名单文件为 /etc/at.allow，并遵循如下规则： 当系统中存在白名单文件时，黑名单文件将被忽略，只有写入白名单的用户才可以运行 at 命令； 当系统中只有黑名单文件中，被写入名单的用户不能运行 at 命令，且黑名单对 root 无效； 如果两个文件都不存在时，只有 root 用户可以运行 at 命令。 at 命令以命令 [user@A ~]$ at &lt;time&gt; 启动 at 命令行，并输入要执行的任务命令集合，按 [ctrl + d] 结束输入，at 命令会提示该任务的系统编号为 ##；这里，&lt;time&gt; 格式可以为： HH:MM，如 02:30 HH:MM YYYY-MM-DD，如 08:00 2018-10-10 HH:MM [am | pm] [month] [date]，如 08:00 Oct 1 HH:MM [am | pm] + number [minutes | hours | days | weeks]，如 08:00 + 1 days now + number [minutes | hours | days | weeks]，如 now + 5 minutes 以命令 [user@A ~]$ at -l 查看所有等待执行的 at 任务； 以命令 [user@A ~]$ at -c ## 查看 ## 号 at 任务的任务详情； 以命令 [user@A ~]$ at -d ## 删除正在等待执行的 ## 号 at 任务。 功能强大的 LD_PRELOAD 变量LD_PRELOAD 是 Linux 系统的一个环境变量，它可以定义一个程序运行前优先加载的动态链接库，主要是用来有选择性地载入不同动态链接库中的相同函数。 一般情况下，动态链接库的加载顺序为：LD_PRELOAD &gt; LD_LIBRARY_PATH &gt; /etc/ld.so.cache &gt; /lib &gt; /usr/lib。 为了实现某些功能，可以重定义第三方库中的一些函数，编译为动态链接库，并将 LD_PRELOAD 设置为此自定义动态链接库。此时，程序在运行时，会优先调用自定义库文件中覆写的第三方库同名函数。此处可见详细示例。 另外，在安装某些软件（如 anaconda）时，如需指定其他路径的第三方库而不使用自身提供的同名库（如 hdf5），可将 LD_PRELOAD 设置为需指定路径的库文件，即可强制安装程序调用指定路径的库文件。 创建新用户时的默认规则配置/etc/login.defs 配置文件通过该文件可以定义在创建新用户时的一些默认设置，其中： MAIL_DIR 字段：系统邮件文件存放位置； PASS_MAX_DAYS 字段：用户密码持续有效天数； PASS_MIN_DAYS 字段：用户密码允许修改的最短间隔天数； PASS_MIN_LEN 字段：允许设置的密码最小长度； PASS_WARN_AGE 字段：自系统给出提醒到密码完全失效的间隔天数； UID_MIN 字段：允许设置的最小用户 ID； UID_MAX 字段：允许设置的最大用户 ID； GID_MIN 字段：允许设置的最小用户组 ID； GID_MAX 字段：允许设置的最大值用户组 ID； CREATE_HOME 字段：是否创建用户 HOME 目录，yes 表示创建。 /etc/default/useradd 配置文件通过该文件可以定义在使用 useradd 或 adduser 命令创建新用户时的一系列创建规则，其中： HOME 字段：用户 HOME 目录的所在目录； INACTIVE 字段：是否启用账号过期停权，-1 表示不启用； EXPIRE 字段：账号失效日期，为空表示不启用； SHELL 字段：默认 SHELL 类型，需指明全路径； SKEL 字段：创建用户 HOME 目录时拷贝的初始启动文件的存放位置。 用户账号信息系统文件/etc/passwd 文件该文件记录了用户的一些基本属性，一行记录对应于一个用户，每行记录又以 : 分隔为 7 个字段，分别为： 用户名:登录密码:用户 ID :用户组 ID :注释性描述信息: HOME 目录:登录 SHELL “用户名”中不能有分隔符 : ，不宜超过 8 个字符，不宜包含字符 . ，不宜以字符 - 或 + 开头。 “登录密码”为密码加密字符串。出于安全考虑，在采用了 shadow 技术的现代 Linux 系统中，本文件中该字段一般设为字符 x 或 *。 “用户 ID”相同而用户名不同的多个用户，系统视为同一个用户，对系统中的文件拥有相同的访问权限，但可以有不同的登录密码、不同的 HOME 目录和不同的登录 SHELL 等。 “注释性描述信息”可以记录一些与用户相关的个人信息，没有实际用途。 “登录 SHELL”也可以指定为某特定的程序，即用户只能运行该指定程序，程序运行结束后自动退出登录。 另外，该文件中还记录了一些伪用户的信息，它们的登录 SHELL 为空，即不能登录。它们的存在主要是为了方便系统管理，满足相应的系统进程支文件所有者属性的要求。 /etc/shadow 文件该文件记录了与用户密码相关的信息，同样地，一行记录对应于一个用户，每行记录又以 : 分隔为 8 个字段，分别为： 用户名:登录密码:最后修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 “用户名”与 /etc/passwd 文件中保持一致，唯一地表征一个单独的用户。 “最后修改时间”为最后一次修改用户登录密码的时间，其值为自 1970 年 1 月 1 日起算的天数。 “最小时间间隔”指定两次修改登录密码的最小间隔天数。 “最大时间间隔”指定登录密码持续有效的最大天数。 “警告时间”指定自系统给出提醒到密码完全失效的间隔天数。 “不活动时间”指定账号保持有效的用户连续不登录的最大天数。 “失效时间”指定用户账号失效的时间，其值为自 1970 年 1 月 1 日起算的天数。 /etc/group 文件该文件记录了用户组的相关信息，一行记录对应于一个用户组，每行记录又以 : 分隔为 4 个字段，分别为： 用户组名:用户组密码:用户组 ID :组内用户列表 “用户组名”由字母或数字构成，不应重复。 “用户组密码”为密码加密字符串。出于安全考虑，在采用了 shadow 技术的现代 Linux 系统中，本文件中该字段一般设为字符 x 或 *。 “组内用户列表”中，多个用户以逗号 , 分隔。 批量创建用户准备文件先参照 /etc/passwd 文件的格式，创建一个文本用户文件 user.txt，如： 12user001::600:100:user:/home/user001:/bin/bashuser002::601:100:user:/home/user002:/bin/bash 再创建一个密码对照文件 passwd.txt，如： 12user001:明码密文user002:明码密文 创建用户 [root@A ~]$ newusers &lt; user.txt：从用户文件 user.txt 中导入数据，创建用户； [root@A ~]$ pwunconv：取消 shadow password 功能，将 /etc/shadow 中的用户密码写入 /etc/passwd 中，删除 /etc/shadow 文件，方便下一步的密码转换； [root@A ~]$ chpasswd &lt; passwd.txt：按照默认的加密方式，将用户密码加密后写入 /etc/passwd 的密码栏； [root@A ~]$ pwconv：重新启用 shadow password 功能，创建 /etc/shadow 文件，删除 /etc/passwd 中的用户密码。 常见问题总结mount.nfs: requested NFS version or transport protocol is not supported在挂载远程目录时，出现这个错误时，可能是由于远程服务器的 nfs 服务未正常启动，可登陆至目标服务器上进行 nfs 服务重启。 若重启失败并报错 “A dependency job for nfs-server.service failed. See ‘journalctl -xe’ for details.”，则可以命令 [root@A ~]$ journalctl -xe 查看出错原因。 若发现本地磁盘自动挂载失败，则重新手动挂载该磁盘后再重启 nfs 服务即可。 *注：先以命令 [root@A ~]$ service rpcbind restart 重启 rpcbind 服务，再以命令 [root@A ~]$ service nfs restart 重启 nfs 服务。 pbsnodes 工作异常在调用 pbsnodes 命令时出现异常，可能是由于某些 PBS 节点的 pbs 服务未正常启动，可登陆至该节点以命令 [root@A ~]$ service pbs start 重启 pbs 服务即可。 多用户组用户的组间切换多用户组用户在登录时默认登录到初始登录用户组，通过命令 [user@A ~]$ newgrp groupname 即可切换到附加用户组。 PGI 社区免费版 License 过期修改 PGI 社区免费版安装目录下的 license.dat 文件中 FEATURE 行的日期为将来的某一日期即可。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动中值滤波边界问题]]></title>
    <url>%2F2018%2F07%2F21%2FBoundary-problem-of-Moving-Median-Filter%2F</url>
    <content type="text"><![CDATA[From Wikipedia, to handle missing window entries at the boundaries of the signal, there are some schemes that have different properties that might be preferred in particular circumstances: The first value is repeated, as with the last value, to obtain enough entries to fill the window. Avoid processing the boundaries, with or without cropping the signal boundaries afterwards. Shrinking the window near the boundaries, so that every window is full. Fetching entries from other places in the signal.]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Inversion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Fortran 90 中使用 netCDF 数据格式简介]]></title>
    <url>%2F2018%2F07%2F20%2FFortran90-netCDF-Introduction%2F</url>
    <content type="text"><![CDATA[本文翻译自 Michael Thorne (michael.thorne@utah.edu) 所执笔的 Introduction to using the netCDF data format with Fortran 90（故而文中所有自称均指代原文作者），谨供学习在 Fortran 中使用 netCDF 数据格式之用。 引言netCDF（即 network Common Data Form）为存储多维数据而产生的一种基于数组的数据结构。一个 netCDF 文件采用 ASCII 头书写，以二进制格式存储数据。因为我们不必担心字节序的问题，以二进制文件来保存数据具有明显的优势。字节交换可以通过调用 netCDF 库来实现，netCDF 文件可以在任何平台上读取。与使用 netCDF 数据格式相关的特性如下： 坐标系：支持 N 维坐标系。 X 坐标（如，纬度） Y 坐标（如，经度） Z 坐标（如，高程） 时间维度 其他维度 变量：支持多重变量。 如，S 波速度，P 波速度，密度，应力分量…… 空间几何：支持多种网格类型（隐式或显式）。 规则网格（隐式） 不规则网格 数据点 自我描述：数据集可以包括数据定义信息。 单位（如，km，m/sec……） 注释（如，标题，调用约定，变量名（如，P 波速度），坐标单位（如，km/sec），……） 关于数据格式的更全的文档在： netCDF 主页 netCDF 文档 F90 接口指导 文件名约定：netCDF 文件通常以 .nc 为扩展名。文件约定：有很多 netCDF 数据风格和约定。在地震学中，人们对 .grd 文件（GMT 软件生成）最熟悉。为了符合 GMT 的要求，采用 COARDS (Cooperative Ocean/Atmosphere Research Data Service) 数据约定书写 netCDF 文件。我开始使用 netCDF 文件的原因之一是，网格信息也可以随数据一同保存下来。因此，在使用类似 GMT 的软件时我不必显式地书写 xyz2grd 命令对数据成图和记忆正在成图的数据文件的范围（GMT 中的 -R 选项）以及网格增量（-I 选项）是多少。然而，只能在直角坐标系统下使用 COARDS 约定。坐标可以不等间距，但必须单调递增或单调递减。很不幸，在不使用类似 blockmean 的命令对数据进行预处理时，GMT 是不能对不等间距网格进行操作的。可视化：使用 netCDF 格式还有一个明显的优势，即有多种数据查看器。另外，几乎所有的我熟悉的可视化包都可以读取 netCDF 格式。这里有一些常用的免费查看器或可视化包： Ncview Data Explorer (OpenDX) 文件结构netCDF 文件包含如下结构： netCDF 文件结构 作用 全局属性 描述文件内容 维度 描述数据结构（如，时间，深度，纬度，经度） 变量 按照维度存储数据的数组 变量属性 描述每个变量的内容 另参见 博文]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>netCDF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim 配置、技巧及其周边]]></title>
    <url>%2F2018%2F07%2F20%2FTips-of-Vim%2F</url>
    <content type="text"><![CDATA[常用配置函数Vim 有一些配置函数，利用这些函数，我们可以通过修改配置文件让我们的 Vim 发挥出更强大的功能。 line(expr) The result is a Number , which is the line number of the file position given with expr .The accepted positions are: “.” the cursor position; “$” the last line in the current buffer; x position of mark “x” (if the mark is not set, 0 is returned). 返回值是一个整数。这个函数功能时返回一个行号。如果你后面的参数 expr 是 “.” 的话，则返回当前光标所在的位置。如果 expr 是 “$” 则返回当前缓冲区最后一行的行号。如果 expr 的值是一个标签名，则返回你对应的标签所在的行号。例如：call line(“.”) 得到当前光标所在的行号。 col({expr})返回指定位置的列号，列号从1开始算起。例如：echo col(“.”) 返回光标所在的列号。echo col(“$”) 返回光标所在的行的长度+1。echo col([2,’$’]) 返回第2行的长度+1。（之所以是长度+1是因为，其实每行的最后有一个不可打印的换行符） setpos({expr})移动光标到指定的行和列。例如：let pos=[0, 25, 15, 0]; call setpos(“.”, pos) 移动光标到 25 行 15 列的位置。 setline ({lnum}, {text}) Set line {lnum} of the current buffer to {text}.If this succeeds, 0 is returned. If this fails (most likely lnum is invalid) 1 is returned.When {lnum} is just below the last line the {text} will be added as a new line. 这个函数就是将第 lnum 行的内容替换成 text 中的内容。如果这个 lunm 行是最后一行的下面一行，那么将新建一行，然后将 text 的内容存放到这一行。如果不是最后一行的下一行，则要满足的条件是行号为 lnum 的行必须是存在的。例如：call setline(1, “/*********************/“) 在文件的开头添加上面的一行，主要是用于 .c/.cpp 文件注释的。 getline({lnum}, {end}) Without the {end},the result is a String, which is line {lnum} from the current buffer.When {end} is given the result is a List where each item is a line from the current buffer in the range {lnum} to {end}, including line {end}. 返回值是一个字符串。当 end 参数存在的时候，函数返回行号为 lnum 的内容，否则函数将返回行 lnum 到行 end 的所有内容（包括第 end 行）。例如：let lines=getline(2, 5); call append(6, lines) 取得 2-5 行的内容，然后从第六行的下一行开始添加，保持原来的格式不变。 append(lnum, string) Append the text string after line lnum in the current buffer. lnum can be zero, to insert a line before the first one. Returns 1 for failure (lnum out of range) or 0 for success. 这个函数就是将 string 这个字符串，插入到行号为 lnum 的下一行。成功则返回 0，否则返回 1 。 expand(expr [, flag]) Expand the file wildcards in expr . The result is a String .When the result of expr starts with% , # or &lt; , the expansion is done like for the cmdline- special variables with their associated modifiers. There cannot be a white space between the variables and the following modifier. When the current or alternate file name is not defined, % or # use an empty string. Using %:p in a buffer with no name results in the current directory, with a “/ ”added.When {expr} starts with ‘%’, ‘#’ or ‘&lt;’, the expansion is done like for the |cmdline-special| variables with their associated modifiers. Here is a short overview:“%” current file name;“#“ alternate file name;“#n” alternate file name n.Modifiers::p expand to full path;:h head (last path component removed);:t tail (last path component only);:r root (one extension removed);:e extension only. 函数的返回值是一个字符串。功能就是将参数 expr 这个通配符进行扩展。各个通配符的含义上面列出来了。例如：call append(2, “File Name: “.expand(“%”)) 在文件的第三行写入这句话 “File Name: ${filename}”，这边%表示当前文件的名称，通过函数expand（”%”）将其还原成了文件名字符串。let sourcefilepath=expand(“%:p”) 获取到当前文件的完全路径（绝对路径）。 配置函数应用举例在用 Vim 打开文件后，在命令模式下，输入命令1:echo col(".") 即返回光标所在的列号。在「$HOME/.vimrc」文件中添加如下语句 123if has("autocmd") au BufReadPost * if line("'.") &gt; 0 &amp;&amp; line("'.") &lt;= line("$") | exe "normal! `." | endifendif 此设置即在文件打开时，如果文件上次编辑的位置存在（即不在 1 行和最大行数以外），自动跳转至上次编辑的位置。此外，可以使用1au BufReadPost * if line("'\"") &gt; 1 &amp;&amp; line("'\"") &lt;= line("$") | exe "normal! '\"" | endif 跳转至上次离开的行首。使用1au BufReadPost * if line("'\"") &gt; 0 &amp;&amp; line("'\"") &lt;= line("$") | exe "normal! `\"" | endif 跳转至上次离开的位置。 Vim 配置收录以下： 配置 功能 set hlsearch 搜索时高亮反白匹配字符串 set autoindent 自动缩排 set ruler 底边显示状态栏 set showmode 左下角显示模式状态 set nu 行首显示行号 set bg=dark 设置底色色调 syntax on 开启语法检查 set nocompatible 不使用兼容模式 set textwidth=0 或 set tw=0 设置行宽，为 0 时即不自动换行 set backup 开启自动备份 set bdir=~/.vim 设置备份目录 set history=50 设置命令历史长度 set tabstop=4 或 set ts=4 设置制表符 tab 长度 set shiftwidth=2 或 set sw=2 设置自动缩进空格数 set showcmd 显示命令 set showmatch 显示匹配 set ignorecase 忽略大小写 set incsearch 输入搜索命令时显示当前匹配 set autowrite 执行外部命令时自动保存 set nolist 不显示不可见字符 set mouse=a 鼠标可用 set nowrap 不自动折行 set expandtab 采用空格代替制表符 tab 缩进 set cursorline 高亮当前行 set cursorcolumn 高亮当前列 set relativenumber 显示相对行号 set colorcolumn=80 设置高亮某列 highlight ColorColumn ctermfg=9 ctermbg=242 设置列高亮背景色 注：本表持续更新中 将以上配置写入「 $HOME/.vimrc 」文件，即可对所有文件打开生效。如果想要对某些文件采用不同的打开初始配置，可在相应的文件末尾加入类似如下语句1# vim:ft=make:sw=4:wrap 该文件为一个 makefile 文件，第一个字符 “#” 为 makefile 文件的注释符，不同的文件可以采用各自相应的注释符。”ft=make” 即指文件格式为 makefile 文件，Vim 自动按 makefile 语法高亮文本，”sw=4” 即设置自动缩进空格数为 4，”wrap” 即设置自动折行，在这里，省去配置语句中的 set，不同的配置语句间用 “:” 隔开。 Vim 命令技巧收录以下： 命令 作用 :se cuc 垂直竖杠（即 set cursorcolum） :Sex 浏览目录 :helpgrep ColorColumn 查找与 ColorColumn 相关的帮助 :hi 查看 highlight 的系统配色方案 注：本表持续更新中 更多 Vim 插件介绍参见 博文 。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My First Blog Attemp]]></title>
    <url>%2F2018%2F07%2F18%2FMy-first-blog-attemp%2F</url>
    <content type="text"><![CDATA[Welcome but enter password to read Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>New Attemp</category>
      </categories>
      <tags>
        <tag>WillDelete</tag>
      </tags>
  </entry>
</search>
