<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[平均自由程 (Mean Free Path)]]></title>
    <url>%2F2020%2F10%2F11%2FMean-Free-Path%2F</url>
    <content type="text"><![CDATA[本文译自 Mean Free Path。 平均自由程平均自由程，即气体分子两次碰撞间自由运动的平均路程，可根据气体动力学理论（kinetic theory）估计得出。Serway 方法是一种很好的可视化方法，它假设分子直径为 $d$，则碰撞的有效横截面为 即用一个直径为 $2d$ 的圆代表某一分子的有效碰撞区域，同时将目标分子视为一个质点。在时间 $t$ 内，该圆将扫过如下图所示的体积，碰撞的数量可以由该体积内的气体分子数目估计得到。 平均自由程可由路程长度除以碰撞数量求得： $$ \text{平均自由程估计} = \frac{\bar{v} t}{\pi d^2 \bar{v} t n_v} = \frac{1}{\pi d^2 n_v} $$ 其中，分子上 $\bar{v} t$ 为分子移动距离；分母中 $\pi d^2 \bar{v} t$ 为分子间相互作用的体积，$n_v$ 为每单位体积内的分子数目。上式整体即每碰撞间的平均距离。 上式中存在的问题是，这里参与计算的是分子平均速度，但目标分子也一直在移动，碰撞的频率依赖于自由运动分子的平均相对速度。 平均相对速度为了计算气体分子的平均自由程，需要估算出分子间的平均相对速度，而不仅仅是某一给定分子的平均速度。任意两个分子的相对速度都可以用它们的矢量速度来表示。 相对速度的幅值可表示为它自己的标量积的平方根，即 $$ v_{\text{rel}} = \sqrt{\vec{v}_{\text{rel}} \cdot \vec{v}_{\text{rel}}} $$ 可进一步表示为 $$ v_{\text{rel}} = \sqrt{(\vec{v}_1 - \vec{v}_2) \cdot (\vec{v}_1 - \vec{v}_2)} $$ $$ v_{\text{rel}} = \sqrt{\vec{v}_1 \cdot \vec{v}_1 - 2 \vec{v}_1 \cdot \vec{v}_2 + \vec{v}_2 \cdot \vec{v}_2} $$ 对上式中各项取平均，由于 $\vec{v}_1$ 和 $\vec{v}_2$ 随机且无关，则 $\overline{\vec{v}_1 \cdot \vec{v}_2} = 0$，所以 $$ \overline{v_{\text{rel}}} = \sqrt{\overline{\vec{v}_1 \cdot \vec{v}_1} - 2 \overline{\vec{v}_1 \cdot \vec{v}_2} + \overline{\vec{v}_2 \cdot \vec{v}_2}} = \sqrt{\bar{v}_1^2 + \bar{v}_2^2} $$ 又因为每个分子的平均速度是一样的，即 $\bar{v}_1 = \bar{v}_2 = \bar{v}$，所以平均相对速度为 $$ \overline{v_{\text{rel}}} = \sqrt{2} \bar{v} $$ 平均自由程的修正上面给出的平均自由程的初步计算公式有一个严重的缺陷，即假设目标分子处于静止状态，而实际上它们有很高的平均速度。这里需要的是平均相对速度，如前所述，由分子速度分布（speed distribution）计算得到的平均相对速度为 $$ \overline{v_{\text{rel}}} = \sqrt{2} \bar{v} $$ 则在时间 $t$ 内扫过的有效体积为 $\pi d^2 \sqrt{2} \bar{v} t$，最终的平均自由程为 $$ \lambda = \frac{1}{\sqrt{2} \pi d^2 n_v} $$ 再由理想气体方程（Ideal Gas Law） $$ P V = n R T $$ 则 $$ n_v = \frac{n N_A}{V} = \frac{n N_A}{n R T / P} = \frac{N_A P}{R T} $$ $$ \lambda = \frac{R T}{\sqrt{2} \pi d^2 N_A P} $$ 其中，$n$ 为摩尔数，$R = 8.3145~\text{J/mol} \cdot \text{K}$ 为气体常数，$P$ 为绝对压力，$V$ 为气体体积，$T$ 为绝对温度，$N_A = 6.0221 \times 10^{23}~\text{mol}^{-1}$ 为阿伏加德罗常数（Avogadro’s number）。 需要注意的是，上式中的平均自由程的计算，将分子视为坚硬的球体，而实际的分子却不是这样的。对于惰性气体，碰撞是近乎完全弹性的，坚硬球体近似也是合适的。但实际分子存在偶极距，当它们相互靠近时会发生强烈的电相互作用。可以通过分子电势来进一步改进计算，也可以将气体的实测粘度视为一个参数来改进实际气体中分子平均自由程的估计。 算例与理想气体的平均分子间距相比，你可能惊讶于平均自由程的长度。假设分子大小为 $0.3~\text{nm}$，计算其他距离如下：]]></content>
  </entry>
  <entry>
    <title><![CDATA[数字信号处理的猫腻]]></title>
    <url>%2F2020%2F08%2F03%2FDigital-Signal-Processing%2F</url>
    <content type="text"><![CDATA[白噪声参考 Wikipedia。 白噪声是一种功率谱密度为常数的随机信号（或随机过程），即此信号在各个频段上的功率一致。理想的白噪声具有无限带宽，因而其能量是无限大的。 在离散时间信号中，白噪声可以看做是由均值为零、方差有限的不相关随机变量离散采样得到的信号序列。 需要注意的是，相关性和概率分布是两个不同的概念。“白”仅意味着信号是不相关的，白噪声的定义除了要求均值为零外并没有对信号应当服从的概率分布作出任何假设。 谱白化参考 StackExchange。 一些讨论 What is meant by “spectral whitening” in DSP ? Spectral whitening is usually an attempt to make the spectrum of the signal “more uniform”. One reason this might be a good thing to do is that it can have the effect of making the autocorrelation of the signal “narrower” (and closer to a Dirac delta, for discrete-time signals). This can help localize in time. Where might spectral whitening be useful in audio processing or analysis ? If you are trying to localize (in time) the onset of a sound, then it’s possible that spectral whitening can improve this. It’s also possible that it can reduce the SNR.]]></content>
      <categories>
        <category>Tricks</category>
      </categories>
      <tags>
        <tag>DSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPI 二维切割子程序 MPI_CART_CREATE、MPI_CART_COORDS 和 MPI_CART_SHIFT]]></title>
    <url>%2F2020%2F07%2F02%2FMPI-Cartesian-Function%2F</url>
    <content type="text"><![CDATA[写在前面 注：这里只介绍了 MPI 二维切割在 Fortran 语言中的应用，于 C 语言，类似但略有差别。 专用词语转录说明如下： 原词 转录 程式 程序 副程式 子程序 阵列 数组 叫用 调用 引数 参数 communicator 通信域 CPU id 进程编号 整数阵列 整型数组 逻辑阵列 逻辑型数组 变数 变量 安排 排布 运作 运行 邻居 邻位 垂直坐标图示法则（Cartesian Topology）二维数组 A(NN, MM) 要做二维切割时，需先说明在第一维和第二维各切成几块。例如第一维要切成四块，第二维要切成三块，则切割后第一维的长度 N 为 NN/4，第二维的长度 M 为 MM/3，当然两者都必须能整除才行。如果 NN = 200 和 MM = 150，就可以使用 PARAMETER 来设定 M、N 的值，切割后数组的第一维和第二维都要预留前后各一个数组元素位置时，其参数可设定为： 12PARAMETER (NN=200, MM=150, JP=4, IP=3, N=NN/JP, M=MM/IP,)DIMENSION A(0:N+1, 0:M+1) 数组 A 切成 4×3 十二块，第一块由一个 CPU 来执行时，则需要十二个 CPU。这十二个 CPU 的编号和坐标如下图所示：十二个 CPU 之中每一个 CPU 的上、下、左、右邻位关系如上图所示。水平方向 X 轴为第一维 (J) ，垂直方向 Y 轴为第二维 (I) 。 MPI_CART_CREATE二维切割方式必须在调用 MPI_CART_SIZE、MPI_COMM_RANK 分别取得通信域的进程数和进程编号等之后，再调用 MPI 子程序 MPI_CART_CREATE 来加以设定。如上图所示的二维切割方式，其相应的参数设定如下： 123456789101112131415PARAMETER (NDIM=2, JP=4, IP=3)INTEGER NPROC, MYIDINTEGER IPART(NDIM), COMM2D, MY_CID, MY_COORD(NDIM)INTEGER SIDEWAYS, UPDOWN, RIGHT, UP, L_NBR, R_NBR, T_NBR, B_NBRLOGICAL PERIODS(NDIM), REORDER...CALL MPI_INIT (IERR)CALL MPI_COMM_SIZE (MPI_COMM_WORLD, NPROC, IERR)IPART(1)=JPIPART(2)=IPPERIODS(1)=.FALSE.PERIODS(2)=.FALSE.REORDER=.TRUE.CALL MPI_CART_CREATE (MPI_COMM_WORLD, NDIM, IPART, PERIODS, REORDER, COMM2D, IERR) 参数 含义 MPI_COMM_WORLD 原来的通信域 NDIM 切割的维数，上图中二维切割的例子需设定为 2 IPART NDIM 个元素的整型数组 IPART(1) 第一维切成的块数，上图中的例子需设定为 4 IPART(2) 第二维切成的块数，上图中的例子需设定为 3 PERIODS NDIM 个元素的逻辑型数组 PERIODS(1) 第一维首尾区块是否相邻，是为 .TRUE. 否为 .FALSE. ，上图中的例子需设定为 .FALSE. PERIODS(2) 第二维首尾区块是否相邻，是为 .TRUE. 否为 .FALSE. ，上图中的例子需设定为 .FALSE. REORDER 逻辑型变量，已排定的 CPU 是否重排，是为 .TRUE. 否为 .FALSE. ，一般设为 .TRUE. COMM2D 切割后得到的新通信域 在调用 MPI_CART_CREATE 之前已经调用过 MPI_COMM_RANK，已经排布好各个 CPU 了，这是一种线性排布。在调用 MPI_CART_CREATE 时，是一种平面排布，当 REORDER 的值设定为 .TRUE. 时，允许系统重新排布各个 CPU，使得相邻的 CPU 排布在相邻的位置上，从而得到最佳的传输效率。 MPI_CART_COORDS此后，程序在新的的通信域 COMM2D 中运行，之前获取的进程编号已经不再适用。必须重新调用 MPI_COMM_RANK 获取当前 CPU 在新的通信域中的进程号。MPI_COMM_RANK 的调用格式如下： 1CALL MPI_COMM_RANK (COMM2D, MYID, IERR) 参数 含义 COMM2D 新设定的通信域 MYID 在通信域 COMM2D 中的新的进程号 MYID 的排布方式如上图中的 CPU0、CPU1、CPU2 等所示。接下来就须调用 MPI_CART_COORDS 获取当前 CPU 在二维 CPU 数组中的坐标 MY_COORD。调用格式如下： 1CALL MPI_CART_COORDS (COMM2D, MY_CID, NDIM, MY_COORD, IERR) 参数 含义 COMM2D 新设定的通信域 MY_CID 在通信域 COMM2D 中的进程号 NDIM 切割的维数，如上图中的例子需设定为 2 MY_COORD NDIM 个元素的整型数组，进程号为 MY_CID 的 CPU 的 CPU 数组坐标 MY_COORD(1) 第一维方向上的坐标，从 0 起算 MY_COORD(2) 第二维方向上的坐标，从 0 起算 CPU 坐标 MY_COORD 的排布方式如上图中 CPU0、CPU1、CPU2 等进程号下的括号内的数字。由上图易知：当 MY_COORD(1) 为 0 时，该 CPU 位于 CPU 数组的最左边；当 MY_COORD(1) 为 JP - 1 时，该 CPU 位于 CPU 数组的最右边；当 MY_COORD(2) 为 0 时，该 CPU 位于 CPU 数组的最下面（底边）；当 MY_COORD(2) 为 IP - 1 时，该 CPU 位于 CPU 数组的最上面（顶边）。 MPI_CART_SHIFT现在，还须调用 MPI_CART_SHIFT 来获取当前 CPU 的上、下、左、右邻位的进程号。调用格式如下： 12345678INTEGER SIDEWAYS, UPDOWN, RIGHT, UPSIDEWAYS=0UPDOWN=1RIGHT=1UP=1CALL MPI_CART_SHIFT (COMM2D, SIDEWAYS, RIGHT, L_NBR, R_NBR, IERR)CALL MPI_CART_SHIFT (COMM2D, UPDOWN, UP, B_NBR, T_NBR, IERR) 参数 含义 COMM2D 新设定的通信域 SIDEWAYS 整型变量，其值为 0 表示获取第一维 (J) 方向的邻位 RIGHT 整型变量，其值为 1 表示获取左、右邻位 L_NBR 整型变量，其值为获取的当前 CPU 的左邻位的进程号 R_NBR 整型变量，其值为获取的当前 CPU 的右邻位的进程号 参数 含义 UPDOWN 整型变量，其值为 1 表示获取第二维 (I) 方向的邻位 UP 整型变量，其值为 1 表示获取下、上邻位 B_NBR 整型变量，其值为获取的当前 CPU 的下邻位的进程号 T_NBR 整型变量，其值为获取的当前 CPU 的上邻位的进程号 这里，L_NBR、R_NBR、B_NBR 和 T_NBR 分别代表 left_neighbor、right_neighbor、bottom_neighbor 和 top_neighbor。 参考 郑守成，2002，《Fortran 語言 MPI 平行计算程式设计》第五章 5.4 节]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>MPI</tag>
        <tag>Parallel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一本正经的贝叶斯理论]]></title>
    <url>%2F2019%2F11%2F19%2FBayes-theorem-in-Wikipedia%2F</url>
    <content type="text"><![CDATA[贝叶斯统计学 Bayesian statistics Bayesian statistics is a theory in the field of statistics based on the Bayesian interpretation of probability where probability expresses a degree of belief in an event. The degree of belief may be based on prior knowledeg about the event, such as the results of previous experiments, or on personal beliefs about the event. This differs from a number of other interpretations of probability, such as the frequentist interpretation that views probability as the limit of the relative frequency of an event after many trials. 贝叶斯统计学是一套基于贝叶斯概率解释的统计学理论，它将概率表达为一个事件的置信度。置信度是基于事件的先验信息（如先前实验的结果）或个人对事件的信任度的。这一点不同于其它的概率解释理论，如频率学解释认为概率是在多次试验后事件发生的相对频率的极限。 先验概率 Prior probability The prior probability of a random event or an uncertain proposition is the unconditional probability that is assigned before any relevant evidence is taken into account. 一个随机事件或不确定命题的先验概率是在未考虑任何相关观测情况下的无条件概率（绝对概率）。 后验概率 Posterior probability The posterior probability of a random event or an uncertain proposition is the conditional probability that is assigned after the relevant evidence or background is taken into account. 一个随机事件或不确定命题的后验概率是在考虑了相关观测或背景的情况下的条件概率。 “Posterior”, in this context, means after taking into account the relevant evidence related to the particular case being examined. For instance, there is a “non-posterior” probability of a person finding buried treasure if they dig in a random spot, and a posterior probability of finding buried treasure if they dig in a spot where their metal detector rings. 这里的“后验”是指在考虑了与被测试事件有关的相关观测之后。例如：如果一个人随机地取点开挖寻找地下宝藏，这是一个“非后验”概率；如果一个人在先用金属探测器圈起来的点上开挖寻宝，这就是一个后验概率。 贝叶斯理论 Bayes’ theorem Bayes’ theorem is a fundamental theorem in Bayesian statistics, as it is used by Bayesian methods to update probabilities, which are degrees of belief, after obtaining new data. Given two events $A$ and $B$, the conditional probability of $A$ given that $B$ is true is expressed as follows:$$ P(A \vert B) = \frac{ P(B \vert A) P(A)}{P(B)} $$where $P(B) \neq 0$. Although Bayes’ theorem is a fundamental result of probability theory, it has a specific interpretation in Bayesian statistics. In the above equation, $A$ usually represents a proposition (such as the statement that a coin lands on heads fifty percent of the time) and $B$ represents the evidence, or new data that is to be taken into account (such as the result of a series of coin flips). $P(A)$ is the prior probability of $A$ which expresses one’s beliefs about $A$ before evidence is taken into account. The prior probability may also quantify prior knowledge or information about $A$. $P(B \vert A)$ is the likelihood function, which can be interpreted as the probability of the evidence $B$ given that $A$ is true. The likelihood quantifies the extent to which the evidence $B$ supports the proposition $A$. $P(A \vert B)$ is the posterior probability, the probability of the proposition $A$ after taking the evidence $B$ into account. Essentially, Bayes’ theorem updates one’s prior beliefs $P(A)$ after considering the new evidence $B$. 贝叶斯理论是贝叶斯统计学中的一个基础理论，用于贝叶斯方法中在获得新数据后更新概率（置信度）。给定两个事件 $A$ 和 $B$，在 $B$ 为真是情况下 $A$ 的条件概率可以表达为： $$ P(A \vert B) = \frac{P(B \vert A) P(A)}{P(B)} $$ 其中 $P(B) \neq 0$。尽管贝叶斯理论是概率理论的一个基本结果，但它在贝叶斯统计学中有特别的解释。在上式中，$A$ 常常表示一个命题（如一枚硬币有 $50%$ 的机会人头朝上落地），$B$ 表示将被考虑在内的观测或新数据（如一系列掷硬币的结果）。$P(A)$ 是用来表征在考虑观测之前 $A$ 的可信度的 $A$ 的先验概率。先验概率也可以由 $A$ 的先验信息量化得到。$P(B \vert A)$ 是用来表征在考虑了观测 $B$ 之后的命题 $A$ 的概率的似然函数。本质上，贝叶斯理论就是在考虑了新的观测 $B$ 之后更新先验可信度 $P(A)$。 The probability of the evidence $P(B)$ can be calculated using the law of total probability. If ${A_1, A_2, \ldots, A_n }$ is a partition of the sample space, which is the set of all outcomes of an experiment, then,$$ P(B) = P(B \vert A_1) P(A_1) + P(B \vert A_2) P(A_2) + \cdots + P(B \vert A_n) P(A_n) = \sum_i P(B \vert A_i) P(A_i) $$When there are an infinite number of outcomes, it is necessary to integrate over all outcomes to calculate $P(B)$ using the law of total probability. Often, $P(B)$ is difficult to calculate as the calculation would involve sums or integrals that would be time-consuming to evaluate, so often only the product of the prior and likelihood is considered, since the evidence does not change in the same analysis. The posterior is proportional to this product:$$ P(A \vert B) \propto P(B \vert A) P(A) $$ 观测的概率 $P(B)$ 可以利用全概率公式计算得到。设 ${A_1, A_2, \ldots, A_n }$ 是采样空间的各个分区，它是试验的所有输出的集合，则 $$ P(B) = P(B \vert A_1) P(A_1) + P(B \vert A_2) P(A_2) + \cdots + P(B \vert A_n) P(A_n) = \sum_i P(B \vert A_i) P(A_i) $$ 如果有无限个输出，则需要根据全概率公式对所有输出做积分来求取 $P(B)$。由于计算涉及耗时的求和或积分，$P(B)$ 总是不易求得，所以常常只考虑先验概率和似然函数的积，因为观测在分析中是不变的。后验概率正比于二者之积： $$ P(A \vert B) \propto P(B \vert A) P(A) $$]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seislab 管理脚本备份]]></title>
    <url>%2F2019%2F09%2F29%2FScripts-for-seislab-root%2F</url>
    <content type="text"><![CDATA[机器新装新机系统设置脚本 setting.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#!/bin/bashset -eyeah='\033[32mYeah\033[39m'warn='\033[33mWarning\033[39m'error='\033[31mERROR\033[39m'function finishprint() &#123; if [ $&#123;1&#125; -eq 0 ]; then echo -e "$&#123;yeah&#125;: Finish $&#123;2&#125; when setting $&#123;3&#125;" else echo -e "&gt;&gt; $&#123;error&#125;: Fail $&#123;2&#125; when setting $&#123;3&#125;" fi&#125;# no-password loginoperation="no-password loging"echo "==========================================================================="echo "Set $&#123;operation&#125;:"systemctl stop firewalld.service finishprint $? "1/4" $&#123;operation&#125;systemctl disable firewalld.service finishprint $? "2/4" $&#123;operation&#125;setenforce 0 finishprint $? "3/4" $&#123;operation&#125;echo " &gt; please edit /etc/selinux/config: SELINUX=... =&gt; SELINUX=disabled"read -p " &gt; press any key to edit:"vi /etc/selinux/config finishprint $? "4/4" $&#123;operation&#125;# EPEL sourceoperation="EPEL source"echo "==========================================================================="echo "Set $&#123;operation&#125;:"yum -y install epel-release finishprint $? "1/2" $&#123;operation&#125;yum clean all &amp;&amp; yum makecache finishprint $? "2/2" $&#123;operation&#125;# ELRepo sourceoperation="ELRepo source"read -p "&gt; Do you want to configure ELRepo source? (Y/n):" ELRepoif [ "$&#123;ELRepo&#125;" == "Y" ]; then echo "===========================================================================" echo "Set $&#123;operation&#125;:" rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org finishprint $? "1/2" $&#123;operation&#125; read -p " &gt; please enter version number (x.x-x):" ver rpm -Uvh http://www.elrepo.org/elrepo-release-$&#123;ver&#125;.e17.elrepo.noarch.rpm finishprint $? "2/2" $&#123;operation&#125;fi# rename hostoperation="hostname"echo "==========================================================================="echo "Set $&#123;operation&#125;:"read -p " &gt; please enter a new hostname:" hosthostnamectl set-hostname $&#123;host&#125; finishprint $? "1/1" $&#123;operation&#125;# modify timezoneoperation="timezone"echo "==========================================================================="echo "Set $&#123;operation&#125;:"timedatectl set-timezone Asia/Shanghai &amp;&amp; timedatectl set-local-rtc 1 finishprint $? "1/1" $&#123;operation&#125;# some soft-linkoperation="soft-links"echo "==========================================================================="echo "Set $&#123;operation&#125;:"mkdir -p /opt/intel/licenses finishprint $? "1/3" $&#123;operation&#125;ln -s /home/data/system/software/intel_compiler.lic /opt/intel/licenses/intel_compiler.lic finishprint $? "2/3" $&#123;operation&#125;ln -s /home/data/system/motd.sh /etc/profile.d/ finishprint $? "3/3" $&#123;operation&#125;echo "==========================================================================="echo "&gt; Finish all auto-config \\(^.^)/"echo "&gt; Next you should (optional):"echo " 1) install more basic softwares (software.sh);"echo " 2) setup font library;"echo " 3) install and configure InfiniBand;"echo " 4) mount local disk and remote directory (mount.all.sh);"echo " 5) install and configure PBS Pro;"echo " 6) install and configure NVIDIA driver and cuda library;"echo " 7) copy user information files (cpusr.all.sh)."echo 新机软件安装脚本 software.sh123456789101112131415161718192021#!/bin/bashset -eread -p "Ensure to install these softwares [-y/ ]:" YorN# compileryum $&#123;YorN&#125; install gcc-gfortran gcc-c++.x86_64# shellyum $&#123;YorN&#125; install zsh# minitoolyum $&#123;YorN&#125; install vim htop tmux mlocate mkfontscaleyum $&#123;YorN&#125; install autojump &amp;&amp; yum $&#123;YorN&#125; install autojump-zsh.noarch# for remote mountyum $&#123;YorN&#125; install nfs-utils rpcbind# libraryyum $&#123;YorN&#125; install hdf5-devel 新机用户拷贝脚本 cpusr.first.sh123456789101112131415161718192021222324252627282930#!/bin/bashblacklist="asc sccp hym01"backdir=/root/backupuserdir=/home/data/system/userftemp1=/tmp/cpusr.1.$$ftemp2=/tmp/cpusr.2.$$mkdir -p $&#123;backdir&#125;function copy_info() &#123; cp /etc/$&#123;1&#125; $&#123;backdir&#125;/ cp $&#123;userdir&#125;/$&#123;1&#125; $&#123;ftemp1&#125; for i in $&#123;blacklist&#125; do cp $&#123;ftemp1&#125; $&#123;ftemp2&#125; cat $&#123;ftemp2&#125; | grep -v $&#123;i&#125; &gt; $&#123;ftemp1&#125; done cp $&#123;ftemp1&#125; /etc/$&#123;1&#125;&#125;copy_info passwdcopy_info groupcopy_info shadowcopy_info gshadowrm -f $&#123;ftemp1&#125; $&#123;ftemp2&#125; 日常维护单机操作单机新增用户拷贝脚本 cpusr.indv.sh12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/bin/bashusername=$&#123;1&#125;RED='\033[01;31m'STA='\033[00m'function copy_info() &#123; # backup the info.-file cp /etc/$&#123;3&#125; /root/backup/ # append the user-info. to file cat $&#123;1&#125;/$&#123;3&#125; | awk -F: '&#123;if($1 == "'$&#123;username&#125;'") print $0&#125;' &gt;&gt; $&#123;2&#125;/$&#123;3&#125; # check the info.-file echo "GREP &lt;$&#123;2&#125;/$&#123;3&#125;&gt;: " `grep $&#123;username&#125; $&#123;2&#125;/$&#123;3&#125;` echo&#125;function copy_user() &#123; if [ $&#123;username&#125; ]; then yon=$&#123;3&#125; if [ -z $&#123;yon&#125; ]; then echo -en "Ensure to copy user info. for $&#123;RED&#125;$&#123;username&#125;$&#123;STA&#125; [Y/n]: " read yon fi if [ "$&#123;yon&#125;" == "Y" ]; then # for /etc/passwd copy_info $&#123;1&#125; $&#123;2&#125; passwd # for /etc/group copy_info $&#123;1&#125; $&#123;2&#125; group # for /etc/shadow copy_info $&#123;1&#125; $&#123;2&#125; shadow # for /etc/gshadow copy_info $&#123;1&#125; $&#123;2&#125; gshadow fi else echo "No user to copy!" fi&#125;if [ `hostname` == "seislab1" ]; then copy_user /etc /home/data/system/user $&#123;2&#125;else copy_user /home/data/system/user /etc $&#123;2&#125;fi 单机普通目录远程挂载脚本 mount.indv.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#!/bin/bash#set -ehost=`hostname`yeah='\033[32mYeah\033[39m'warn='\033[33mWarning\033[39m'error='\033[31mERROR\033[39m'if [ "$&#123;host&#125;" == "seislab2" -o "$&#123;host&#125;" == "garray2" ]; then # for NO infiniband hosts: seislab2 and garray2 list="seislab1:xx.xx.xx.xxx:/public: \ seislab2:seislab2:/shdisk/lab2:/dev/sda2 \ seislab5:seislab5:/shdisk/lab5:/dev/sdb \ seislab6:seislab6:/shdisk/lab6:/dev/sdb \ seislab0:seislab0:/data:/dev/sda1 \ garray3:garray3:/shdisk/ary3:/dev/sda \ garray4:garray4:/shdisk/ary4:/dev/sdb \ remdata1:remdata1:/shdisk/rem1: "else # for other hosts: list="seislab1:192.18.1.101:/public: \ seislab2:seislab2:/shdisk/lab2:/dev/sda2 \ seislab5:seislab5:/shdisk/lab5:/dev/sdb \ seislab6:seislab6:/shdisk/lab6:/dev/sdb \ seislab0:seislab0:/data:/dev/sda1 \ garray3:garray3:/shdisk/ary3:/dev/sda \ garray4:garray4:/shdisk/ary4:/dev/sdb \ remdata1:remdata1:/shdisk/rem1: "fifunction print_help() &#123; echo echo "/home/data/system/scripts/mount.sh &lt;option&gt;" echo " option list:" echo " local - local mount its own devices on one host." echo " remote - remote mount other host directories on one host." echo " unload - umount all mounted directories on one host." echo exit $&#123;1&#125;&#125;function print_return_code() &#123; if [ $&#123;1&#125; -eq 0 ]; then echo -e "$&#123;yeah&#125;: Finished for $&#123;2&#125; @$&#123;3&#125;" else echo -e "&gt;&gt; $&#123;warn&#125;: Failed for $&#123;2&#125; @$&#123;3&#125;" fi&#125;function mount_list() &#123; for i in $&#123;list&#125; do hs=`echo $&#123;i&#125; | awk -F ":" '&#123;print $1&#125;'` ip=`echo $&#123;i&#125; | awk -F ":" '&#123;print $2&#125;'` mp=`echo $&#123;i&#125; | awk -F ":" '&#123;print $3&#125;'` dv=`echo $&#123;i&#125; | awk -F ":" '&#123;print $4&#125;'` if [ "$&#123;1&#125;" == "local" ]; then if [ "$&#123;host&#125;" == "$&#123;hs&#125;" ]; then if ! grep -qs "$&#123;mp&#125;" /proc/mounts; then if [[ -n $&#123;dv&#125; ]]; then mount $&#123;dv&#125; $&#123;mp&#125; print_return_code $? $&#123;mp&#125; $&#123;hs&#125; ls $&#123;mp&#125; fi fi fi fi if [ "$&#123;1&#125;" == "remote" ]; then if [ "$&#123;host&#125;" != "$&#123;hs&#125;" ]; then if ! grep -qs "$&#123;mp&#125;" /proc/mounts; then mount -t nfs $&#123;ip&#125;:$&#123;mp&#125; $&#123;mp&#125; print_return_code $? $&#123;mp&#125; $&#123;hs&#125; fi fi fi if [ "$&#123;1&#125;" == "unload" ]; then if grep -qs "$&#123;mp&#125;" /proc/mounts; then umount -l $&#123;mp&#125; print_return_code $? $&#123;mp&#125; $&#123;hs&#125; fi fi done&#125;if [ $# -ne 1 ]; then print_help 1else if [ $&#123;1&#125; == "-h" -o $&#123;1&#125; == "--help" ]; then print_help 0 elif [ $&#123;1&#125; == "local" -o $&#123;1&#125; == "remote" -o $&#123;1&#125; == "unload" ]; then mount_list $&#123;1&#125; else print_help 2 fifi 集群操作集群新增用户拷贝脚本 cpusr.all.sh1234567891011121314151617181920212223242526#!/bin/bashset -eRED='\033[01;31m'STA='\033[00m'cmdcpusr=/home/data/system/scripts/cpusr.indv.shnodelist="seislab1 seislab2 seislab3 seislab4 seislab5 seislab6 \ seislab0 garray1 garray2 garray3 garray4"username=$&#123;1&#125;yon=$&#123;2&#125;if [ -z $&#123;yon&#125; ]; then echo -en "Ensure to copy user info. for $&#123;RED&#125;$&#123;username&#125;$&#123;STA&#125; [Y/n]: " read yonfiif [ "$&#123;yon&#125;" == "Y" ]; then for i in $&#123;nodelist&#125; do echo "&gt;&gt; prepare to cpusr on $&#123;i&#125; ..." ssh $&#123;i&#125; "$&#123;cmdcpusr&#125; $&#123;username&#125; $&#123;yon&#125;" doneelse echo "No user to copy!"fi 集群 home 目录远程挂载脚本 mount.home.sh12345678910111213141516171819202122# !/bin/bashset -e# for normal nodes:nodelist="seislab3 seislab4 seislab5 seislab6 \ seislab0 garray1 garray3 garray4"for i in $&#123;nodelist&#125;do ssh $&#123;i&#125; "grep /home /proc/mounts | grep -qs seislab1 || \ mount -t nfs 192.18.1.101:/home /home"done# for NO-infiniband nodes:noiblist="seislab2 garray2"for i in $&#123;noiblist&#125;do ssh $&#123;i&#125; "grep /home /proc/mounts | grep -qs seislab1 || \ mount -t nfs xx.xx.xx.xxx:/home /home"done 集群普通目录远程挂载脚本 mount.all.sh12345678910111213141516171819#!/bin/bashset -ecmdmount=/home/data/system/scripts/mount.indv.shnodelist="seislab1 seislab2 seislab3 seislab4 seislab5 seislab6 \ seislab0 garray1 garray2 garray3 garray4"for i in $&#123;nodelist&#125;do echo "&gt;&gt; prepare to mount local on $&#123;i&#125; ..." ssh $&#123;i&#125; "$&#123;cmdmount&#125; local"donefor i in $&#123;nodelist&#125;do echo "&gt;&gt; prepare to mount remote on $&#123;i&#125; ..." ssh $&#123;i&#125; "$&#123;cmdmount&#125; remote"done]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一堆儿公式]]></title>
    <url>%2F2019%2F08%2F15%2FHandbook-of-Formulas%2F</url>
    <content type="text"><![CDATA[数学代数公式复数共轭$$ | z |^2 = z \cdot \bar{z} $$ $$ \overline{ z_1 + z_2 } = \overline{z_1} + \overline{z_2} $$ $$ \overline{ z_1 - z_2 } = \overline{z_1} - \overline{z_2} $$ $$ \overline{ z_1 \cdot z_2 } = \overline{z_1} \cdot \overline{z_2} $$ $$ \overline{\left( \frac{z_1}{z_2} \right)} = \frac{\overline{z_1}}{\overline{z_2}} $$ 三角函数欧拉公式$$e^{i\theta} = \cos \theta + i \sin \theta$$ $$\sin \theta = \frac{e^{i \theta} - e^{- i \theta}}{2i}$$ $$\cos \theta = \frac{e^{i \theta} + e^{- i \theta}}{2}$$ 诱导公式基本关系：$\sin^2 a + \cos^2 a = 1$, $\tan a = \frac{\sin a}{\cos a}$, $\cot a = \frac{\cos a}{\sin a}$, $\sec a = \frac{1}{\cos a}$, $\csc a = \frac{1}{\sin a}$. 扩展关系：$\sec^2 a - \tan^2 a = 1$, $\csc^2 a - \cot^2 a = 1$. $\sin$ $\cos$ $\tan$ $\cot$ $\sec$ $\csc$ $- a$ $- \sin a$ $\cos a$ $- \tan a$ $ - \cot a$ $\sec a$ $- \csc a$ $\frac{\pi}{2} \pm a$ $\cos a$ $\mp \sin a$ $\mp \cot a$ $\mp \tan a$ $\mp \csc a$ $\sec a$ $\pi \pm a$ $\mp \sin a$ $- \cos a$ $\pm \tan a$ $\pm \cot a$ $- \sec a$ $\mp \csc a$ $\frac{3\pi}{2} \pm a$ $- \cos a$ $\pm \sin a$ $\mp \cot a$ $\mp \tan a$ $\pm \csc a$ $- \sec a$ $2\pi \pm a$ $\pm \sin a$ $\cos a$ $\pm \tan a$ $\pm \cot a$ $\sec a$ $\pm \csc a$ 两角和差公式$$\sin(a \pm b) = \sin a \cos b \pm \cos a \sin b$$ $$\cos(a \pm b) = \cos a \cos b \mp \sin a \sin b$$ $$\tan(a \pm b) = \frac{\tan a \pm \tan b}{1 \mp \tan a \tan b}$$ $$\cot (a \pm b) = \frac{\cot a \cot b \mp 1}{\cot b \pm \cot a}$$ 半角公式$$\sin^2 \frac{a}{2} = \frac{1 - \cos a}{2}$$ $$\cos^2 \frac{a}{2} = \frac{1 + \cos a}{2}$$ $$\tan^2 \frac{a}{2} = \frac{1 - \cos a}{1 + \cos a}$$ 万能公式$$\sin a = \frac{2 \tan \frac{a}{2}}{1 + \tan^2 \frac{a}{2}}$$ $$\cos a = \frac{1 - \tan^2 \frac{a}{2}}{1 + \tan^2 \frac{a}{2}}$$ $$\tan a = \frac{2 \tan \frac{a}{2}}{1 - \tan^2 \frac{a}{2}}$$ 三倍角公式$$\sin 3a = 3 \sin a - 4 \sin^3 a$$ $$\cos 3 a = 4 \cos^3 a - 3 \cos a$$ $$\tan 3a = \frac{3 \tan a - \tan^3 a}{1 - 3 \tan^2 a} = \tan a \tan (\frac{\pi}{3} + a) \tan (\frac{\pi}{3} - a)$$ $$\cot 3a = \frac{\cot^3 a - 3 \cot a}{3 \cot^2 a - 1}$$ 降冪公式 $\sin^2 a = \frac{1}{2} (1 - \cos 2a)$ $\sin^3 a = \frac{1}{4} (3 \sin a - \sin 3a)$ $\sin^4 a = \frac{1}{8} (3 - 4 \cos 2a + \cos 4a)$ $\cos^2 a = \frac{1}{2} (1 + \cos 2a)$ $\cos^3 a = \frac{1}{4} (3 \cos a + \cos 3a)$ $\cos^4 a = \frac{1}{8} (3 + 4 \cos 2a + \cos 4a)$ 和差化积 $\sin a + \sin b = 2 \sin \frac{a + b}{2} \cos \frac{a - b}{2}$ $\sin a - \sin b = 2 \sin \frac{a - b}{2} \cos \frac{a + b}{2}$ $\sin^2 a - \sin^2 b = \sin (a + b) \sin (a - b)$ $\cos a + \cos b = 2 \cos \frac{a + b}{2} \cos \frac{a - b}{2}$ $\cos a - \cos b = - 2 \sin \frac{a + b}{2} \sin \frac{a - b}{2}$ $\cos^2 a - \cos^2 b = - \sin (a + b) \sin (a - b)$ $\tan a + \tan b = \frac{\sin (a + b)}{\cos a \cos b}$ $\tan a - \tan b = \frac{\sin (a - b)}{\cos a \cos b}$ $\cos^2 a - \sin^2 b = \cos (a + b) \cos (a - b)$ $\cot a + \cot b = \frac{\sin (a + b)}{\sin a \sin b}$ $\cot a - \cot b = - \frac{\sin (a - b)}{\sin a \sin b}$ $\sin^2 - \cos^2 b = - \cos (a + b) \cos (a - b)$ 积化和差$$\sin a \sin b = - \frac{1}{2} [ \cos (a + b) - \cos (a - b) ]$$ $$\sin a \cos b = \frac{1}{2} [ \sin (a + b) + \sin (a - b) ]$$ $$\cos a \cos b = \frac{1}{2} [ \cos (a + b) + \cos (a - b) ]$$ $$\cos a \sin b = \frac{1}{2} [ \sin (a + b) - \sin (a - b) ]$$ 微积分导数公式 $f(x)$ $f’(x)$ $f(x)$ $f’(x)$ $f(x)$ $f’(x)$ $x^n$ $n x^{n -1}$ $a^x$ $a^x \ln a$ $e^x$ $e^x$ $x^x$ $x^x (1 + \ln x)$ $\log_a x$ $\frac{1}{x \ln a}$ $\ln x$ $\frac{1}{x}$ $\sin x$ $\cos x$ $\arcsin x$ $\frac{1}{\sqrt{1 - x^2}}$ $\sinh x$ $\cosh x$ $\cos x$ $- \sin x$ $\arccos x$ $- \frac{1}{\sqrt{1 - x^2}}$ $\cosh x$ $\sinh x$ $\tan x$ $\frac{1}{\cos^2 x}$ $\arctan x$ $\frac{1}{1 + x^2}$ $\tanh x$ $\frac{1}{\cosh^2 x}$ $\cot x$ $- \frac{1}{\sin^2 x}$ $\text{arccot}~x$ $- \frac{1}{1 + x^2}$ $\coth x$ $- \frac{1}{\sinh^2 x}$ $\sec x$ $\frac{\sin x}{\cos^2 x}$ $\text{arcsec}~x$ $\frac{1}{x \sqrt{x^2 - 1}}$ $\text{sech}~x$ $- \frac{\sinh x}{\cosh^2 x}$ $\csc x$ $- \frac{\cos x}{\sin^2 x}$ $\text{arccsc}~x$ $- \frac{1}{x \sqrt{x^2 - 1}}$ $\text{csch}~x$ $- \frac{\cosh x}{\sinh^2 x}$ 积分号的微分$$ \frac{\text{d}}{\text{d}y} \int_{\phi(y)}^{\psi(y)} f(x, y) \text{d}x = f[\psi(y), y]\psi’(y) - f[\phi(y), y]\phi’(y) + \int_{\phi(y)}^{\psi(y)} f_y’(x, y) \text{d}x $$ $$ \text{特别地，}\quad \frac{\text{d}}{\text{d}y} \int_a^y f(x) \text{d}x = f(y) \quad\text{和}\quad \frac{\text{d}}{\text{d}y} \int_a^{\infty} f(x, y) \text{d}x = \int_a^{\infty} f_y’(x, y) \text{d}x $$ 幂级数展开$$\frac{1}{1 - x} = 1 + x + x^2 + \cdots + x^n + \cdots, |x| &lt; 1$$ $$\sin x = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \cdots + (- 1)^n \frac{x^{2n + 1}}{(2n + 1)!} + \cdots, |x| &lt; \infty$$ $$\cos x = 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \cdots + (- 1)^n \frac{x^{2n}}{(2n)!} + \cdots, |x| &lt; \infty$$ $$e^x = 1 + \frac{x}{1!} + \frac{x^2}{2!} + \cdots + \frac{x^n}{n!} + \cdots, |x| &lt; \infty$$ $$\ln (1 + x) = x - \frac{x^2}{3} + \frac{x^3}{3} - \cdots + (- 1)^{n + 1} \frac{x^n}{n} + \cdots, - 1 &lt; x \leq 1$$ 泰勒展开$$f(x) = f(x_0) + f’(x_0) (x - x_0) + \frac{f’’(x_0)}{2!} (x - x_0)^2 + \cdots + \frac{f^{(n)}(x_0)}{n!} (x - x_0)^n + R_n(x)$$ 积分变换傅里叶变换定义$$F(\omega) = \int_{-\infty}^{+\infty} f(t) e^{-j \omega t} dt$$ $$f(t) = \frac{1}{2\pi} \int_{-\infty}^{+\infty} F(\omega) e^{j \omega t} d\omega$$ 性质 性质 像原函数 像函数 线性 $a f_1(t) + b f_2(t)$ $a F_1(\omega) + b F_2(\omega)$ 位移 $f(t-t_0)$$e^{j \omega_0 t} f(t)$ $e^{-j \omega t_0} F(\omega)$$F(\omega - \omega_0)$ 相似 $f(a t)$ $\frac{1}{\vert a \vert} F(\frac{\omega}{a})$ 对称 $F(\pm t)$ $2\pi f(\mp \omega)$ 微分 $f^{(n)} (t)$$(-j t)^n f(t)$ $(j \omega)^n F(\omega)$$F^{(n)}(\omega)$ 积分 $\int_{-\infty}^t \int_{-\infty}^t \cdots \int_{-\infty}^t f(t) dt \cdots dt dt$ $\frac{1}{(j \omega)^n} F(\omega)$ 卷积 $(f_1 \ast f_2) (t) = \int_{-\infty}^{+\infty} f_1(\tau) f_2(t - \tau) d\tau$$f_1 (t) \cdot f_2 (t)$ $F_1(\omega) F_2(\omega)$$\frac{1}{2\pi} (F_1 \ast F_2) (\omega)$ 逆时 $f(-t)$ $\overline{F(\omega)}$ 互相关 $(f_1 \circ f_2)(t) = \int_{-\infty}^{+\infty} f_1(\tau) f_2(t + \tau) d\tau$ $F_1(\omega) \overline{F_2(\omega)}$ 能量积分$$\int_{-\infty}^{+\infty} f_1(t) f_2(t) dt = \frac{1}{2\pi} \int_{-\infty}^{+\infty} \overline{F_1 (\omega)} F_2 (\omega) d\omega$$ $$\int_{-\infty}^{+\infty} f^2 (t) dt = \frac{1}{2\pi} \int_{-\infty}^{+\infty} \vert F(\omega) \vert ^2 d\omega$$ 常见变换对 像原函数 像函数 矩形单脉冲 $f(t) = \begin{cases} E, &amp; \vert t \vert \leq \frac{\tau}{2} \newline 0, &amp; \text{other} \newline \end{cases}$ $2E \frac{\sin \frac{\omega \tau}{2}}{\omega}$ 指数衰减函数 $f(t) = \begin{cases} 0, &amp; t &lt; 0 \newline e^{-\beta t}, &amp; t \geq 0 \end{cases}, (\beta &gt; 0)$ $\frac{1}{\beta + j \omega}$ 单位函数 $f(t) = u(t)$ $\frac{1}{j \omega} + \pi \delta(\omega)$ 三角形脉冲 $f(t) = \begin{cases} \frac{2A}{\tau} (\frac{\tau}{2} + t), &amp; -\frac{\tau}{2} \leq t &lt; 0 \newline \frac{2A}{\tau} (\frac{\tau}{2} - t), &amp; 0 \leq t &lt; \frac{\tau}{2} \end{cases}$ $\frac{4A}{\tau \omega^2} (1 - \cos \frac{\omega \tau}{2})$ 钟形脉冲 $f(t) = A e^{-\beta t^2}, (\beta &gt; 0)$ $\sqrt(\frac{\pi}{\beta}) A e^{- \frac{\omega^2}{4 \beta}}$ 傅里叶核 $f(t) = \frac{\sin \omega_0 t}{\pi t}$ $F(\omega) = \begin{cases} 1, &amp; \vert \omega \vert \leq \omega_0 \newline 0, &amp; \text{other} \end{cases}$ 高斯分布函数 $f(t) = \frac{1}{\sqrt{2\pi \sigma}} e^{-\frac{t^2}{2\sigma^2}}$ $e^{- \frac{\sigma^2 \omega^2}{2}}$ 单位脉冲函数 $f(t) = \delta(t)$ $1$ 周期性脉冲函数 $f(t) = \sum_{n=-\infty}^{+\infty} \delta(t - n T)$ $\frac{2\pi}{T} \sum_{n=-\infty}^{+\infty} \delta(\omega - \frac{2n\pi}{T})$ 符号函数 $f(t) = \mathrm{sgn~} t = 2 u(t) - 1$ $\frac{2}{j \omega}$ $f(t) = \cos \omega_0 t$ $\pi [ \delta(\omega + \omega_0) + \delta(\omega - \omega_0) ]$ $f(t) = \sin \omega_0 t$ $j \pi [ \delta(\omega + \omega_0) - \delta(\omega - \omega_0) ]$ $u(t - c)$ $\frac{1}{j \omega} e^{-j \omega c} + \pi \delta(\omega)$ $u(t) \cdot t^n$ $\frac{n!}{(j \omega)^{n + 1}} + \pi j^n \delta^{(n)} (\omega)$ $u(t) \sin at$ $\frac{a}{a^2 - \omega^2} + \frac{\pi}{2 j} [ \delta(\omega - a) - \delta(\omega + a) ]$ $u(t) \cos at$ $\frac{j \omega}{a^2 - \omega^2} + \frac{\pi}{2} [ \delta(\omega - a) + \delta(\omega + a) ]$ $u(t) e^{j a t}$ $\frac{1}{j (\omega - a)} + \pi \delta(\omega - a)$ $u(t - c) e^{j a t}$ $\frac{1}{j(\omega - a)} e^{-j (\omega - a) c} + \pi \delta(\omega - a)$ $u(t) e^{j a t} t^n$ $\frac{n!}{[j (\omega - a)]^{n + 1}} + \pi j^n \delta^{(n)}(\omega - a)$ $e^{a \vert t \vert}, \Re (a) &lt; 0$ $ - \frac{2a}{\omega^2 + a^2}$ $\delta(t - c)$ $e^{-j \omega c}$ $\delta^{(n)}(t)$ $(j \omega)^n$ $\delta^{(n)}(t - c)$ $(j \omega)^n e^{- j \omega c}$ $1$ $2 \pi \delta(\omega)$ $t^n$ $2 \pi j^n \delta^{(n)} (\omega)$ $e^{j a t}$ $2 \pi \delta(\omega - a)$ $t^n e^{j a t}$ $2 \pi j^n \delta^{(n)} (\omega - a)$ $\frac{1}{a^2 + t^2}, \Re (a) &lt; 0$ $- \frac{\pi}{a} e^{a \vert \omega \vert}$ $\frac{t}{(a^2 + t^2)^2}, \Re (a) &lt; 0$ $\frac{j \omega \pi}{2a} e^{a \vert \omega \vert}$ $\frac{\sin bt}{a^2 + t^2}, \Re (a) &lt; 0, b \in \mathscr{R}$ $ - \frac{\pi}{a} e^{a \vert \omega - b \vert}$ $\frac{\cos bt}{a^2 + t^2}, \Re (a) &lt; 0, b \in \mathscr{R}$ $ - \frac{\pi}{2a} [ e^{a \vert \omega - b \vert} + e^{a \vert \omega + b \vert} ]$ $\frac{e^{j b t}}{a^2 + t^2}, \Re (a) &lt; 0, b \in \mathscr{R}$ $ - \frac{\pi}{2 a j} [ e^{a \vert \omega - b \vert} - e^{a \vert \omega + b \vert} ]$ $\frac{\sinh at}{\sinh \pi t}, - \pi &lt; a &lt; \pi$ $\frac{\sin a}{\cosh \omega + \cos a}$ $\frac{\sinh at}{\cosh \pi t}, - \pi &lt; a &lt; \pi$ $-2j \frac{\sin \frac{a}{2} \sinh \frac{\omega}{2}}{\cosh \omega + \cos a}$ $\frac{\cosh at}{\cosh \pi t}, - \pi &lt; a &lt; \pi$ $2 \frac{\cos \frac{a}{2} \cosh \frac{\omega}{2}}{\cosh \omega + \cos a}$ $\frac{1}{\cosh at}$ $\frac{\pi}{a} \frac{1}{\cosh \frac{\pi \omega}{2a}}$ $\sin at^2$ $\sqrt{\frac{\pi}{a}} \cos \Big( \frac{\omega^2}{4a} + \frac{\pi}{4} \Big)$ $\cos at^2$ $\sqrt{\frac{\pi}{a}} \cos \Big( \frac{\omega^2}{4a} - \frac{\pi}{4} \Big)$ $\frac{1}{t} \sin at$ $\begin{cases} \pi, &amp; \vert \omega \vert \leq a \newline 0, &amp; \vert \omega \vert &gt; a \end{cases}$ $\frac{1}{t^2} \sin^2 at$ $\begin{cases} \pi \Big( a - \frac{\vert \omega \vert}{2} \Big), &amp; \vert \omega \vert \leq 2a \newline 0, &amp; \vert \omega \vert &gt; 2a \end{cases}$ $\frac{\sin at}{\sqrt{\vert t \vert}}$ $j \sqrt{\frac{\pi}{2}} \Big( \frac{1}{\sqrt{\vert \omega + a \vert}} - \frac{1}{\sqrt{\vert \omega - a \vert}} \Big)$ $\frac{\cos at}{\sqrt{\vert t \vert}}$ $\sqrt{\frac{\pi}{2}} \Big( \frac{1}{\sqrt{\vert \omega + a \vert}} + \frac{1}{\sqrt{\vert \omega - a \vert}} \Big)$ $\frac{1}{\sqrt{\vert t \vert}}$ $\sqrt{\frac{2\pi}{\vert \omega \vert}}$ $e^{- at^2}, \Re(a) &gt; 0$ $\sqrt{\frac{\pi}{a}} e^{- \frac{\omega^2}{4a}}$ $\vert t \vert$ $- \frac{2}{\omega^2}$ $\frac{1}{\vert t \vert}$ $\frac{\sqrt{2\pi}}{\vert \omega \vert}$ 坐标系单位矢量柱坐标系对于柱坐标系 $(\rho, \varphi, z)$，有 $$\begin{cases} x = \rho \cos \varphi \newline y = \rho \sin \varphi \newline z = z\end{cases} \qquad (0 \leqslant \rho &lt; \infty, 0 \leqslant \varphi &lt; 2 \pi, - \infty &lt; z &lt; \infty)$$ 单位矢量为 $$\begin{cases} \vec{e}_{\rho} = \cos \varphi \vec{i} + \sin \varphi \vec{j} \newline \vec{e}_{\varphi} = - \sin \varphi \vec{i} + \cos \varphi \vec{j} \newline \vec{e}_z = \vec{k} \newline\end{cases}$$ 其偏导数为 $$\frac{\partial \vec{e}_{\rho}}{\partial \rho} = \frac{\partial \vec{e}_{\varphi}}{\partial \rho} = \frac{\partial \vec{e}_z}{\partial \rho} = 0$$ $$\frac{\partial \vec{e}_{\rho}}{\partial \varphi} = \vec{e}_{\varphi}, \frac{\partial \vec{e}_{\varphi}}{\partial \varphi} = - \vec{e}_{\rho}, \frac{\vec{e}_z}{\partial \varphi} = 0$$ $$\frac{\partial \vec{e}_{\rho}}{\partial z} = \frac{\partial \vec{e}_{\varphi}}{\partial z} = \frac{\partial \vec{e}_z}{\partial z} = 0$$ 球坐标系对于球坐标系 $(r, \theta, \varphi)$，有 $$\begin{cases} x = r \sin \theta \cos \varphi \newline y = r \sin \theta \sin \varphi \newline z = r \cos \theta \newline\end{cases} \qquad (0 \leqslant r &lt; \infty, 0 \leqslant \varphi &lt; 2 \pi, 0 \leqslant \theta \leqslant \pi)$$ 单位矢量为 $$\begin{cases} \vec{e}_r = \sin \theta \cos \varphi \vec{i} + \sin \theta \sin \varphi \vec{j} + \cos \theta \vec{k} \newline \vec{e}_{\theta} = \cos \theta \cos \varphi \vec{i} + \cos \theta \sin \varphi \vec{j} - \sin \theta vec{k} \newline \vec{e}_{\varphi} = - \sin \varphi \vec{i} + \cos \varphi \vec{j} \newline\end{cases}$$ 其偏导数为 $$\frac{\partial \vec{e}_r}{\partial r} = \frac{\partial \vec{e}_{\theta}}{\partial r} = \frac{\partial \vec{e}_{\varphi}}{\partial r} = 0$$ $$\frac{\partial \vec{e}_r}{\partial \theta} = \vec{e}_{\theta}, \frac{\partial \vec{e}_{\theta}}{\partial \theta} = - \vec{e}_r, \frac{\partial \vec{e}_{\varphi}}{\partial \theta} = 0$$ $$\frac{\partial \vec{e}_r}{\partial \varphi} = \sin \theta \vec{e}_{\varphi}, \frac{\partial \vec{e}_{\theta}}{\partial \varphi} = \cos \theta \vec{e}_{\varphi}, \frac{\partial \vec{e}_{\varphi}}{\partial \varphi} = - \sin \theta \vec{e}_r - \cos \theta \vec{e}_{\theta}$$ 坐标系转换矢量在直角坐标系 $(v_x, v_y, v_z)$ 和任意坐标系 $(v_{\xi}, v_{\eta}, v_{\zeta})$ 中可以分别表达为 $$\vec{v} = v_x \vec{i} + v_y \vec{j} + v_z \vec{k} = v_{\xi} \vec{e}_{\xi} + v_{\eta} \vec{e}_{\eta} + v_{\zeta} \vec{e}_{\zeta}$$ 柱坐标系与直角坐标系由柱坐标系 $(v_{\rho}, v_{\varphi}, v_z)$ 到直角坐标系 $(v_x, v_y, v_z)$ ： $$\begin{cases} v_x = v_{\rho} \cos \varphi - v_{\varphi} \sin \varphi \newline v_y = v_{\rho} \sin \varphi + v_{\varphi} \cos \varphi \newline v_z = v_z \newline\end{cases}$$ 由直角坐标系 $(v_x, v_y, v_z)$ 到柱坐标系 $(v_{\rho}, v_{\varphi}, v_z)$ ： $$\begin{cases} v_{\rho} = v_x \cos \varphi +v_y \sin \varphi \newline v_{\varphi} = - v_x \sin \varphi + v_y \cos \varphi \newline v_z = v_z \newline\end{cases}$$ 球坐标系与直角坐标系由球坐标系 $(v_r, v_{\theta}, v_{\varphi})$ 到直角坐标系 $(v_x, v_y, v_z)$ ： $$\begin{cases} v_x = v_r \sin \theta \cos \varphi + v_{\theta} \cos \theta \cos \varphi - v_{\varphi} \sin \varphi \newline v_y = v_r \sin \theta \sin \varphi + v_{\theta} \cos \theta \sin \varphi + v_{\varphi} \cos \varphi \newline v_z = v_r \cos \theta - v_{\theta} \sin \theta \newline\end{cases}$$ 由直角坐标系 $(v_x, v_y, v_z)$ 到球坐标系 $(v_r, v_{\theta}, v_{\varphi})$ ： $$\begin{cases} v_r = v_x \sin \theta \cos \varphi + v_y \sin \theta \sin \varphi + v_z \cos \theta \newline v_{\theta} = v_x \cos \theta \cos \varphi + v_y \cos \theta \sin \varphi - v_z \sin \theta \newline v_{\varphi} = - v_x \sin \varphi + v_y \cos \varphi \newline\end{cases}$$ 各种算子取 $U$ 为一个标函数，$\mathbf{V}$ 为一个矢函数。 柱坐标系中的算子哈密顿算子：$\widetilde{\nabla} = \vec{e}_{\rho} \frac{\partial}{\partial \rho} + \vec{e}_{\varphi} \frac{1}{\rho} \frac{\partial}{\partial \varphi} + \vec{e}_z \frac{\partial}{\partial z}$ 梯度：$\text{grad } U = \widetilde{\nabla} U = \vec{e}_{\rho} \frac{\partial U}{\partial \rho} + \vec{e}_{\varphi} \frac{1}{\rho} \frac{\partial U}{\partial \varphi} + \vec{e}_z \frac{\partial U}{\partial z}$ 散度：$\text{div } \mathbf{V} = \widetilde{\nabla} \cdot \mathbf{V} = \frac{1}{\rho} \frac{\partial (\rho v_{\rho})}{\partial \rho} + \frac{1}{\rho} \frac{\partial v_{\varphi}}{\partial \varphi} + \frac{\partial v_z}{\partial z}$ 旋度：$\text{rot } \mathbf{V} = \widetilde{\nabla} \times \mathbf{V} = \left( \frac{1}{\rho} \frac{\partial v_z}{\partial \varphi} - \frac{\partial v_{\varphi}}{\partial z} \right) \vec{e}_{\rho} + \left( \frac{\partial v_{\rho}}{\partial z} - \frac{\partial v_z}{\partial \rho} \right) \vec{e}_{\varphi} + \left( \frac{1}{\rho} \frac{\partial (\rho v_{\varphi})}{\partial \rho} - \frac{1}{\rho} \frac{\partial v_{\rho}}{\partial \varphi} \right) \vec{e}_z$ 拉普拉斯算子：$\Delta U = \text{div } \text{grad } U = \frac{1}{\rho} \frac{\partial}{\partial \rho} \left( \rho \frac{\partial U}{\partial \rho} \right) + \frac{1}{\rho^2} \frac{\partial^2 U}{\partial \varphi^2} + \frac{\partial^2 U}{\partial z^2}$ 球坐标系中算子哈密顿算子：$\widetilde{\widetilde{\nabla}} = \vec{e}_r \frac{\partial}{\partial r} + \vec{e}_{\theta} \frac{1}{r} \frac{\partial}{\partial \theta} + \vec{e}_{\varphi} \frac{1}{r \sin \theta} \frac{\partial}{\partial \varphi}$ 梯度：$\text{grad } U = \widetilde{\widetilde{\nabla}} U = \vec{e}_r \frac{\partial U}{\partial r} + \vec{e}_{\theta} \frac{1}{r} \frac{\partial U}{\partial \theta} + \vec{e}_{\varphi} \frac{1}{r \sin \theta} \frac{\partial U}{\partial \varphi}$ 散度：$\text{div } U = \widetilde{\widetilde{\nabla}} \cdot \mathbf{V} = \frac{1}{r^2} \left[ \frac{\partial}{\partial r} (r^2 v_r) \right] + \frac{1}{r \sin \theta} \left[ \frac{\partial}{\partial \theta} (\sin \theta v_{\theta}) \right] + \frac{1}{r \sin \theta} \frac{\partial v_{\varphi}}{\partial \varphi}$ 旋度：$\text{rot } \mathbf{V} = \widetilde{\widetilde{\nabla}} \times \mathbf{V} = \left[ \frac{1}{r \sin \theta} \left( \frac{\partial}{\partial \theta} (\sin \theta v_{\varphi}) - \frac{\partial v_{\theta}}{\partial \varphi} \right) \right] \vec{e}_r + \left[ \frac{1}{r \sin \theta} \frac{\partial v_r}{\partial \varphi} - \frac{1}{r} \frac{\partial}{\partial r} (r v_{\varphi}) \right] \vec{e}_{\theta} + \left[ \frac{1}{r} \frac{\partial}{\partial r} (r v_{\theta}) - \frac{1}{r} \frac{\partial v_r}{\partial \theta} \right] \vec{e}_{\varphi}$ 拉普拉斯算子：$\Delta U = \text{div } \text{grad } U = \frac{1}{r^2} \left[ \frac{\partial}{\partial r} \left( r^2 \frac{\partial U}{\partial r} \right) \right] + \frac{1}{r \sin \theta} \left[ \frac{\partial}{\partial \theta} \left( \sin \theta \frac{1}{r} \frac{\partial U}{\partial \theta} \right) \right] + \frac{1}{r^2 \sin^2 \theta} \frac{\partial^2 U}{\partial \varphi^2}$ 物理地震学弹性参数转换纵波波速 $\alpha$ 和横波波速 $\beta$： $$\alpha = \sqrt{ \frac{ \lambda + 2\mu }{ \rho} }$$ $$\beta = \sqrt{ \frac{\mu}{\rho} }$$ 泊松比 $\nu$： $$\nu = \frac{\lambda}{ 2(\mu + \lambda) }$$ 弹性常数 $c_{jklm}$，体积模量 $\kappa$ 和弹性模量 $E$： $$c_{jklm} = \Big(\kappa - \frac{2\mu}{3}\Big) \delta_{jk}\delta_{lm} + \mu (\delta_{jl}\delta_{km} + \delta_{jm}\delta_{kl})$$ $$\kappa = \lambda + \frac{2}{3} \mu$$ $$E = \frac{\mu (3\lambda + 2\mu)}{\lambda + \mu}$$ 其中，$\rho$ 为密度，$\lambda$ 和 $\mu$ 为拉梅参数。 波动方程声波在各向同性介质中，声波波动方程有以下几种形式： 二阶标量方程：$$ \nabla^2 p - \frac{1}{c^2} \frac{\partial^2 p}{\partial t^2} = f \quad \text{或} \quad \rho \frac{\partial^2 p}{\partial t^2} - \nabla \cdot \left( c^2 \nabla p \right) = f $$ 一阶压力-速度方程组：$$ \begin{cases} p_{, t} = - \rho c^2 v_{i, i} \newline v_{i, t} = - \frac{1}{\rho} p_{, i} + f_i \newline \end{cases} $$ 其中，$p$ 为压力场，$v$ 为速度场，$f$ 为力源项，$\rho$ 为介质密度，$c$ 为介质的声波波速。 弹性波在各向同性介质中，弹性波波动方程有以下几种形式： 二阶位移方程组：$$ \rho u_{i,tt} = (\lambda u_{k,k})_{,i} + (\mu u_{i,j})_{,j} + (\mu u_{j,i})_{,j} + f_i $$ 位移-应力方程组：$$ \begin{cases} \rho u_{i,tt} = \sigma_{ij,j} + f_i \newline \sigma_{ij} = \lambda u_{k,k} \delta_{ij} + \mu (u_{i,j} + u_{j,i}) \end{cases} $$ 一阶速度-应力方程组：$$ \begin{cases} \rho v_{i,t} = \sigma_{ij,j} + f_i \newline \sigma_{ij,t} = \lambda v_{k,k} \delta_{ij} + \mu (v_{i,j} + v_{j,i}) \end{cases} $$ 其中，$u$ 为位移场，$v$ 为速度场，$\sigma$ 为应力场，$f$ 为力源项，$\rho$ 为介质密度，$\lambda$ 和 $\mu$ 为介质的拉梅参数。 波的传播波数 $k$ 和波速 $c$： $$ k = \frac{f}{c} \qquad \text{或} \qquad k = \frac{\omega}{c} $$ 其中，$f$ 为线频率，$\omega$ 为角频率。]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Basic formula</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造一个简单的滤波器]]></title>
    <url>%2F2019%2F06%2F24%2FCreate-a-Filter%2F</url>
    <content type="text"><![CDATA[一个简单的低通滤波器本文译自 How to Create a Simple Low-Pass Filter。 低通意即仅允许低频通过，阻滞高频。sinc 滤波器就是一个理想的低通滤波器。信号处理中常用的、正则化的 sinc 函数定义为： $$\text{sinc} (x)=\frac{\sin(\pi x)}{\pi x}$$ 由于 sinc 函数的傅里叶变换的结果即是关于 $y$ 轴对称的矩形函数（rectangular function），在 $x$ 轴正半部分即为一个理想的低通滤波时窗，当与输入信号褶积时，sinc 滤波器即可得到一个仅包含所有截止频率以下成分的输出信号。 sinc 滤波器为设计一个数字滤波器，需要先将连续的 sinc 函数归一化，再逐点采样生成一个序列。定义 sinc 滤波器的脉冲响应： $$h[n] = 2f_c \text{sinc} (2 f_c n)$$ 这里的 $f_c$ 是经采样频率分数特征化后的截止频率。例如，采样频率为 1000 Hz ，取 $f_c = 0.01 = 10/1000$ 时即将去除信号中高于 10 Hz 的频率成分。 然而，由于 sinc 函数是无限长的，在设计滤波器时，需要将其在某处截断，这就会在滤波结果中引起持续的振荡。这时，最容易想到的解决方法就是，在 sinc 滤波器上叠加一个时窗，使滤波器在时窗边界处趋近于 $x$ 轴。 时窗窗函数即一个在某一区间外值全为 0 的函数。作为其中比较常用的一种，Blackman 窗的定义为： $$w[n] = 0.42 - 0.5 \cos\Big(\frac{2 \pi n}{N - 1}\Big) + 0.08 \cos\Big(\frac{4 \pi n}{N - 1}\Big)$$ 其中 $n\in [0, N - 1]$。 时窗 sinc 滤波器根据上面给出的定义，可以得到时窗 sinc 滤波器在区间 $[0, N - 1]$ 内的表达式为： $$h[n] = \text{sinc} \Big(2 f_c \big(n - \frac{N - 1}{2}\big)\Big) \Big(0.42 - 0.5 \cos\big(\frac{2 \pi n}{N - 1}\big) + 0.08 \cos\big(\frac{4 \pi n}{N - 1}\big) \Big)$$ 对于 $n \notin [0, N - 1]$，$h[n] = 0$。这里省略了 sinc 滤波器的系数 $2 f_c$，因为还需要进行正则化，以得到单位滤波增益： $$h_{\text{normalized}} [n] = \frac{h[n]}{\sum_{i=0}^{N - 1} h[i]}$$ 过渡带宽采样频率分数特征化的过渡带宽 $b$ 和滤波器长度 $N$ 之间有一个近似关系： $$b \approx \frac{4}{N}$$ 根据此式，在设定过渡带宽后，即可求出合适的滤波器长度。此外，一般取 N 为奇数，以确保滤波器峰值的两侧有相同的采样点数。例如，采样频率为 1000 Hz，欲得到 1 Hz 的过渡带宽，即 $b = 1/1000 = 0.001$，取 $N = 4001$ 即可。 Python 代码如下即是上述低通滤波器的示例生成代码： 1234567891011121314151617181920import numpy as np fc = 0.1 # Cutoff frequency, as a fraction of the sampling rate (in (0, 0.5)).b = 0.08 # Transition band, as a fraction of the sampling rate (in (0, 0.5)).N = int(np.ceil((4 / b)))if not N % 2: N += 1 # Make sure that N is odd.n = np.arange(N) # Compute sinc filter.h = np.sinc(2 * fc * (n - (N - 1) / 2)) # Compute Blackman window.w = 0.42 - 0.5 * np.cos(2 * np.pi * n / (N - 1)) + \ 0.08 * np.cos(4 * np.pi * n / (N - 1)) # Multiply sinc filter by window.h = h * w # Normalize to get unity gain.h = h / np.sum(h) 通过将滤波器 $h$ 与信号 $s$ 褶积，即可得到低通滤波的结果：s = np.convolve(s, h)。 在实际信息处理过程中，褶积会导致输出信号与输入信号长度不一致，此时只需将输出信号向后时延 $(N - 1)/2​$ 个数据点后，再截取与输入信号等长的信号段即可。 另外，Blackman 窗也可通过语句 w = np.balckman(N) 直接生成。 一个简单的高通滤波器 本文译自 How to Create a Simple High-Pass Filter。 前面已经介绍了低通滤波器的构造，通过频谱反转（Spectral inversion）即可将一个低通滤波器转化为一个高通滤波器。 从低通到高通低通滤波会去除信号中的高频成分，如果我们从信号中减去低通滤波信号，剩下的便只是信号中的高频成分。据此，我们可以构造一个简单的高通滤波器。 首先，对信号作低通滤波： $$x_{\text{lpf}}[n] = x[n] * h_{\text{lpf}}[n]​$$ 其中，$x[n]$ 为原始信号，$h_{\text{lpf}}[n]$ 为低通滤波器，$x_{\text{lpf}}[n]$ 即低通滤波信号，$*$ 表示褶积。接着，从原始信号中减去低通滤波信号： $$x_{\text{hpf}}[n] = x[n] - x_{\text{lpf}}[n]$$ 得到的 $x_{\text{hpf}}[n]​$ 即为高通滤波信号。 从上述各式中，我们可以得到： $$x_{\text{hpf}}[n] = x[n] - x_{\text{lpf}}[n] = x[n] * \delta[n] - x[n] * h_{\text{lpf}}[n] = x[n] * (\delta[n] - h_{\text{lpf}}[n])$$ 因此，高通滤波器可以定义为： $$h_{\text{hpf}}[n] = \delta[n] - h_{\text{lpf}}[n]$$ 频谱反转上述即为频谱反转的理论原理，其具体做法为： 构造一个简单的低通滤波器 $h[n]$； 改变低通滤波器中所有元素的符号； 给滤波器中心的元素加上 1。 Python 代码如下即是上述高通滤波器的示例生成代码： 1234567891011121314151617import numpy as np fc = 0.1 # Cutoff frequency, as a fraction of the sampling rate (in (0, 0.5)).b = 0.08 # Transition band, as a fraction of the sampling rate (in (0, 0.5)).N = int(np.ceil((4 / b)))if not N % 2: N += 1 # Make sure that N is odd.n = np.arange(N) # Compute a low-pass filter.h = np.sinc(2 * fc * (n - (N - 1) / 2))w = np.blackman(N)h = h * wh = h / np.sum(h) # Create a high-pass filter from the low-pass filter through spectral inversion.h = -hh[(N - 1) // 2] += 1 一个简单的带通滤波器本文译自 How to Create Simple Band-Pass and Band-Reject Filters。 前面已经介绍了低通和高通滤波器的构造，通过简单组合即可利用一个低通滤波器和一个高通滤波器构造出一个带通滤波器。 带通滤波带通滤波即保留下截止频率 $f_L$ 和上截止频率 $f_H$ 之间的频率成分，阻滞区间外的所有频率。为此，我们首先以 $f_H$ 为截止频率对原始信号进行低通滤波： $$x_{\text{lpf,H}}[n] = x[n] * h_{\text{lpf,H}}[n]$$ 其中，$x[n]$ 为原始信号， $h_{\text{lpf,H}}[n]$ 为以 $f_H$ 为截止频率的低通滤波器，$x_{\text{lpf,H}}[n]$ 为低通滤波信号，$*$ 表示褶积。再以 $f_L$ 为截止频率对低通滤波信号进行高通滤波： $$x_{\text{bpf,LH}}[n] = x_{\text{lpf,H}}[n] * h_{\text{hpf,L}}[n]$$ 其中，$h_{\text{hpf,L}}[n]$ 为以 $f_L$ 为截止频率的高通滤波器，$x_{\text{bpf,LH}}[n]$ 即为最终的带通滤波信号。 根据褶积的结合律，由： $$x_{\text{bpf,LH}}[n] = (x[n] * h_{\text{lpf,H}}[n]) * h_{\text{hpf,L}}[n] = x[n] * (h_{\text{lpf,H}}[n] * h_{\text{hpf,L}}[n])$$ 定义带通滤波器为： $$h_{\text{bpf,LH}}[n] = h_{\text{lpf,H}}[n] * h_{\text{hpf,L}}[n]$$ Python 代码如下即是上述带通滤波器的示例生成代码： 1234567891011121314151617181920212223import numpy as np fL = 0.1 # Cutoff frequency, as a fraction of the sampling rate (in (0, 0.5)).fH = 0.4 # Cutoff frequency, as a fraction of the sampling rate (in (0, 0.5)).b = 0.08 # Transition band, as a fraction of the sampling rate (in (0, 0.5)).N = int(np.ceil((4 / b)))if not N % 2: N += 1 # Make sure that N is odd.n = np.arange(N) # Compute a low-pass filter with cutoff frequency fH.hlpf = np.sinc(2 * fH * (n - (N - 1) / 2))hlpf *= np.blackman(N)hlpf = hlpf / np.sum(hlpf) # Compute a high-pass filter with cutoff frequency fL.hhpf = np.sinc(2 * fL * (n - (N - 1) / 2))hhpf *= np.blackman(N)hhpf = hhpf / np.sum(hhpf)hhpf = -hhpfhhpf[(N - 1) // 2] += 1 # Convolve both filters.h = np.convolve(hlpf, hhpf) 一个简单的带阻滤波器本文译自 How to Create Simple Band-Pass and Band-Reject Filters。 前面已经介绍了低通和高通滤波器的构造，通过简单组合即可利用一个低通滤波器和一个高通滤波器构造出一个带通滤波器。 带阻滤波带阻滤波即保留下截止频率 $f_L$ 和上截止频率 $f_H$ 之外的频率成分，阻滞区间内的所有频率。为此，我们首先以 $f_L$ 为截止频率对原始信号进行低通滤波： $$x_{\text{lpf,L}}[n] = x[n] * h_{\text{lpf,L}}[n]$$ 其中，$x[n]$ 为原始信号，$h_{\text{lpf,L}}[n]$ 为以 $f_L$ 为截止频率的低通滤波器，$x_{\text{lpf,L}}[n]$ 为低通滤波信号，$*$ 表示褶积。再以 $f_H$ 为截止频率对原始信号进行高通滤波： $$x_{\text{hpf,H}}[n] = x[n] * h_{\text{hpf,H}}[n]$$ 其中，$h_{\text{hpf,H}}[n]$ 为以 $f_H$ 为截止频率的高通滤波器，$x_{\text{hpf,H}}[n]$ 为带通滤波信号。将低通滤波信号与高通滤波信号叠加： $$x_{\text{brf,LH}}[n] = x_{\text{lpf,L}}[n] + x_{\text{hpf,H}}[n]$$ 这里 $x_{\text{brf,LH}}[n]$ 即为最终的带阻滤波信号。 根据褶积的分配律，由： $$x_{\text{brf,LH}}[n] = x[n] * h_{\text{lpf,L}}[n] + x[n] * h_{\text{hpf,H}}[n] = x[n] * (h_{\text{lpf,L}}[n] + h_{\text{hpf,H}}[n])$$ 定义带阻滤波器： $$h_{\text{brf,LH}}[n] = h_{\text{lpf,L}}[n] + h_{\text{hpf,H}}[n]$$ Python 代码如下即是上述带阻滤波器的示例生成代码： 1234567891011121314151617181920212223import numpy as np fL = 0.1 # Cutoff frequency, as a fraction of the sampling rate (in (0, 0.5)).fH = 0.4 # Cutoff frequency, as a fraction of the sampling rate (in (0, 0.5)).b = 0.08 # Transition band, as a fraction of the sampling rate (in (0, 0.5)).N = int(np.ceil((4 / b)))if not N % 2: N += 1 # Make sure that N is odd.n = np.arange(N) # Compute a low-pass filter with cutoff frequency fL.hlpf = np.sinc(2 * fL * (n - (N - 1) / 2))hlpf *= np.blackman(N)hlpf /= np.sum(hlpf) # Compute a high-pass filter with cutoff frequency fH.hhpf = np.sinc(2 * fH * (n - (N - 1) / 2))hhpf *= np.blackman(N)hhpf /= np.sum(hhpf)hhpf = -hhpfhhpf[(N - 1) // 2] += 1 # Add both filters.h = hlpf + hhpf 一个简单的应用示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#!/usr/bin/env python3import numpy as np def lowFIR(fc = 0.1, b = 0.08): #fc: Cutoff frequency, as a fraction of the sampling rate (in (0, 0.5)). #b: Transition band, as a fraction of the sampling rate (in (0, 0.5)). N = int(np.ceil((4 / b))) if not N % 2: N += 1 # Make sure that N is odd. n = np.arange(N) # Compute sinc filter. h = np.sinc(2 * fc * (n - (N - 1) / 2)) # Compute Blackman window. w = 0.42 - 0.5 * np.cos(2 * np.pi * n / (N - 1)) + \ 0.08 * np.cos(4 * np.pi * n / (N - 1)) # Multiply sinc filter by window. h = h * w # Normalize to get unity gain. h = h / np.sum(h) return N, h#-------------------------------------------------------------------------------def highFIR(fc = 0.1, b = 0.08): #fc: Cutoff frequency, as a fraction of the sampling rate (in (0, 0.5)). #b: Transition band, as a fraction of the sampling rate (in (0, 0.5)). N = int(np.ceil((4 / b))) if not N % 2: N += 1 # Make sure that N is odd. n = np.arange(N) # Compute sinc filter. h = np.sinc(2 * fc * (n - (N - 1) / 2)) # Compute Blackman window. w = 0.42 - 0.5 * np.cos(2 * np.pi * n / (N - 1)) + \ 0.08 * np.cos(4 * np.pi * n / (N - 1)) # Multiply sinc filter by window. h = h * w # Normalize to get unity gain. h = h / np.sum(h) # Create a high-pass filter from the low-pass filter through spectral inversion. h *= - 1 h[(N - 1) // 2] += 1 return N, h#-------------------------------------------------------------------------------def passFIR(fL = 0.1, fH = 0.4, b = 0.08): N = int(np.ceil(4 / b)) if not N % 2: N += 1 n = np.arange(N) hlpf = np.sinc(2 * fH * (n - (N - 1) / 2)) hlpf *= np.blackman(N) hlpf /= np.sum(hlpf) hhpf = np.sinc(2 * fL * (n - (N - 1) / 2)) hhpf *= np.blackman(N) hhpf /= np.sum(hhpf) hhpf *= - 1 hhpf[(N - 1) // 2] += 1 h = np.convolve(hlpf, hhpf) return 2*N - 1, h#-------------------------------------------------------------------------------def stopFIR(fL = 0.1, fH = 0.4, b = 0.08): N = int(np.ceil(4 / b)) if not N % 2: N += 1 n = np.arange(N) hlpf = np.sinc(2 * fL * (n - (N - 1) / 2)) hlpf *= np.blackman(N) hlpf /= np.sum(hlpf) hhpf = np.sinc(2 * fH * (n - (N - 1) / 2)) hhpf *= np.blackman(N) hhpf /= np.sum(hhpf) hhpf *= - 1 hhpf[(N - 1) // 2] += 1 h = hlpf + hhpf return N, h#-------------------------------------------------------------------------------import matplotlib.pyplot as pltfs = 1000 # sampling frequency# generate properly the time vectort = np.arange(1000)/fssga = np.sin(2*np.pi*2*t) # signal with f = 2sgb = np.sin(2*np.pi*6*t) # signal with f = 6sgc = np.sin(2*np.pi*10*t) # signal with f = 10sgd = sga + sgcsge = sga + sgb + sgcif 1: plt.plot(t, sga, label = 'f = 2') plt.plot(t, sgc, label = 'f = 10') plt.plot(t, sgd, label = 'f = 2 + 10') N, h = lowFIR(fc = 5/fs, b = 2/fs) sgf = np.convolve(sgd, h) plt.plot(t, sgf[int(N/2):1000 + int(N/2)], label = 'low-pass') N, h = highFIR(fc = 5/fs, b = 2/fs) sgf = np.convolve(sgd, h) plt.plot(t, sgf[int(N/2):1000 + int(N/2)], label = 'high-pass')else: plt.plot(t, sgb, label = 'f = 6') plt.plot(t, sgd, label = 'f = 2 + 10') plt.plot(t, sge, label = 'f = 2 + 6 + 10') N, h = passFIR(fL = 4/fs, fH = 8/fs, b = 1/fs) sgf = np.convolve(sge, h) plt.plot(t, sgf[int(N/2):1000 + int(N/2)], label = 'band-pass') N, h = stopFIR(fL = 4/fs, fH = 8/fs, b = 1/fs) sgf = np.convolve(sge, h) plt.plot(t, sgf[int(N/2):1000 + int(N/2)], label = 'band-stop')plt.legend()plt.show()]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Singal Process</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地空系并行集群管理]]></title>
    <url>%2F2019%2F04%2F05%2FESS-Cluster%2F</url>
    <content type="text"><![CDATA[创建或删除用户先以命令 [root@mn01 ~]$ adduser username 创建新用户 username 生成相应的用户信息，或以命令 [root@mn01 ~]$ userdel -rf username 删除原用户 username 并删除该用户的用户信息，再以命令 [root@mn01 ~]$ make -C /var/yp 将管理节点（mn01）的用户信息发送到所有计算节点。 修改用户密码先以命令 [root@mn01 ~]$ passwd username 修改管理节点的用户密码，再以命令 [root@mn01 ~]$ make -C /var/yp 将新的用户信息发送到所有计算节点。 修改用户公共数据访问权限以中国地震台网中心地震数据（/share/data/CENC 目录）为例，该数据所属用户组为 cenc，该数据目录访问权限为 rwxr-xr-x，目录下数据文件的访问权限为 rw-r—– 。 先以命令 [root@mn01 ~]$ usermod -G cenc username 为用户添加附加用户组 cenc，再以命令 [root@mn01 ~]$ make -C /var/yp 将修改后的用户信息发送到所有计算节点。至此，用户即可在任一节点读取该数据目录下的所有数据文件。 集群系统关机 [root@mn01 ~]$ psh compute poweroff 关闭所有计算节点； [root@mn01 ~]$ mmshutdown -N io01,io02,mn01 关闭 io 节点和管理节点的 GPFS 服务； [root@mn01 ~]$ psh io poweroff 关闭 io 节点； [root@mn01 ~]$ poweroff 关闭管理节点。 重新启动集群启动顺序启动时，先启动管理节点（mn01），再启动 io 节点（io*），最后启动计算节点（c0* 和 s0*）。为保险起见，不同类型节点启动适当间隔一段时间，以等待相应的依赖服务启动完成。 重启检查先以命令 [user@mn01 ~]$ lnodes 查看各计算节点连接情况，保证无异常状态（unavail 或 unreach）节点。 若上述命令长时间无响应，说明 LSF 作业系统未完成启动，尝试以如下命令完成启动： [root@mn01 ~]$ mmstartup -a 确保 GPFS 服务已经启动； [root@mn01 ~]$ source /share/lsf/lsf/conf/profile.lsf 导入 LSF 系统配置； [root@mn01 ~]$ systemctl restart lsfd 启动管理节点的 LSF 服务； [root@mn01 ~]$ psh compute &quot;systemctl restart lsfd&quot; 启动计算节点的 LSF 服务。 待所有节点连接正常后，再以 test 身份登录至管理节点，以命令 [test@mn01 ~]$ /share/apps/matlab/etc/lmstart 启动 matlab 的 License 管理器，激活该软件的正版授权。 排查错误集群启动完成后，登录管理节点，若出现告错 12-bash: /opt/ibm/lsfsuite/lsf/conf/profile.lsf: No such file or directory-bash: /opt/ibm/lsfsuite/ext/ppm/conf/profile.js: No such file or directory 则说明 GPFS 服务没有启动，以命令 [root@mn01 ~]$ mmstartup -a 启动该服务即可。 集群启动完成后，若以命令 [user@mn01 ~]$ lnodes 查看节点连接情况，发现部分节点为 unavil 状态，则先以命令 [root@mn01 ~]$ mmstartup -N nodename 启动该节点的 GPFS 服务后，再以命令 [root@mn01 ~]$ psh nodename &quot;systemctl restart lsfd&quot; 启动该节点的 LSF 服务即可。或者以 root 身份登录至相应节点，分别以命令 [root@A ~]$ mmstartup 和 [root@A ~]$ systemctl restart lsfd 重启这两个系统服务也可。 LSF 队列管理队列状态通过命令 [user@mn01 ~]$ bqueues 可查看各个队列的当前状态。队列状态描述的是队列接收和派发作业的能力，有如下组合： 状态 描述 Open: Active 接收并派发作业，正常处理中 Open: Inactive 只接收但不派发作业，正在收集作业 Closed: Active 只派发但不接收作业，正在排空队列 Closed: Inactive 既不接收也不派发作业，停止所有活动 队列控制LSF 管理员或 root 用户可以通过以下命令来控制队列 queuename： 以命令 [root@mn01 ~]$ badmin qopen queuename 开启队列，该队列开始接收新的作业； 以命令 [root@mn01 ~]$ badmin qclose queuename 关闭队列，该队列不再接收新的作业； 以命令 [root@mn01 ~]$ badmin qact queuename 激活队列，该队列开始派发作业； 以命令 [root@mn01 ~]$ badmin qinact queuename 阻塞队列，该队列停止派发作业。 LSF 作业系统的配置LSF 作业系统的主要配置文件位于 /share/lsf/lsf/conf 目录下，该目录已软链接到 LSF 的安装目录下，修改配置并重新启动相应的 LSF 服务后，新的配置参数即可生效。具体地， 用户群组配置文件为 /share/lsf/lsf/conf/lsbatch/sustc_ess/configdir/lsb.users； 主机群组配置文件为 /share/lsf/lsf/conf/lsbatch/sustc_ess/configdir/lsb.hosts； 调度参数配置文件为 /share/lsf/lsf/conf/lsbatch/sustc_ess/configdir/lsb.params； 队列配置文件为 /share/lsf/lsf/conf/lsbatch/sustc_ess/configdir/lsb.queues； LSF 主配置文件为 /share/lsf/lsf/conf/lsf.conf。 LSF 系统动态优先级的计算LSF 作业系统会根据用户作业的作业槽数、运行时间和累积核时等资源占用情况，实时调整用户在队列的优先级，即动态优先级。 LSF 系统默认的动态优先级计算公式为： dynamic_priority = number_shares/(cpu_time*CPU_TIME_FACTOR + run_time*RUN_TIME_FACTOR + (1 + job_slots)*RUN_JOB_FACTOR + fairshare_adjustment*FAIRSHARE_ADJUSTMENT_FACTOR) 其中，cpu_time、run_time 和 job_slots 是 LSF 系统收集的用户总资源消耗；CPU_TIME_FACTOR、RUN_TIME_FACTOR 和 RUN_JOB_FACTOR 为权重因子，默认值分别为 0.7、0.7 和 3，可在 lsb.queues 或 lsb.params 中设置。 另外，lsb.queues 或 lsb.params 中的 HIST_HOURS 参数为 LSF 系统收集资源消耗历史的时间间隔，默认值为 5。 GPFS 文件系统磁盘配额在创建新的 GPFS 文件系统时，可在 mmcrfs 命令中加入 -Q yes 选项，以激活该文件系统的磁盘配额设置。对于原有的 GPFS 文件系统，可以命令 [root@mn01 ~]$ mmchfs -Q yes 重新激活该系统的磁盘配额设置。若想针对目录进行磁盘配额，需指定 –perfileset-quota 选项。 GPFS 文件系统可以 mmsetquota 命令设置磁盘配额，具体可根据该命令的帮助（以命令 [user@mn01 ~]$ man mmsetquota 查看）来进行详细的配置。 当前 fs01 文件系统的用户默认磁盘配额是由 stanza 文件 /share/system/conf/quoatesetting 设置的（设置命令为 [root@mn01 ~]$ mmsetquota -F /share/system/conf/quotasetting）。 通过命令 [root@mn01 ~]$ mmsetquota filesystemname --user username --block 2T:2560G，可对 username 用户单独设置 filesystemname 文件系统的磁盘配额。 在设置软硬限制时，指定 0: 即为无任何限制，可用于取消原有限制。 通过命令行执行命令生效的 GPFS 文件系统的磁盘配置，即永久生效，即使重启集群系统也不会失效。 注意，当针对整个文件系统进行配额设置（即 mmcrfs 或 mmchfs 命令中不指定 –perfileset-quota 选项）时，则不可在 mmsetquota 命令中指定 fileset 选项，否则该命令不会生效。 一些疑问zsh 启动时报错找不到 complete 命令，该如何解决？ 这个命令是 bash 的内建命令，而调用该命令的脚本是用来收集系统管理信息的，若禁止加载该脚本，会导致部分管理功能的缺失。考虑到 zshell 的使用者不多，不建议禁止该脚本的加载。 LSF 系统在识别计算节点的 CPU 核数跟 htop 工具识别出来的核数有区别，这是为什么？ 这应该是因为 LSF 系统识别出来的是物理核数，而 htop 识别出来的是逻辑核数，而有些节点可能没有开启超线程设置。不过无论如何，LSF 系统调用的核数皆以该系统自动识别出来的核数为准。 存储节点只连接一根网线会影响使用吗？ 不影响使用，但会影响性能。在硬件允许的情况下，应把两根网线都连接上。 集群系统关机后存储节点指示灯依然常亮，此时若突然断电会对所存储的数据造成影响吗？ 在集群系统已关机的情况下，已停止了所有节点对存储节点的读写操作，即断电不再会对数据安全构成威胁。另外，存储节点也没有单独的关机指令，也就没有其他可执行的额外操作了。 计算节点的硬盘可以利用起来吗？ 计算节点的硬盘只能用来安装系统，无法共享出来供用户使用。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神奇的贝叶斯理论]]></title>
    <url>%2F2018%2F12%2F08%2FBayes-theorem%2F</url>
    <content type="text"><![CDATA[概率论只不过是把常识用数学公式表达了出来。（From Laplace） 历史根据维基，所谓的贝叶斯方法起源于逆向概率问题。正向概率问题很常见，如「已知一个袋内有 N 个白球和 M 个黑球，伸手进去摸一球，问摸出黑球的概率几何」；而反过来，一个相应的逆向概率问题可以是「现不知袋中黑白球的个数，在经过多次取出放入后，根据取出球的颜色求袋中黑白球的比例」。可见，逆概问题即，不知实际模型如何，但知观测数据怎样，求模型。 对于逆概问题，我们可以先给出若干个假设，然后求出不同假设的可能性（假设本身成立的概率，即先验概率）和可靠性（由假设得到观测的概率，即似然），其中最可能又可靠的假设即为所求。 第一个例子在使用 Office Word 写作时，我们会发现一个非常人性化的功能，叫拼写纠正。 在攻城狮实现这一功能时就涉及到一个概率问题，比如用户输入 thwn，那么可以猜测用户本意输入 than 或者 then，讲道理，在显示这两个纠正选项时应该按可能性排序，那么问题来了，到底哪个纠正选项可能性更大呢？怎么看起来好像两个选项的可能性差不多呢？ 第二个例子下面展示的是自然语言的歧义性： 1The girl saw the boy with a telescope. 作者想通过这句话表达什么意思呢？这个句子该如何理解？「那个女孩用望远镜看见了那个男孩 (The girl saw-with-a-telescope the boy) 」？也可以吧，但有没有另一种可能？「那个女孩看见了那个拿着望远镜的男孩 (The girl saw the-boy-with-a-telescope) 」怎样呢？ 那么问题也来了，为什么我们大部分人在这两种理解中优先选择了前者？其实，我们的选择过程中就隐藏着一个贝叶斯理论的应用。 第三个例子这里在平面上给出 $N$ 个点，求一个函数拟合这些离散点。 贝叶斯公式贝叶斯理论有一个很简单的公式，绝不是「非专人所不能理解」的那种： $$P(B|A)=\frac{P(A|B)\times P(B)}{P(A)}=\frac{P(A|B)\times P(B)}{P(A|B)\times P(B)+P(A|\sim B)\times P(\sim B)}$$ 也就是，$P(B|A)=\frac{P(AB)}{P(A)}$ 或者 $P(B|A)\times P(A)=P(AB)$。 是的，贝叶斯理论就是一个简单而又深刻的生活道理：两件事同时发生的可能性，就是一件事发生的可能性和一件事发生的情况下另一件事发生的可能性的乘积。 基本的贝叶斯公式给出了一个启示：我们现在有一个观测数据 A 和一个假设模型 B，对于不同的假设模型都有一个恒定不变的观测数据的可能性 $P(A)$（在只有实际模型才会影响观测结果的提前下，可认为这个概率为 1），那么 $P(B|A)\propto P(B)\times P(A|B)$，即这个观测数据是由这个假设模型产生的的可能性 $P(B|A)$，由这个模型本身的可能性 $P(B)$（我们常常忽略这一点）和这个模型产生这个数据的可能性 $P(B|A)$（我们常常用拟合度来表征）的乘积决定。 也就是说： 对于给定的观测数据，一个假设模型是好是坏，取决于「这个假设模型本身独立的可能性大小（先验概率，Prior ）」和「这个假设模型生成我们的观测数据的可能性大小（似然，Likelihood ）」的乘积。 奥卡姆剃刀与最大似然我们总是希望透过表象看本质，却又往往容易被表象所迷惑而看不到本质。总结起来，在这里迷惑我们的就是奥卡姆剃刀或最大似然。 奥卡姆剃刀回到前述拼写纠正的例子（第一个例子），为什么我们觉得两个猜测 than 或 then 是等可能的？因为这两个单词的常见程度相近。在这里，迷惑我们的就是奥卡姆剃刀。 奥卡姆剃刀认为，先验概率最大的模型具有最大的优势，即 $P(B|A)\propto P(B)$。一个假设模型越平凡，越常见，它本身的概率越大，这个模型就越好，越可能是隐藏在观测数据背后的真实模型。 是的，我们很容易发觉，奥卡姆剃刀太片面了。就在上述的拼写纠正的例子中，两个猜测的常见程度相近，先验概率约等，这可让有强迫症的攻城狮们如何是好？就算两个纠正选项的好坏程度相同，也不能把两个排布在候选列表的同一个位置啊。对，这就是一个奥卡姆剃刀应用失败的例子，因为它回答不了我们的问题，比较不出两个假设模型的好坏差异（那么一个问题，如何才能合理地对这两个猜测作出一个优胜劣汰的评断呢？留给后面作讨论）。 对于上述的函数拟合的例子（第三个例子），奥卡姆剃刀告诉我们，要用最常见最普通的函数，也即一阶多项式（直线）。虽然在这些离散点趋于共线的情况下，奥卡姆剃刀给了我们一个简单直接而又合理的方案，这时的直线拟合已经能我们满意了；但对于离散点趋于呈拋物线，甚至更高阶多项式分布的情况下，我们就不能在奥卡姆剃刀的指导下再去用一条直线去拟合离散点了。在第一种情况下，直线并不能保证精确地穿过所有离散点，即数据还不能完美匹配，但我们却觉得这样做还是可靠的，为什么呢？因为实践告诉我们，在一个直线上随意地取一些离散点，在拾取这些点位坐标时存在着不可避免的观测误差，这些误差会导致拾取到的离散点不再共线。 最大似然回到前述语言歧义的例子（第二个例子），为什么我们很习惯地就形成了第一种理解呢？因为采用第二种语句结构不太可能恰好形成如上的表述。在这里，迷惑我们的又是最大似然。 最大似然认为，似然程度最大的模型具有最大的优势，即 $P(B|A)\propto P(A|B)$。一个假设模型越可能生成我们的观测数据（常用假设模型的仿真数据和观测数据的契合程度来表征），这个模型就越好。 在上述的语言歧义的例子中，若作者真正想表述的是第一种理解，那么这个 telescope 就必须是一个可以「目光透过」的东西，即第一种语句结构形成如上表述（从模型 see-with-sth. sb. 到观测 see the boy with a telescope）的可能性就大概是，从一堆可以「目光透过」的东西中取出 telescope 的可能性；若是第二种理解（从模型 see sb.-with-sth. 到观测 see the boy with a telescope），男孩手里的几近是任何可以随身的东西，这种语句结构的可能性就差不多为，从大千世界的琳琅满目的几乎不受限定的东西中取出 telescope 的可能性，即接近零。就这样，最大似然诱导我们悄悄地做出了选择。 这里扩展一下，如果把前述语句中的 telescope 换成 telephone 又该如何理解？我们的直觉很快告诉我们，应该是第二种理解。继续，为什么呢？因为此时第一种语句结构是要从一堆可以「目光透过」的东西中取出 telephone，这种可能性直直地为零，telephone 明明不能「目光透过」的嘛。 是的，该轮到批评最大似然了，即使它在语言歧义的例子中应用得很成功（那么又一个问题，为什么它在这里这么成功？后面再讨论）。 同样地，对于函数拟合的例子（第三个例子），最大似然告诉我们，要用与离散点拟合效果最好的函数，也即 $N-1$ 阶多项式。虽然在离散点的离散程度很大的情况下，这样拟合会可能得到一个比较合理的方案；但在离散点本就近似共线的情况下，再用高阶多项式去拟合，就不大合适了。在第二种情况下，高阶函数曲线能精确地穿过所有离散点，即数据能完美匹配，但我们却觉得这样做并不可靠，为什么呢？因为实践告诉我们，从一个高阶函数曲线上随意地取一些离散点，而这些点恰好近似共线的可能性却几乎为零。就是最大似然所谓的数据过配（overfitting）问题，即过分地寻求能够完美解释观测数据的模型。 这里告诉我们，数据过配不好，但从理论上来说，为什么不好？因为实践中数据的观测存在误差，在我们离散取点拾取坐标时会引入人为误差，如果过分地追求数据完美匹配，也就在用模型解释观测的同时，努力地用部分模型贡献去解释这些误差，而误差却不是由模型产生的，这就会导致我们的假设模型偏离真实模型。 问题的最终解决对于由观测到模型的问题，前面介绍了两种简单方便却都以偏盖全的方法。到这里，问题的最终解决，就要依靠贝叶斯理论了。 第一个例子前面提到，奥卡姆剃刀在拼写纠正中应用失败，那我们在这里应该如何安排两个猜测 than 和 then 在候选列表里的先后顺序呢？随便，谁先谁后都一样？那不科学。非要排个坐次？那就需要贝叶斯理论出场了。 在这个例子中，奥卡姆剃刀说，两个猜测的先验概率基本相同，那我们再考虑一下两个猜测的似然程度。经常使用键盘就会发现，e 键比 a 键离 w 键更近，我们更可能在手指抽动的时候将 e（而非 a）错敲成 w，所以相比之下，thwn 更可能是 then 的错误拼写，从模型 then 到观测 thwn 的可能性比从模型 than 到观测 thwn 的可能性更大，也就是说，then 的似然程度更高。根据贝叶斯理论 ，先验概率相同，似然越大，二者相乘，则模型越好。进一步地，我们就可以心安理得地在候选列表里将 then 安排在 than 的前面了。 第二个例子前面说到，最大似然在语言歧义的例子中应用得很成功，但是为什么它在这里就成功了呢？其实也还是因为贝叶斯理论。 在这个例子中，最大似然说，两种语句结构的似然程度不同，不过我们还是来考虑一下两种语句结构的先验概率。咦，两种语句结构（see-with-sth. sb. 和 see sb.-with-sth.）所表达的场景的常见程度差不多唉，那就是说它俩的先验概率也基本相同呀。对，在先验概率 $P(B)$ 相同的情况下，贝叶斯理论 $P(B|A)\propto P(B)\times P(A|B)$ 也就退化成了最大似然 $P(B|A)\propto P(A|B)$。所以，最大似然才会在这个例子中应用得如此成功。 第三个例子我们已经在前面看到了，在函数拟合时，既不能单纯地采用奥卡姆剃刀也不能单纯地采用最大似然来指导我们的工作。这时候，就得祭出大杀器贝叶斯理论了。 函数拟合这个例子比较复杂，我们应该始终秉承贝叶斯理论的思想，即同时考虑模型的先验概率和似然程度。在离散点分布有一定规律时，先用不同阶的多项式拟合，计算得到拟合误差（似然程度），再在可容忍的误差范围内的不同阶中选择更低阶的多项式（先验概率）。 至此，贝叶斯理论就完美解决了上述所有困扰我们的问题。]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Ubuntu 的陈年往事]]></title>
    <url>%2F2018%2F11%2F28%2FTips-of-Ubuntu%2F</url>
    <content type="text"><![CDATA[Ubuntu 启动栏图标自定义设置个人有时的误操作会导致 Ubuntu 启动栏某些软件的图标消失，变成一个大大的问号「？」，为了挽救难看的启动栏，这里学习一下 Ubuntu 启动栏图标的实现原理： 在目录 /usr/share/applications 下可以看到，这里有很多以 .desktop 结尾的文件，其实这些文件就是 Ubuntu 启动栏各个软件图标的设置文件。 这里以 firefox 火狐浏览器（是的，我就是把它的图标搞丢了 😐）为例介绍启动图标的设置。可自行新建或修改一个以 firefox.desktop 命令的文件，写入或修改内容： 12345678[Desktop Entry]Name=Firefox 63.0.3Comment=this is firefoxExec=/opt/firefox/firefoxIcon=/opt/firefox/browser/chrome/icons/defaults/default128.pngTerminal=falseType=ApplicationCategories=Application;Network; 其中，较为重要的几个，Name 字段即启动图标鼠标悬停提示，Exec 字段即启动图标对应的可执行程序，Icon 字段为启动图标的 icon 文件。 Ubuntu 20 添加自定义程序到启动栏同样地，在目录 /usr/share/applications 下，参照上节 firefox 的示例，自行创建一个以 xxxx.desktop 命令的文件，并以命令 [user@host /usr/share/applications]$ sudo chmod +x xxxx.desktop 赋予其可执行权限，至此即可在启动栏尾部选择「Show Applications」菜单，在所有应用列表中找到刚才创建的应用启动图标（以 Name 字段为名称，以 Icon 字段指向的图片为图标），在该图标上右键选择「Add to Favorites」即可将此自定义程序（即 Exec 字段指向的可执行程序）添加到系统的快速启动栏。 修改 Ubuntu 默认终端在考虑到多终端窗口分屏显示时，可以采用命令 [root@A ~]$ apt-get install terminator 安装新的终端工具 Terminator 。但在安装该工具后会自动设置默认终端为 Terminator，对于 Ubuntu 16.04，可通过如下命令重置默认终端为系统自带的 gnome-terminal： $ gsettings set org.gnome.desktop.default-applications.terminal exec /usr/bin/gnome-terminal $ gsettings set org.gnome.desktop.default-applications.terminal exec-arg &quot;-x&quot; 对于 Ubuntu 20.04，可通过如下命令 [root@A ~]$ update-alternatives --config x-terminal-emulator 重置默认终端。 FoxitReader 支持中文输入在安装完 Linux 平台的 FoxitReader （版本号：2.4.4.0910）后，FoxitReader 默认是不支持中文输入的。在 FoxitReader 安装目录下的 FoxitReader.sh 脚本文件中加入环境变量 GTK_IM_MODULE、QT_IM_MODULE 和 XMODIFIERS 的设置，即添加 gtk、qt 等对 fcitx 的支持： 12345678#!/bin/sh appname="FoxitReader" selfpath="/opt/foxitsoftware/foxitreader" export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=@im=fcitx exec "$selfpath/$appname" "$@" 注意，需将 export 语言添加在 exec 语句之前。 用 ImageMagick convert 拼贴多张图片命令 $ convert flameshot_*.png -gravity Center -append new.png 将所有匹配到 flameshot_*.png 的图片文件从上至下紧凑拼接成一整个名为 new.png 的图片。 命令 $ convert flameshot_*.png -gravity Center +append new.png 将所有匹配到 flameshot_*.png 的图片文件从左至右紧凑拼接成一整个名为 new.png 的图片。 命令 $ convert Screenshot*.png -background black -splice 0x10+0+0 -gravity Center -append -chop 0x10+0+0 new.png 将所有匹配到 Screenshot*.png 的图片文件从上至下拼接成一整个名为 new.png 的图片，拼接时所有单个 Screenshot*.png 按水平居中对齐，在每两个图片中间插入 10 像素的空隙，并取背景底色为黑色。 命令 $ convert Screenshot*.png -background white -splice 10x0+0+0 -gravity Center +append -chop 10x0+0+0 new.png 将所有匹配到 Screenshot*.png 的图片文件从左至右拼接成一整个名为 new.png 的图片，拼接时所有单个 Screenshot*.png 按垂直居中对齐，在每两个图片中间插入 10 像素的空隙，并取前景底色为白色。 批量修改目录下所有文件夹或文件的属性可以命令 [user@A target_directory]$ find . -type d -exec chmod 755 {} \; 修改主文件夹 target_directory 下所有子文件夹的访问属性为 755。 可以命令 [user@A target_directory]$ find . -type f -exec chmod 644 {} \; 修改主文件夹 target_directory 下所有文件的访问属性为 644。 Mendeley 支持中文输入根据 解决 Debian 中 RStudio 和 Mendeley 下 Fcitx 输入法不能使用的问题 所述，Mendeley 等软件不支持 Fcitx 输入法输入中文的原因可能是，这些软件使用的 Qt 版本与系统版本不同，而 Fcitx 是直接调用的系统的 Qt 库。 所以，Mendeley 等的 Fcitx 中文支持问题的最根本最可靠的解决办法是，下载这些软件对应版本的 Qt 库源码，编译生成动态链接库，拷贝到软件的插件目录下即可。 此外，针对 Mendeley 软件，另一种可能但不可靠的解决办法（参见 libfcitxplatforminputcontextplugin.so）是，下载 libfcitxplatforminputcontextplugin.so.for.MendeleyDesktop 并拷贝到插件目录 /opt/mendeleydesktop/plugins/qt/plugins/platforminputcontexts/ 下并重命名为 libfcitxplatforminputcontextplugin.so，可通过如下命令实现： 12$ wget https://github.com/JackieMium/libfcitxplatforminputcontextplugin.so/raw/master/lib-fcitx-plugin/debian.sid.20171223/libfcitxplatforminputcontextplugin.so.for.MendeleyDesktop$ sudo mv libfcitxplatforminputcontextplugin.so.for.MendeleyDesktop /opt/mendeleydesktop/plugins/qt/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AWK 编程拾锦]]></title>
    <url>%2F2018%2F11%2F26%2FExamples-of-AWK%2F</url>
    <content type="text"><![CDATA[以相同的列首字段分割文件需求文件的第一列为分类标志，以相同的每行第一列内容为分隔，将文件分为不同的多个文件。 实现假设有文件 “run” 内容如下： 123456780 one0 two1 three1 four1 five2 six2 seven2 eigth 首先，需要一个变量 fs 来记录每相同首列部分的首列内容，在 BEGIN 阶段需要对此变量初始化，在判断出 fs 与当前行的首列内容 $1 不同时重新给 fs 赋值并创建新文件；同时，还需要一个变量 fn 记录不同部分对应的输出文件名。具体实现为： 123456789101112[user@A ~]$ cat run | awk 'BEGIN &#123;fs=""&#125; &#123;if(fs!=$1) &#123;fs=$1; fn="file" $1; print $1, $2 &gt; fn&#125; else &#123;print $1, $2 &gt;&gt; fn&#125;&#125;'[user@A ~]$ cat file00 one0 two[user@A ~]$ cat file11 three1 four1 five[user@A ~]$ cat file22 six2 seven2 eigth 同模式重复多行块重组需求文件按同一模式多行重复不同对象的内容，现需要将同一对象的信息以同一行内容保存。 实现假设有文件 “run” 内容如下： 12345678910111213141516学号姓名年龄成绩200101张三1874200102李四1739200103王二1956 可见，该文件以每四行分别为“学号”、“姓名”、“年龄”和“成绩”内容的模式呈多行重复，这里要将每四行重新整合为一行，借助内置变量已读记录数 NR 和输出记录分隔符 ORS ，可以如下命令实现： 12345[user@A ~]$ cat run | awk '&#123;if(NR%4!=0) ORS=" "; else ORS="\n"; print $0&#125;' 学号 姓名 年龄 成绩200101 张三 18 74200102 李四 17 39200103 王二 19 56]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地震学中那些可爱的人和事儿]]></title>
    <url>%2F2018%2F11%2F24%2FLove-of-Seismology%2F</url>
    <content type="text"><![CDATA[SLIM 研究组即 The University of British Columbia 的 Seismic Laboratory for Imaging and Modeling，此处为该研究组在 github 上的主页。 这里要介绍的是 JUDI (Julia Devito Inversion) 反演框架，这是一个采用 Julia 语言编写的勘探地震学正反演并行程序包，可以实现基于波动方程的反演应用，包括全波形反演和最小二乘逆时偏移。程序包中波动方程采用有限差分代码自动生成器 Devito 求解。另外，作者就此程序包发布了三篇使用指导，分别对正演模拟、伴随模拟和最优化作了说明。 SEG 开源数据SEG 维基开放数据版面中列出了一些可用的模型、数据、程序和研究机构，包括 SEAM open data, Phase I 2D Data Sets, 2D land seismic data, 2D marine seismic data, 3D land seismic data, 3D marine seismic data, SEG/DMEC Reference Mineral Exploration Data, New Zealand 3D, OpenGeoscience at British Geological Survey, Natural Resources Canada, National Petroleum Reserve Alaska, Norwegian Petroleum Directorate, 2D synthetic seismic data, SMAART models, 3D synthetic seismic data, Gravity and magnetic data, Chevron GOM Full Waveform Inversion Seismic CSEM and MT Synthetic, Topographic and bathymetric data, Dutch Ministry of Economic Affairs Data Release 和 Geophysical Software and Algorithms。 ETOPO1 全球地形模型ETOPO1 是一个 1 弧分的全球地表起伏模型，它整合了陆地地形和洋底测深的数据。对于南极洲和格陵兰岛的冰层，分别提供了层顶 (Ice Surface) 和层底 (Bedrock) 两种起伏数据。 gCAP 解gCAP采用 the generalized cut-and-paste method (L. Zhu and Y. Ben-Zion, 2013) 对宽频带波形滤波获得台湾地区的震源机制解。 SEIZMO 项目SEIZMO 项目收集了超 700 余个 Matlab 函数，提供了一个类似 SAC 的地震数据预处理、质量控制和分析框架，包括标准地震数据格式读写、元数据展示和编辑、地震成图、数据处理（互相关、卷积、反卷积、去势、微分、积分、插值、重采样、滤波、合并、旋转、叠加、谱分析和锥化等）与交互分析。另外，这里是该项目的 GitHub 主页。]]></content>
      <categories>
        <category>Seismology</category>
      </categories>
      <tags>
        <tag>Software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些不可吿人的小东西]]></title>
    <url>%2F2018%2F11%2F03%2FPassword%2F</url>
    <content type="text"><![CDATA[Welcome but enter password to read 9fad3be05d09c19f03755f2d122f93acfa3fe5d36019c57530aa3f5bf239b59878e3f92bd59ad10f72fbee4353d22b7fc9bee697ba67e9a934d5258852dd49c451b7d3af1b7dbc911bedba150060867bee0b1cb510cfd56f5a552ce9dee0bcff1fe9535153ad379ae3ff8e65b13597c66da6c85c557bad47cc5206f5073ba37d90a2b7c1d6768898d0d5a63e071e398be32eb246226475257d27e35e83cbfa8afe140b3994a0dcc5d41cefaad9da5fc96b1605ce9171b907b73c2c2403db0207ced593a933d0da9009622f1acb6ce4692224b009f8e091a7ea6565ad98df04788b6c262ac6ba2e71400167d20b97549859cba12d3b5fa959f1b14b24bb89aa8d10342e54dcbc3ab54058e497284b462c4ff168bb7a0b84b5522380cd7b7420e12727108fc7b8a1490df9578411c4271216015bdd4091cb2e9f94b98dc31e4e4d5bd3b3f1a95fc4c80a8407ec8cf8e94ac418e7b63506d38568fa7b5a5f89646d15e4de40faa44429dc37a04ed2ed95a821f5b49628730673e69a83da4db170b7707dfc28049719c455bd1cecf8923d1797f698e6087bce9c4f6ab68eeb6560e3a692a7243ca9c7da3fddf29ed0c00019a9b3be370209f289c7a9bb3d530d4cd5ad8fc8e69b42639a7a5e82dbf217a795c799aad1613dd9649feb61fe15e7959917138af0bb6057e693018136288d6c61a784e09ebab9e2002a263f3968b805bb07a38db5277c785beeba36a3700d55a9df79d70d40b36b4ca77579e590d61f0d23af1861300940ddee6b37657dad77dc21fcbc218003c4c2f16ce28ad9c32fb07cdca3b465ad94e3e9458cf77a4bbab2a7211842b6c1e021e37a4fef1a392502354d93253a96d12bd7fad14720edcf7471d9cec6908e62027344ae88a010b08e1d79fd834fc43bdc9f896bed60731598464e3fb65f009a98b6a5f65783007f6653eeb33f38fda2c61ae7d34cf1adb96ad6be305eabb990efd9d6cab6a2c2eeb9f26f325ae62cfbb163ffb67ee9645e8183de61955257dbff328730055a9a2836e2357bfcfac14427b420c5d1982987cbbaf7cad66feb816fcbb96515ef43c9850380f20481696ccc087026ab6175c164c85b7ff844fd559036409e6955e672e8d160fe4e6edea37f3d4d45f368538a2f6c431ae2fd2702934ca50c88f6bc17b4763962f065a98e0ce88aeec1183beea472aae7f59bdba128a0a4ba58e1d7daa68e61fa71a6d7891963b175c95d7c0dc6a2d87ae5b5414da426b77fd617a3ffb005b413d20a0ee6fb488fa8e160d888635436324245fb033e75a47ad85393b62c536d34169bebd39bc8ad8de44d3cdd67d31aa37f6d207c2e87f34b85db852013d4129530f16abfef6f4d52bf290a7a5c82bf4a1db580091d997f049ea5571cdb12a0e5531ee3af97f17d26d460730ccbecfaaffc9ae01e3fa7e7e35128f2f326f96bed1f3b565ee3e38f626e0e277b1a78bfb53913b2c38be3e008208dd76271048c9cb16fbaf15586de5d5dd44c23df3dbec4eb194b7c339c33a17ebb2529b8e465ce7b74e2c1848275b25bec6cff873e6e970cac475073f635d6a3c2afe3684388c87984e63cd302649775ea2d6c9e4ab890d050eafad232fbec6d9d0395d986fc5ea64a5d4af9d112d34d280bae5dafbbd19853fb06470877e6ac4e902dc707c5f82ba6a258041fae484c40ae342450f92ed523ad953e1fa307c615714248ef244693f7890e4587a0a884404ff4bb3f597cd97b67b6982f70229271d9c35548883fcbf0313b3a976b05b28ff51ec0ea72fc71197d8379e393a7f9fa893629793e3d1d5e7ac1e5d48898cb315abf7c9557de33b6b6647d29f47aca86712cac7926422c12813109dfd3918c1a955be672e9aeca2cd4b3cb278ccb32a58afb62f3dd48963de51203053300b01cbd60c3]]></content>
      <categories>
        <category>NOpen</category>
      </categories>
      <tags>
        <tag>Secret</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二阶方阵的逆]]></title>
    <url>%2F2018%2F09%2F29%2FThe-Inverse-Matrix-of-2x2%2F</url>
    <content type="text"><![CDATA[基础知识逆矩阵方阵 $A$ 的逆矩阵： $$A^{-1}=\frac{1}{|A|}A^*$$ 其中，$|A|$ 为 $A$ 的行列式，$A^*$ 为 $A$ 的伴随矩阵。 行列式方阵 $A$ 的行列式： $$|A|=\left|\begin{array}{c} a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \newline a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \newline \vdots &amp; \vdots &amp; \ddots &amp; \vdots \newline a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn} \end{array}\right|=\sum_k(-1)^ka_{1k_1}a_{2k_2}\cdots a_{nk_n}$$ 其中，$k_1, k_2, \cdots, k_n$ 是将序列 $1, 2, \cdots, n$ 的元素次序交换 $k$ 次所得到的一个序列。 伴随矩阵方阵 $A$ 的伴随矩阵为： $$A^*=\left[\begin{array}{c} A_{11} &amp; A_{21} &amp; \cdots &amp; A_{n1} \newline A_{12} &amp; A_{22} &amp; \cdots &amp; A_{n2} \newline \vdots &amp; \vdots &amp; \ddots &amp; \vdots \newline A_{1n} &amp; A_{2n} &amp; \cdots &amp; A_{nn} \end{array}\right]$$ 其中，$A_{ij}$ 为矩阵 $A$ 的元素 $a_{ij}$ 的代数余子式。 代数余子式在 $n$ 阶行列式 $A$ 中任意选定的 $k$ 行 $k$ 列元素，其中在行列交点上的元素按原顺序排列组成的 $k$ 阶行列式，称为行列式 $A$ 的 $k$ 阶子式 $D$ 。 在 $n$ 阶行列式 $A$ 中划去任意选定的 $k$ 行 $k$ 列元素后，余下的元素按原顺序排列组成的 $n-k$ 阶行列式，称为行列式 $A$ 的 $k$ 阶子式 $D$ 的余子式 $M$ 。 如果所选定的行列在行列式 $A$ 中的行列序号分别为 $i_1, i_2, \cdots, i_k$ 和 $j_1, j_2, \cdots, j_k$ ，则行列式 $A$ 的 $k$ 阶子式 $D$ 的代数余子式为 $$(-1)^{(i_1+i_2+\cdots+i_k)+(j_1+j_2+\cdots+j_k)}\cdot M$$ 二阶矩阵的逆对于二阶矩阵 $A=\left[\begin{array}{c} a_{11} &amp; a_{12} \newline a_{21} &amp; a_{22} \end{array}\right]$ ： $|A|=a_{11}\cdot a_{22}-a_{12}\cdot a_{21}$ ， $A_{11} = (-1)^{(1+1)}\cdot a_{22}=a_{22}$ ， $A_{12}=(-1)^{(1+2)}\cdot a_{21}=-a_{21}$ ， $A_{21}=(-1)^{(2+1)}\cdot a_{12}=-a_{12}$ ， $A_{22}=(-1)^{(2+2)}\cdot a_{11}=a_{11}$ ， 则其伴随矩阵为 $$A^*=\left[\begin{array}{c} A_{11} &amp; A_{21} \newline A_{12} &amp; A_{22} \end{array}\right]=\left[\begin{array}{c} a_{22} &amp; -a_{12} \newline -a_{21} &amp; a_{11} \end{array}\right]$$ 其逆矩阵为 $$A^{-1}=\frac{1}{|A|}\cdot A^*=\frac{1}{a_{11}\cdot a_{22}-a_{12}\cdot a_{21}}\cdot\left[\begin{array}{c} a_{22} &amp; -a_{12} \newline -a_{21} &amp; a_{11} \end{array}\right]$$]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cuda C 学习之路]]></title>
    <url>%2F2018%2F09%2F02%2FTips-of-Cuda-C%2F</url>
    <content type="text"><![CDATA[C 相关 C 语言中函数形参默认传值，即函数内部修改形参不会改变实参的值；但可以通过指针形参传递实参地址，修改指针引用值可以改变实参的值。 在变量单双精度切换时，使用 scanf 函数读入数据到变量也需在格式字符串 %f 和 %lf 之间切换，但使用 printf 函数输出变量数据则不需切换。 else 优先与上文最近的不具备完整 if-else 结构的 if 结合组成判断分支结构： Cuda 相关 Cuda kernel 函数不允许通过指针形参传递单变量地址，修改指针引用值不会改变外部实参的值。 在 Cuda kernel 函数内进行屏幕输出时，可在 host 端 kernel 函数之后加上 cudaDeviceReset(); 确保屏幕及时输出。 若运行时报错 “Too many resources requested for lanch”，可能是处理器上的 register 数超出了限制，可减少 the number of threads per block 后再次尝试运行。 在 C++ 类的构造函数中，不要 launch kernel，否则会发生不可预测的后果，在程序运行至某处时报错 “an illegal memory access was encountered” ？]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Cuda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些数学概念]]></title>
    <url>%2F2018%2F07%2F22%2FBasic-of-Math%2F</url>
    <content type="text"><![CDATA[Hilbert 变换定义参考 Wikipedia 。 The Hilbert transform of the function $u(t)$ can be thought of as the convolution of $u(t)$ with the function $h(t)=\frac{1}{\pi t}$. Because $h(t)$ is not integrable, the integrals defining the convolution do not converge. Instead, the Hilbert transform is defined using the Cauchy principal value (denoted here by $p$ ): $$\mathcal{H}\lbrace u(t)\rbrace=p\int_{-\infty}^{\infty}u(\tau)h(t-\tau)d\tau=\frac{1}{\pi}p\int_{-\infty}^{\infty}\frac{u(\tau)}{t-\tau}d\tau$$ 性质A property of Hilbert transform is: $\mathcal{H}\lbrace\mathcal{H}\lbrace u(t)\rbrace\rbrace=-u(t)$. 解析信号The analytic signal is constructed from a real signal $f(t)$ and its Hilbert transform $\mathcal{H}\lbrace f(t)\rbrace$ : $$\tilde f(t)=f(t)-i\mathcal H\lbrace f(t)\rbrace$$ The analytic signal can be written in terms of the instantaneous amplitude $E(t)$ and the instantaneous phase $\phi(t)$ as $$\tilde f(t)=E(t)e^{i\phi(t)}$$ where $$\phi(t)=\arctan\frac{\mathfrak I\lbrace\tilde f(t)\rbrace}{\mathfrak R\lbrace\tilde f(t)\rbrace}=\arctan\frac{\mathcal H\lbrace f(t)\rbrace}{f(t)}$$ $$E(t)=\sqrt{\mathfrak R\lbrace\tilde f(t)\rbrace^2+\mathfrak I\lbrace\tilde f(t)\rbrace^2}=\sqrt{f(t)^2+\mathcal H\lbrace f(t)\rbrace^2}$$ 共轭转置定义即 Hermitian 转置，参考 Wikipedia 。 In mathematics, the conjugate transpose and Hermitian transpose of an $m\times n$ matrix $A$ with complex entries is the $n\times m$ matrix $A^\ast$ obtained from $A$ by taking the transpose and then taking the complex conjugate of each entry. The definition can also be written as $$ \left(A^H \right)_{ij} = \overline{A_{ji}} $$ or $$A^\ast=(\bar{A})^T=\overline{A^T}$$ Another name for the conjugate transpose of a matrix is adjoint matrix. The commonly used symbols for the conjugate transpose: $A^\ast$ or $A^H$ in linear algebra ; $A^\dagger$ in quantum mechanics ; $A^+$. 例子If $A=\begin{bmatrix} 1 &amp; -2-i \newline 1+i &amp; i \end{bmatrix} $, then $A^\ast=\begin{bmatrix} 1 &amp; 1-i \newline -2+i &amp; -i \end{bmatrix}$. Kronecker 乘积定义参考 Wikipedia 。 In mathematics, the Kronecker product, denoted by $\otimes$, is an operation on two matrices of arbitrary size resulting in a block matrix. It is a generalization of the outer product from vectors to matrices. If $A$ is an $m\times n$ matrix and $B$ is a $p\times q$ matrix, then the Kronecker product $A\otimes B$ is the $mp\times nq$ block matrix: $$A\otimes B=\left[\begin{array}{c} a_{11}B &amp; a_{12}B &amp; \cdots &amp; a_{1n}B \newline a_{21}B &amp; a_{22}B &amp; \cdots &amp; a_{2n}B \newline \vdots &amp; \vdots &amp; \ddots &amp; \vdots \newline a_{m1}B &amp; a_{m2}B &amp; \cdots &amp; a_{mn}B \end{array}\right]$$ where $$a_{ij}B=\left[ \begin{array}{c} a_{ij}b_{11} &amp; a_{ij}b_{12} &amp; \cdots &amp; a_{ij}b_{1q} \newline a_{ij}b_{21} &amp; a_{ij}b_{22} &amp; \cdots &amp; a_{ij}b_{2q} \newline \vdots &amp; \vdots &amp; \ddots &amp; \vdots \newline a_{ij}b_{p1} &amp; a_{ij}b_{p2} &amp; \cdots &amp; a_{ij}b_{pq} \end{array} \right]$$ 例子$$\left[\begin{array}{c} 1 &amp; 2 \newline 3 &amp; 4 \end{array}\right] \otimes \left[\begin{array}{c} 0 &amp; 5 \newline 6 &amp; 7 \end{array}\right]=\left[\begin{array}{c} 1\cdot \left[\begin{array}{c} 0 &amp; 5 \newline 6 &amp; 7 \end{array}\right] &amp; 2\cdot \left[\begin{array}{c} 0 &amp; 5 \newline 6 &amp; 7 \end{array}\right] \newline 3\cdot \left[\begin{array}{c} 0 &amp; 5 \newline 6 &amp; 7 \end{array}\right] &amp; 4\cdot \left[\begin{array}{c} 0 &amp; 5 \newline 6 &amp; 7 \end{array}\right] \end{array}\right]=\left[\begin{array}{c} 0 &amp; 5 &amp; 0 &amp; 10 \newline 6 &amp; 7 &amp; 12 &amp; 14 \newline 0 &amp; 15 &amp; 0 &amp; 20 \newline 18 &amp; 21 &amp; 24 &amp; 28 \end{array}\right]$$ Frobenius 范数定义即 Hilbert-Schmidt 范数，参考 Wikipedia 。 The norm can be defined in various ways: $$||A||_F=\sqrt{\sum_{i=1}^m\sum_{j=1}^n|a_{ij}|^2}=\sqrt{\text{trace}(A^\dagger A)}=\sqrt{\sum_{i=1}^{\min\lbrace m,n\rbrace}\sigma_i^2(A)}$$ where $A^\dagger$ denotes the conjugate transpose of $A$, and $\sigma_i(A)$ are the singular value of $A$. Frobenius 内积参考 Wikipedia 。 $$||A||_F=\sqrt{\langle A,A\rangle_F}$$ where the Frobenius inner product is defined by: $$\langle A,B\rangle_F=\sum_{i,j}\overline{A_{ij}}B_{ij}=\text{trace}(\overline{A^T}B)$$ Hadamard 乘积定义即 Hadamard matrices ，参考 Wikipedia https://en.wikipedia.org/wiki/Hadamard_product_(matrices) 。 For two matrices, $A, B$, of the same dimension, $m\times n$, the Hadamard product, $A\circ B$, is a matrix of the same dimension as the operands, with elements given by $$(A\circ B)_{i,j}=A_{i,j}B_{i,j}$$ The Hadamard division $A\oslash B$ is defined as: $$(A\oslash B)_{ij}=\frac{A_{ij}}{B_{ij}}$$ 性质 The Hadamard product is commutative, associative and distributive over addition, that is: $A\circ B=B\circ A$ $A\circ(B\circ C)=(A\circ B)\circ C$ $A\circ(B+C)=A\circ B+A\circ C$ For square matrices $A, B$, the row-sums of their Hadamard product are the diagonal elements of $AB^T$ or $B^TA$: $\sum_i(A\circ B)_{i,j}=(B^TA)_{j,j}$ $\sum_j(A\circ B)_{i,j}=(AB^T)_{i,i}$ Hilbert 矩阵定义参考 Wikipedia 。 In linear algebra, a Hilbert matrix is a square matrix with entries being the unit fractions: $$H_{ij}=\frac{1}{i+j-1}$$ For example, this is the $3\times 3$ Hilbert matrix: $$H=\left[\begin{array}{c} 1 &amp; \frac{1}{2} &amp; \frac{1}{3} \newline \frac{1}{2} &amp; \frac{1}{3} &amp; \frac{1}{4} \newline \frac{1}{3} &amp; \frac{1}{4} &amp; \frac{1}{5} \end{array}\right]$$ 应用The notoriously ill-conditioned Hilbert matrix can be defined as: $$J_{ij}:=\begin{cases} \frac{1}{i+j-1} &amp; \text{if }i\text{ mod }j=0\text{, or }j\text{ mod }i=0 \newline 0 &amp; \text{otherwise} \end{cases}$$ For example, if given by $n=5$, the matrix $J$ has the condition number of $4.9\times 10^3$. 矩阵的条件数矩阵 $A$ 的条件数（condition number）可定义为： $$\kappa(A)=||A||\cdot ||A^{-1}||$$ 如果方阵 $A$ 是奇异的，那么 $A$ 的条件数为正无穷大。实际上，每一个可逆方阵都存在一个条件数。 条件数是一个矩阵（或它所描述的线性系统）的稳定性或敏感度的度量。 A problem with a low condition number is said to be well-conditioned, while a problem with a high condition number is said to be ill-conditioned. 积分函数表参考 Wikipedia。 有理函数 指数函数 对数函数 三角函数 反三角函数 双曲函数 反双曲函数 另外，这里还有在线数学笔记。 Dirac comb 函数即 Shah 函数，参考 Wikipedia 。 在数学上，Dirac comb 即一个由 Dirac delta 函数构成的周期性调和分布（periodic tempered distribution）。也即电子工程中的脉冲序列（impulse train）或采样函数（sampling function）。 A Dirac comb is an infinite series of Dirac delta functions spaced at intervals of $T$. 函数表达式为： $$III_T(t)=\sum_{k=-\infty}^\infty \delta (t-kT)$$ 函数图像如下： Euclidean 距离 vs Manhattan 距离Euclidean 距离即欧几里德长度、毕达哥拉斯度量（Pythagorean metric）或 $L^2$ 距离，参考 Wikipedia 。 In mathemactics, the Euclidean distance is the “ordinary” straight-line distance between two points in Euclidean space. In Cartesian coordinates, if $\textbf p = (p_1, p_2, \ldots, p_n)$ and $\textbf q = (q_1, q_2, \ldots, q_n)$ are two points in Euclidean n-space, then the Euclidean distance from $\textbf p$ to $\textbf q$, or from $\textbf q$ to $\textbf p$ is given by the Pythagorean formula: $$ d (\textbf p, \textbf q) = d (\textbf q, \textbf p) = \sqrt{ \sum_{i = 1}^n (q_i - p_i)^2 } $$ Manhattan 距离即曼哈顿长度、出租车距离（taxicab metric / taxicab distance）、rectilinear distance、snake distance、city block distance 或 $L^1$ 距离，参考 Wikipedia 。 A taxicab geometry is form of geometry in which the distance between two points is the sum of the absolute differences of their Cartesian coordinates. The taxicab distance between two points, $\textbf p = (p_1, p_2, \ldots, p_n)$ and $\textbf q = (q_1, q_2, \ldots, q_n)$, in an n-dimensional space with fixed Cartesian coordinate system, is the sum of the lengths of the projections of the line segment between the points onto the coordinate axes: $$ d (\textbf p, \textbf q) = \lVert \textbf p - \textbf q \rVert_1 = \sum_{i = 1}^n \lvert p_i - q_i \rvert $$ 二者差异 In taxicab geometry, the red, yellow, and blue paths all have the same shortest path length of 12. In Euclidean geometry, the green line has length $ 6\sqrt{2} \approx 8.49 $ and is the unique shortest path. Monte Carlo 积分参考 Wikipedia 。 概述 In mathematics, Monte Carlo integration is a technique of numerical integration using random numbers. It is a particular Monte Carlo method that numerically computes a definite integral. This method is particularly useful for higher-dimensional integrals. Monte Carlo integration employs a non-deterministic approach: each realization provides a different outcome. In Monte Carlo, the final outcome is an approximation of the correct value with respective error bars, and the correct value is likely to be within those error bars. 公式化表达The problem Monte Carlo integration addresses is the computation of a multidimensional definite integral $$ I = \int_\Omega f(\mathbf x) d\mathbf x $$ where $\Omega$, a subset of $\mathbf R^m$, has volume $$ V = \int_\Omega d\mathbf x $$ The naive Monte Carlo approach is to sample points uniformly on $\Omega$: given $N$ uniform samples $\mathbf x_1, \mathbf x_2, \ldots, \mathbf x_N \in \Omega$, $I$ can be approximated by $$ I \approx Q_N \equiv V \frac{1}{N} \sum_{i = 1}^N f(\mathbf x_i) = V \langle f \rangle $$ This is because the law of large numbers ensures that $\lim_{N \rightarrow \infty} Q_N = I$. Heaviside 阶跃函数即单位阶跃函数，参考 Wikipedia。 概述The Heaviside step function, usually denoted by $H$ (but sometimes $u$), is a discontinuous function, whose value is zero for negative arguments and one for positive arguments. The Heaviside function can also be defined as the integral of the Dirac delta function: $$ H(x) = \int_{ - \infty}^x \delta(s) ds $$ 离散形式An alternative form of the unit step, as a function of a discrete variable $n$: $$ H[n] = \begin{cases} 0, &amp; n &lt; 0 \newline 1, &amp; n \geq 0 \end{cases} $$ or using the half-maximum convention: $$ H[n] = \begin{cases} 0, &amp; n &lt; 0 \newline \frac{1}{2}, &amp; n = 0 \newline 1, &amp; n &gt; 0 \end{cases} $$ where $n$ is an integer. The discrete-time unit impulse is the first difference of the discrete-time step $$ \delta[n] = H[n] - H[n - 1] $$ 多目标最优化即矢量最优化、Pareto 最优化、multicriteria 最优化或 multiattribute 最优化，参考 Wikipedia。 概述Multi-objectvie optimization is an area that is concerned with mathematical optimization problems involving more than one objective function to be optimized simultaneously, where optimal decisions need to be taken in the presence of trade-offs between two or more conflicting objectives. Pareto 解For a nontrivial multi-objective optimization problem, no single solution exists that simultaneously optimizes each objective. In that case, the objective functions are said to be conflicting, and there exists a (possibly infinite) number of Pareto optimal solutions. A solution is called nondominated or Pareto optimal solution, if none of the objective functions can be improved in value without degrading some of the other objective values. Without additional subjective preference information, all Pareto optimal solutions are considered equally good. Pareto 前沿 In mathematical terms, a feasible solution $x_1 \in X$ is said to (Pareto) dominate another solution $x_2 \in X$, if $$ \begin{cases} f_i(x_1) \leq f_i(x_2) &amp; \text{ for all indices } i \in {1, 2, \ldots, k} \newline f_j(x_1) &lt; f_j(x_2) &amp; \text{ for at least one index } j \in {1, 2, \ldots, k} \end{cases} $$ where $k \geq 2$ is the number of objectives. A solution $x_\ast \in X$ (and the corresponding outcome $f(x_\ast)$) is called Pareto optimal, if there does not exist another solution that dominates it. The set of Pareto optimal outcomes is called the Pareto front or Pareto boundary. Helmholtz 方程定义参考 Wikipedia。 In mathematics, the eigenvalue problem for the Laplace operator is known as the Helmholtz equation. It corresponds to the linear partial differential equation: $$ \nabla^2 f = - k^2 f $$ where $\nabla^2$ is the Laplace operator, $k^2$ is the eigenvalue, and $f$ is the eigenfunction. When the equation is applied to waves, $k$ is knows as the wave number. 波动方程对于声速恒为 $c$ 的均匀介质，由源 $f(\mathbf x_0, t)$ 激发的压力场 $p(\mathbf x, t)$ 满足声波波动方程 $$ \nabla^2 p(\mathbf x, t) - \frac{1}{c^2} \frac{\partial^2 p(\mathbf x, t)}{\partial t^2} = f(\mathbf x_0, t) $$ 转化到频率域即 $$ \nabla^2 P(\mathbf x, \omega) + \frac{\omega^2}{c^2} P(\mathbf x, \omega) = F(\mathbf x_0, \omega) $$ 也即 $$ \nabla^2 P + k^2 P = F $$ 其中 $k = \omega / c$ 为波数。 Green 函数参考 Wikipedia。 非均匀 Helmholtz 方程（Inhomogeneous Helmholtz equation）的 Green 函数满足： $$ \nabla^2 G(x) + k^2 G(x) = - \delta(x) \in \mathbb{R}^n $$ 其解为： $$ G(x) = \begin{cases} \frac{i e^{i k |x|}}{2 k}, &amp; n = 1 \newline \frac{i}{4} H_0^{(1)}(k |x|), &amp; n = 2 \newline \frac{e^{i k |x|}}{4 \pi |x|}, &amp; n = 3 \newline\end{cases} $$ 其中 $H_0^{(1)}$ 为第一类零阶 Hankel 函数。 特殊矩阵Toeplitz 矩阵参考 Wikipedia。 In linear algebra, a Toeplitz matrix or diagonal-constant matrix is a matrix in which each descending diagonal from left to right is constant. A Toeplitz matrix $ \mathbf A $ by $ n \times n $ is of the form $$ \mathbf A = \begin{bmatrix} a_0 &amp; a_{ - 1} &amp; a_{ - 2} &amp; \cdots &amp; \cdots &amp; a_{ - (n - 1)} \newline a_1 &amp; a_0 &amp; a_{ - 1} &amp; \ddots &amp; \ddots &amp; \vdots \newline a_2 &amp; a_1 &amp; \ddots &amp; \ddots &amp; \ddots &amp; \vdots \newline \vdots &amp; \ddots &amp; \ddots &amp; \ddots &amp; a_{ - 1} &amp; a_{ - 2} \newline \vdots &amp; \ddots &amp; \ddots &amp; a_1 &amp; a_0 &amp; a_{ - 1} \newline a_{n - 1} &amp; \cdots &amp; \cdots &amp; a_2 &amp; a_1 &amp; a_0 \newline\end{bmatrix} $$ If the $ i, j $ element of $ \mathbf A $ is denoted $ A_{i, j} $, then $ A_{i, j} = A_{i + 1, j + 1} = a_{i - j}$. A Toeplitz matrix is not necessarily square. Hankel 矩阵参考 Wikipedia。 In linear algebra, a Hankel matrix or catalecticant matrix is a square matrix in which each ascending skew-diagonal from left to right is constant. A Hankel matrix $ \mathbf A $ by $ n \times n $ is of the form $$ \mathbf A = \begin{bmatrix} a_0 &amp; a_1 &amp; a_2 &amp; \cdots &amp; \cdots &amp; a_{n - 1} \newline a_1 &amp; a_2 &amp; a_3 &amp; \ddots &amp; \ddots &amp; \vdots \newline a_2 &amp; a_3 &amp; \ddots &amp; \ddots &amp; \ddots &amp; \vdots \newline \vdots &amp; \ddots &amp; \ddots &amp; \ddots &amp; a_{2n - 5} &amp; a_{2n - 4} \newline \vdots &amp; \ddots &amp; \ddots &amp; a_{2n - 5} &amp; a_{2n - 4} &amp; a_{2n - 3} \newline a_{n - 1} &amp; \cdots &amp; \cdots &amp; a_{2n - 4} &amp; a_{2n - 3} &amp; a_{2n - 2} \newline\end{bmatrix} $$ If the $ i, j $ element of $ \mathbf A $ is denoted with $ A_{i, j} $, and assuming $ i \le j $, then $ A_{i, j} = A_{i + k, j - k} $ for all $ k = 0, 1, \ldots, j - i $. 循环矩阵即 circulant matrix，参考 Wikipedia。 In linear algebra, a circulant matrix is a square matrix in which each row vector is rotated one element to the right relative to the preceding row vector. A circulant matrix $ \mathbf A $ by $ n \times n $ is of the form $$ \mathbf A = \begin{bmatrix} a_0 &amp; a_{n - 1} &amp; a_{n - 2} &amp; \cdots &amp; a_2 &amp; a_1 \newline a_1 &amp; a_0 &amp; a_{n - 1} &amp; \ddots &amp; \ddots &amp; a_2 \newline a_2 &amp; a_1 &amp; \ddots &amp; \ddots &amp; \ddots &amp; \vdots \newline \vdots &amp; \ddots &amp; \ddots &amp; \ddots &amp; a_{n - 1} &amp; a_{n - 2} \newline a_{n - 2} &amp; \ddots &amp; \ddots &amp; a_1 &amp; a_0 &amp; a_{n - 1} \newline a_{n - 1} &amp; a_{n - 2} &amp; \cdots &amp; a_2 &amp; a_1 &amp; a_0 \newline\end{bmatrix} $$ Vandermonde 矩阵参考 Wikipedia。 In linear algebra, a Vandermonde matrix is a matrix with the terms of a geometirc progression in each row. A Vandermode matrix $ \mathbf A $ by $ m \times n $ is of the form $$ \mathbf A = \begin{bmatrix}1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^{n - 1} \newline1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^{n - 1} \newline\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \newline1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^{n - 1} \newline\end{bmatrix} $$ If the $ i, j $ element of $ \mathbf A $ is denoted with $ A_{i, j} $, then $ A_{i, j} = a_i^{j - 1} $. Cauchy 矩阵参考 Wikipedia。 In mathematics, a Cauchy matirx is an $ m \times n $ matrix with element $ a_{ij} $ in the form $$ a_{ij} = \frac{1}{x_i - y_j}; x_i - y_j \ne 0, 1 \le i \le m, 1 \le j \le n $$ where $ x_i $ and $ y_j $ are elements of a field $ \mathcal F $. Every submatrix of a Cauchy matrix is itself a Cauchy matrix. 交换矩阵即 exchange matrix，参考 Wikipedia。 In mathematics, especially linear algebra, an exchange matrix (also called the reversal matrix, backward identity, or standard involutory permutation) is a matrix where the 1 element resides on the counterdiagonal and all other elements are zero. An exchange matrix $ \mathbf A $ by $ n \times n $ is of the form $$ \mathbf A = \begin{bmatrix} 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 1 \newline 0 &amp; \ddots &amp; \ddots &amp; 0 &amp; 1 &amp; 0 \newline \ldots &amp; \ddots &amp; \ddots &amp; \ddots &amp; 0 &amp; 0 \newline 0 &amp; 0 &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ldots \newline 0 &amp; 1 &amp; 0 &amp; \ddots &amp; \ddots &amp; 0 \newline 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \newline\end{bmatrix} $$ If the $ i, j $ element of $ \mathbf A $ is denoted with $ A_{i, j} $, then $$ A_{i, j} = \begin{cases} 1, &amp; j = n - i + 1 \newline 0, &amp; j \ne n - i + 1 \newline\end{cases} $$]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Hilbert</tag>
        <tag>Kronecker</tag>
        <tag>Frobenius</tag>
        <tag>Hadamard</tag>
        <tag>Condition number</tag>
        <tag>Dirac</tag>
        <tag>Euclidean</tag>
        <tag>Manhattan</tag>
        <tag>Monte Carlo</tag>
        <tag>Heaviside</tag>
        <tag>Pareto</tag>
        <tag>Helmholtz</tag>
        <tag>Toeplitz</tag>
        <tag>Hankel</tag>
        <tag>Vandermonde</tag>
        <tag>Cauchy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些算法原理]]></title>
    <url>%2F2018%2F07%2F22%2FPrinciple-of-Algorithm%2F</url>
    <content type="text"><![CDATA[BFGS 算法也即 Broyden-Fletcher-Goldfarb-Shanno 算法。参考 Wikipedia 。 基本原理The search direction at stage $k$ is given by the Newton method: $$p_k=-B_k\nabla f(x_k)$$ where $B_k$ is an approximation of the Hessian matrix, and $\nabla f(x_k)$ is the gradient of the function at $x_k$ The quasi-Newton condition imposed on the update of $B_k$ is: $$B_{k+1}(x_{k+1}-x_k)=\nabla f(x_{k+1})-\nabla f(x_k)$$ Let $y_k=\nabla f(x_{k+1})-\nabla f(x_k)$ and $s_k=x_{k+1}-x_k$, then $B_{k+1}s_k=y_k$ which is the secant equation. The curvature condition $s_k^Ty_k&gt;0$ should be satisfied. In the BFGS method, instead of requiring the full Hessian matrix at $x_{k+1}$ to be computed, the approximate Hessian is given by: $$B_{k+1}=B_k+\frac{y_ky_k^T}{y_k^Ts_k}-\frac{B_ks_ks_k^TB_k}{s_k^TB_ks_k}$$ $$B_{k+1}^{-1}=\left(I-\frac{s_ky_k^T}{y_k^Ts_k}\right)B_k^{-1}\left(I-\frac{y_ks_k^T}{y_k^Ts_k}\right)+\frac{s_ks_k^T}{y_k^Ts_k}$$ or $$B_{k+1}^{-1}=B_k^{-1}+\frac{(s_k^Ty_k+y_k^TB_k^{-1}y_k)(s_ks_k^T)}{(s_k^Ty_k)^2}-\frac{B_k^{-1}y_ks_k^T+s_ky_k^TB_k^{-1}}{s_k^Ty_k}$$ 算法步骤From an initial guess $x_0$ and an approximate Hessian matrix $B_0$ (generally the identity matrix), the following steps are repeated as $x_k$ converges to the solution: Obtain a direction: $p_k=-B_k^{-1}\nabla f(x_k)$; Perform a line search to find an acceptable stepsize $\alpha_k$ in the direction found in the first step; Set $s_k=\alpha_kp_k$ and update $x_{k+1}=x_k+s_k$; $y_k=\nabla f(x_{k+1})-\nabla f(x_k)$; $B_{k+1}=B_k+\frac{y_ky_k^T}{y_k^Ts_k}-\frac{B_ks_ks_k^TB_k}{s_k^TB_ks_k}$. 固定点迭代法固定点（Fixed point）参考 Wikipedia https://en.wikipedia.org/wiki/Fixed_point_(mathematics) 。 Not to be confused with a stationary point where $f’(x)=0$ . In mathematics, $c$ is a fixed point of the function $f(x)$ if $f(c) = c$. Points that come back to the same value after a finite number of iterations of the function are called periodic points. A fixed point is a periodic point with period equal to one. 固定点迭代定义参考 Wikipedia 。 In numerical analysis, given a function $f$ defined on the real number with real values and given a point $x_0$ in the domain of $f$, the fixed point iteration is $$x_{n+1}=f(x_n), n=0,1,2,…$$ 应用Newton’s method for finding roots of a given differentiable function $f(x)$ is $$x_{n+1}=x_n-\frac{f(x_n)}{f’(x_n)}$$ If we write $g(x)=x-\frac{f(x)}{f’(x)}$, we may rewrite the Newton iteration as $$x_{n+1}=g(x_n)$$ If this iteration converges to a fixed point $x$ of $g$, then $$x=g(x)=x-\frac{f(x)}{f’(x)}$$ so that $$\frac{f(x)}{f’(x)}=0$$ The reciprocal of anything is nonzero, therefore $f(x)=0$: $x$ is a root of $f$. 非线性共轭梯度法参考 Wikipedia 。 In numerical optimization, the nonlinear conjugate gradient method generalizes the conjugate gradient method to nonlinear optimization. 线性共轭梯度法For a quadratic function $$f(x)=||Ax-b||^2$$ the minimum of $f$ is obtained when the gradient $\nabla_x f=2A^T(Ax-b)=0$. Linear conjugate gradient seeks a solution to the linear equation $A^T Ax=A^T b$. 非线性共轭梯度法The nonlinear conjugate gradient method is generally used to find the local minimum of a nonlinear function using its gradient $\nabla_x f$ alone. 算法步骤Given a function $f(x)$, one simply starts in the steepest descent direction: $$\Delta x_0=-\nabla_x f(x_0)$$ with an step length $\alpha$, and preforms a line search: $$\alpha_0:=\text{argmin}_\alpha f(x_0+\alpha\Delta x_0)$$ $$x_1=x_0+\alpha_0\Delta x_0$$ After the first iteration in $\Delta x_0$, the following steps continue along a subsequent conjugate direction $s_n$, where $s_0=\Delta x_0$: Calculate the steepest direction: $\Delta x_n=-\nabla_x f(x_n)$; Compute $\beta_n$ according to one of the formulas below; Update the conjugate direction: $s_n=\Delta x_n+\beta_n s_{n-1}$; Perform a line search: optimize $\alpha_n=\text{argmin}_\alpha f(x_n+\alpha s_n)$; Update: $x_{n+1}=x_n+\alpha_n s_n$. Subsequent search directions lose conjugacy requiring the search direction to be reset to the steepest descent direction at least every $N$ iterations, or sooner if progress stops. $\beta_n$ 的计算Four of the best known formulas for $\beta_n$ are named after their developers: Fletcher-Reeves: $\beta_n^{FR}=\frac{\Delta x_n^T \Delta x_n}{\Delta x_{n-1}^T \Delta x_{n-1}}$; Polak-Ribiere: $\beta_n^{PR}=\frac{\Delta x_n^T (\Delta x_n-\Delta x_{n-1})}{\Delta x_{n-1}^T \Delta x_{n-1}}$; Hestenes-Stiefel: $\beta_n^{HS}=-\frac{\Delta x_n^T (\Delta x_n-\Delta x_{n-1})}{s_{n-1}^T (\Delta x_n-\Delta x_{n-1})}$; Dai-Yuan: $\beta_n^{DY}=-\frac{\Delta x_n^T \Delta x_n}{s_{n-1}^T (\Delta x_n-\Delta x_{n-1})}$. A popular choice is $\beta=\max\lbrace 0,\beta^{PR}\rbrace$, which provides a direction reset automatically. 邻域算法邻域算法（Neighborhood Algorithm）是由 (Sambridge, 1999) 引入到地球物理反演的应用中的。在该文中，作者发出了灵魂拷问： How can a search for new models be best guided by all previous models for which the forward problem has been solved (and hence the data-misfit value evaluated) ? 邻域算法采用简单的几何概念指导参数空间中的模型搜索，是一种非线性的无导数反演方法 (Peyrat and Olsen, 2004) 。 Voronoi 图参考 Wikipedia 。 In mathematics, a Voronoi diagram is a partition of a plane into regions close to each of a given set of objects. Let $X$ be a metric space with distance function $d$. Let $K$ be a set of indices and let $(P_k)_{k \in K}$ be a tuple (ordered collection) of nonempty subsets (the sites) in the space $X$. The Voronoi cell, or Voronoi region, $R_k$, associated with the site $P_k$ is the set of all points in $X$ whose distance to $P_k$ is not greater than their distance to the other sites $P_j$, where $j$ is any index different from $k$: $$ R_k = { x \in X \vert d(x, P_k) \leq d(x, P_j) \text{ for all } j \neq k } $$ 算法步骤The Neighborhood Algorithm can be summarized as follows (Sambridge, 1999): Generate an initinal set of $n_s$ models uniformly in parameter space; Calculate the misfit function for the most recently generated set of $n_s$ models, and determine the $n_r$ models with the lowest misfit of all models generated so far; Generate $n_s$ new models by perfoming a uniform random walk in the Voronoi cell of each of the $n_r$ chosen models (i.e., $n_s/n_r$ samples in each cell); Go to step 2. 首先，在一个预定义的模型空间中随机生成 $n_s$ 个模型（即 Voronoi 中心），并计算出这些模型的目标函数值。接着，根据定义的距离测量公式构建出 Voronoi 元胞（Voronoi cell），赋予元胞中每个点与 Voronoi 中心相同的目标函数值。在这个过程中，我们实质上生成了一组等目标函数面。从目前生成的这 $n_s$ 个模型中，选出误差最小的 $n_r$ 个模型，去掉剩下的 $(n_s - n_r)$ 个模型。现在，在这 $n_r$ 个 Voronoi 元胞中，每个元胞生成 $n_s/n_r$ 个新模型，总共产生 $n_s$ 个新模型。再次，选出 $n_r$ 个误差最小的模型，去掉剩下的 $(n_s - n_r)$ 个模型。重复以上过程直到满足预定义的收敛条件。（本段译自：Global Optimization Methods in Geophysical Inversion，第二版，6.1.3 小节） 算法优点According to the section 6.1.3 of Global Optimization Methods in Geophysical Inversion (2nd edition, Sen and Stoffa, 2013), following are the advantages of the Neighborhood Algorithm: It uses previous smaples to determine the next step of the search, or in other words, the algorithm is self-adaptive. The algorithm requires only two tuning parameters, namely, $n_s$ and $n_r$. The process generates an ensemble of models with low misfit values; thus the method can be used for uncertainty quantification as well. 根据 (Peyrat and Olsen, 2004)：（1）在迭代中，新模型只在上一步误差最小的若干个模型的 Voronoi 元胞中产生，因此邻域算法比蒙特卡罗算法具有更少的计算消耗；（2）与遗传算法和模拟退火算法相比，在模型搜索中邻域算法仅需要两个控制参数，需要更少的主观“指导”。 Householder 方法参考 Wikipedia。 概述In mathematics, Householder’s methods are a class of root-finding algorithms that are used for functions of one real variable with continuous derivatives up to some order $d + 1$. Each of these methods is characterized by the number $d$, which is known as the order of the method. The algorithm is iterative and has a rate of convergence of order $d + 1$. 方法论For solving the nonlinear equation $f(x) = 0$, Householder’s method consists of a sequence of iterations: $$ x_{n + 1} = x_n + d \frac{ (1/f)^{(d - 1)} (x_n) }{ (1/f)^{(d)} (x_n) } $$ beginning with an initial guess $x_0$. 低阶方法一阶：Newton 方法Since $$ (1/f)(x) = \frac{1}{f(x)} \quad\text{ and }\quad (1/f)’(x) = - \frac{f’(x)}{f(x)^2} $$ result in $$ x_{n + 1} = x_n + 1 \cdot \frac{(1/f)(x_n)}{(1/f)’ (x_n)} = x_n - \frac{f(x_n)}{f’(x_n)} $$ 二阶：Halley 方法Since $$ (1/f)’(x) = - \frac{f’(x)}{f(x)^2} \quad\text{ and }\quad (1/f)’’(x) = - \frac{f’’(x)}{f(x)^2} + 2 \cdot \frac{f’(x)^2}{f(x)^3} $$ result in $$ x_{n + 1} = x_n + 2 \cdot \frac{ (1/f)’ (x_n) }{ (1/f)’’ (x_n) } = x_n - \frac{ 2 f(x_n) f’(x_n) }{ 2 f’(x_n)^2 - f(x_n) f’’(x_n) } $$ The following alternative formulation shows the similarity between Halley’s method and Newton’s method. The expression $f(x_n)/f’(x_n)$ is computed only once, and it is particularly useful when $f’’(x_n)/f’(x_n)$ can be simplified: $$ x_{n + 1} = x_n - \frac{f(x_n)}{f’(x_n)} \left[ 1 - \frac{f(x_n)}{f’(x_n)} \cdot \frac{f’’(x_n)}{2 f’(x_n)} \right]^{ - 1} $$ When the second derivative is very close to zero, the Halley’s method iteration is almost the same as the Newton’s method iteration.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>BFGS</tag>
        <tag>Fixed point</tag>
        <tag>Conjugate gradient</tag>
        <tag>NA</tag>
        <tag>Householder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器管理]]></title>
    <url>%2F2018%2F07%2F21%2FTips-of-Server%2F</url>
    <content type="text"><![CDATA[dd 命令刻录系统启动盘若系统已自动挂载 U 盘，可以命令 [root@A ~]$ fdisk -l 查看 U 盘挂载设备号，如 /dev/sdb，但由于 Linux 中每个设备文件可能对应多个设备号，如主/次设备号，实际自动挂载的可能只是其中的一个设备号，如 /dev/sdb1，再以命令 [root@A ~]$ umount /dev/sdb1 卸载 U 盘；若系统未自动挂载 U 盘，同样可由 fdisk 命令查看 U 盘对应的设备号，如 /dev/sdb； 以命令 [root@A ~]$ mkfs.vfat /dev/sdb -I 格式化 U 盘； 最后以命令 [root@A ~]$ dd if=~/CentOS-7-x86_64-Minimal-xxxx.iso of=/dev/sdb 即可将 ~/CentOS-7-x86_64-Minimal-xxxx.iso 系统文件内容刻录入设备 /dev/sdb 对应的 U 盘。 系统安装注意事项安装程序引导错误在安装 CentOS 7.x 系统时，可能出现报错 “No controller found”，无法继续安装进程，此为安装程序引导错误。此时，可按下 Ctrl + Alt + Delete 组合键重启机器。待重新进入 “Install CentOS 7” 等安装选项选择界面时，按方向键选择该选项后按下 e 键，进入选项编辑页面，将该页面中的 “LABEL=CentOS\x207\x20x86_64” 修改为 “LABEL=CentOS\x207\x20x8” 后按下 Ctrl + x 组合键，而后安装程序仍会报告上述错误，但可继续进入后序安装进程，自此即可正常安装系统了。 系统目录空间配置考虑到在使用过程中，计算节点的 /home 目录需由主节点的 /home 目录远程挂载而来，其原始 /home 目录无法被用户使用，可在安装系统时，将 /home 目录的空间设置小些，而将系统根目录设置得适当大些。 针对当前需求，推荐的手动分区目录配置为： /home: 50 GiB /boot: 1 GiB /boot/efi: 200 MiB swap: 48 GiB 剩余空间均分配给根目录 / 即可。 SSH 免密登录以下实现主机 A 到主机 B 的免密登录： 在主机 A 下生成公钥/私钥对：执行 [user@A ~]$ ssh-keygen -t rsa 后，连按三次回车键即可。 把主机 A 下生成的公钥复制远程传输到主机 B 上，并添加到其 $HOME/.ssh/authorized_keys 文件中：执行 [user@A ~]$ ssh-copy-id -i .ssh/id_rsa.pub user@B 即可。 注：设置主机 B 上的 $HOME/.ssh/authorized_keys 文件权限为 600 。 设置系统免密登录以命令 [root@A ~]$ systemctl stop firewalld.service 关闭防火墙；以命令 [root@A ~]$ systemctl disable firewalld.service 禁用防火墙。 以命令 [root@A ~]$ setenforce 0 关闭 SELinux；修改 /etc/selinux/config 文件：SELINUX=disabled， 以禁用 SELinux 。 CentOS minimal 首次安装后连接网络CentOS minimal 首次初始安装后是无法自动成功联网的，需手动配置网卡。即进入目录 /etc/sysconfig/network-scripts，对于多网口的机器，在该目录下会存在多个以 ifcfg- 开头的配置文件，在修改除 ifcfg-lo 以外的其他配置文件中的 ONBOOT 选项为 yes 后重启机器即可。 安装 EPEL 源EPEL，即 Extra Packages for Enterprise Linux，是为企业级 Linux 提供的一组高质量的额外软件包。 命令 [root@A ~]$ yum install epel-release 安装 rpm 包，命令 [root@A ~]$ yum clean all &amp;&amp; yum makecache 更新软件源。 安装 ELRepo 源ELRepo 包含了一些硬件相关的驱动程序，比如显卡、声卡驱动。可以如下命令进行安装： 12[root@A ~]$ rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org[root@A ~]$ rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm 注意将第二条命令中的版本号 7.0-2 修改为自己机器相应的数字。 安装 Nux Dextop 源Nux Dextop 是类似 CentOS、RHEL、ScientificLinux 等的第三方 RPM 仓库。Nux Dextop 库依赖于 EPEL 库，所以要先安装 EPEL 库。可通过如下命令进行安装： 12[root@A ~]$ rpm -v --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro[root@A ~]$ rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-5.el7.nux.noarch.rpm 由于 Nux Dextop 仓库可能会与其他第三方库有冲突，所以建议默认情况下禁用该仓库，即将文件 /etc/yum.repos.d/nux-dextop.repo 中的 enable=1 全部修改为 enabled=0 便可。 如需调用 Nux Dextop 仓库，可显式启用该仓库，如可以命令 [root@A ~]$ yum --enablerepo=nux-dextop install fuse-exfat 调用该仓库安装 fuse-exfat。 系统软件安装必要安装 gcc-gfortran: [root@A ~]$ yum install gcc-gfortran gcc-c++: [root@A ~]$ yum install gcc-c++.x86_64 autojump: 命令 [root@A ~]$ yum install autojump 安装，命令 [root@A ~]$ yum install autojump-zsh.noarch 添加对 zsh 的支持。 HDF5 库：[root@A ~]$ yum install hdf5-devel htop: [root@A ~]$ yum install htop vim: [root@A ~]$ yum install vim tmux: [root@A ~]$ yum install tmux iostat: [root@A ~]$ yum install sysstat.x86_64 locate: [root@A ~]$ yum install mlocate zsh: [root@A ~]$ yum install zsh fc-list: [root@A ~]$ yum install fontconfig 可选安装 Xpm 库：[root@A ~]$ yum install libXpm-devel.x86_64 ifconfig: [root@A ~]$ yum install net-tools.x86_64 GNU Parallel: [root@A ~]$ yum install parallel.noarch eog: [root@A ~]$ yum install eog.x86_64 Xt 库：[root@A ~]$ yum install libXt-devel.x86_64 xauth: [root@A ~]$ yum install xauth （当 ssh -X 远程登录报错 X11 forwarding request failed on channel 0 时） xwindow 图形界面：[root@A ~]$ yum -y groupinstall &quot;X Window System&quot; GNU m4 宏处理器：[root@A ~]$ yum install m4.x86_64 ghostscript: [root@A ~]$ yum install ghostscript.x86_64 mail: [root@A ~]$ yum install mailx GFortran 静态库： [root@A ~]$ yum install libgfortran-static ntfs 磁盘格式支持: [root@A ~]$ yum install ntfs-3g exfat 磁盘格式支持: [root@A ~]$ yum install fuse-exfat（需先安装 Nux Dextop 软件源） GPU 节点安装 nl 库：[root@A ~]$ yum install libnl-devel.x86_64 修改主机名hostnamectl set-hostname seislab 命令修改主机名为 seislab 。 修改系统时区先用 timedatectl set-timezone Asia/Shanghai 命令更新时区为亚洲上海时区，再用 timedatectl set-local-rtc 1 命令将硬件时钟与系统时钟调整一致。 添加用户到 sudoer 列表以下实现将 user 用户添加到 sudoer 列表： 进入 root 账户，在命令行键入：[root@A ~]$ visudo，打开 sudoer 的配置文件。 向下查找到 root ALL=(ALL) ALL 内容行，在下一行参照新建行内容 user ALL=(ALL) ALL，保存后退出。 挂载本地磁盘查看本地已挂载磁盘文件系统格式以命令 [root@A ~]$ cat /etc/fstab 查看本地已挂载磁盘文件系统格式，如 ntfs 或 ext4 等。 格式化本地磁盘命令 [root@A ~]$ mkfs -t ext4 /dev/sdb 以 ext4 文件格式格式化本地磁盘 /dev/sdb。 挂载本地磁盘命令 [root@A ~]$ mount /dev/sdb /shdisk/lab 将本地磁盘 /dev/sdb 挂载至 /shdisk/sdb 目录下。 开机自动挂载 假以命令 [root@A ~]$ blkid 查看到本地磁盘 /dev/sdb 的 UUID（即 Universally Unique IDentifier，通用唯一识别符）值为 b0c3c256-60de-47d7-b10a-674b86bdc913，及其 Type（即文件系统类型）值为 ext4； 以 root 身份打开并在文件 /etc/fstab 中添加行内容「 UUID=b0c3c256-60de-47d7-b10a-674b86bdc913 /shdisk/sdb ext4 defaults 0 0 」即可实现，在系统开机后，自动将本地磁盘 /dev/sdb 挂载至 /shdisk/sdb 目录下。 挂载 ntfs 硬盘并指定访问权限CentOS 系统默认不支持 ntfs 文件系统，需先行以命令 [root@A ~]$ yum install ntfs-3g 安装额外驱动 ntfs-3g。 若需指定挂载目录为 GID 为 1005 的用户组和 UID 为 1010 的用户所有，且访问权限为 750，则可以如下命令将硬盘 /dev/sdb 挂载在目录 /data 下： 1[root@A ~]$ mount -t ntfs -o rw,auto,umask=027,uid=1010,gid=1005 /dev/sdb /data 其中，访问权限设置选项 umask 采用八进制记法，对应关系如下： Octal Binary Permission 0 000 rwx 1 001 rw- 2 010 r-x 3 011 r– 4 100 -wx 5 101 -w- 6 110 –x 7 111 — 如设置访问权限为 750，即 -rwxr-x—，则应取 umask=027。 挂载远程目录以主机 B（ip 为 192.18.1.2）挂载远程主机 A（ip 为 192.18.1.1）的共享目录 /data/share 为例： 服务端 [root@A ~]$ yum install nfs-utils rpcbind 安装 nfs-utils 和 rpcbind 服务； [root@A ~]$ chkconfig nfs on 设置 nfs 服务开机自启，[root@A ~]$ chkconfig rpcbind on 设置 rpcbind 服务开机自启； [root@A ~]$ service rpcbind start 启动 rpcbind 服务，[root@A ~]$ service nfs start 启动 nfs 服务，注意这两条命令的执行顺序； 在文件 /etc/exports 中添加内容 /data/share 192.18.1.2(rw,no_root_squash,no_subtree_check) ； [root@A ~]$ exportfs -a 使配置文件生效； [root@A ~]$ showmount -e 查看是否共享成功。 客户端 [root@B ~]$ yum install nfs-utils rpcbind 安装 nfs-utils 和 rpcbind 服务； [root@A ~]$ chkconfig nfs on 设置 nfs 服务开机自启，[root@A ~]$ chkconfig rpcbind on 设置 rpcbind 服务开机自启； [root@A ~]$ service rpcbind start 启动 rpcbind 服务，[root@A ~]$ service nfs start 启动 nfs 服务，注意这两条命令的执行顺序； [root@B ~]$ showmount -e 192.18.1.1 查看是否检测到服务端的共享 [root@B ~]$ mkdir /data/share 创建映射目录； 在文件 /etc/fstab 中添加内容 192.18.1.1:/data/share /data/share nfs rw,defaults 0 0 ； 当前启动下，执行手动挂载 [root@B ~]$ mount -t nfs 192.18.1.1:/data/share /data/share 。 常见问题 若出现由于服务端偶然宕机而导致客户端执行 df 或 ls 等与远程挂载目录相关的操作时终端卡死的情况，可以在服务端依次执行如下命令手动重启 rpcbind 和 nfs 服务解决： 1234[root@A ~]$ service rpcbind stop[root@A ~]$ service nfs stop[root@A ~]$ service rpcbind start[root@A ~]$ service nfs start 有时候使用命令 [root@A ~]$ service rpcbind restart &amp;&amp; service nfs restart 重启服务也可解决该问题。 若在上一问题中，服务端暂时无法登陆，则在客户端以命令 [root@A ~]$ umount -fl /data/share 强制卸载该远程目录即可（ -f 即强制卸载；-l 为延迟卸载。仅 -f 可能提示目录繁忙，-l 即等待目录不繁忙时再卸载）。 若在服务端启动 nfs 服务时出现问题，有可能是该服务节点的本地磁盘未挂载，可手动挂载后再重新启动 nfs 服务。 若远程挂载过程中出现 mount.nfs: access denied by server while mounting (null) 告警，可能是先前自动挂载失败导致的，需先 umount 掉该挂载目录后再重新尝试远程挂载。 若在挂载远程目录时，出现 mount.nfs: requested NFS version or transport protocol is not supported 告警时，可能是由于远程服务器的 nfs 服务未正常启动，可登陆至目标服务器上进行 nfs 服务重启。若重启失败并报错 “A dependency job for nfs-server.service failed. See ‘journalctl -xe’ for details.”，则可以命令 [root@A ~]$ journalctl -xe 查看出错原因。若发现本地磁盘自动挂载失败，则重新手动挂载该磁盘后再重启 nfs 服务即可。 安装 Pbs Pro 作业调度系统准备机器假设如下两台机器（CentOS 7 系统）： 主机名 主机 IP pbsmaster 192.18.1.1 pbsslave 192.18.1.2 修改两台机器的 /etc/hosts 文件，确保两台机器可以 ssh 互相访问。 安装包此处下载安装包 pbspro-14.1.0.tar.gz 。 制作 RPM 包先提前安装依赖包： 123$ yum -y install rpm-build$ yum -y install gcc autoconf automake libtool hwloc-devel$ yum -y install libX11-devel libXt-devel libedit-devel libical-devel ncurses-devel postgresql-devel python-devel python-devel tcl-devel tk-devel swig expat-devel openssl-devel libXext libXft 执行以下命令，在 /root/rpmbuild/RPMS/x86_64 目录下生成 pbspro-[ client | debuginfo | execution | server ]-14.1.0-0.x86_64.rpm 包： 1234$ mkdir -p /root/rpmbuild/SOURCES/$ mv pbspro-14.1.0.tar.gz /root/rpmbuild/SOURCES/$ cd /root/rpmbuild/SOURCES &amp;&amp; tar zxvf pbspro-14.1.0.tar.gz$ cd /root/rpmbuild/SOURCES/pbspro-14.1.0 &amp;&amp; rpmbuild -ba pbspro.spec 安装安装 Master登录至 Master 节点，命令 [root@pbsmaster /root/rpmbuild/RPMS/x86_64]$ yum install -y pbspro-server-14.1.0-0.x86_64.rpm （或者 [root@pbsmaster /root/rpmbuild/RPMS/x86_64]$ rpm -ivh pbspro-server-14.1.0-0.x86_64.rpm ）安装作业调度系统，修改 /etc/pbs.conf 文件： 12PBS_SERVER=pbsmasterPBS_START_MOM=1 安装 Slave登录至 Slave 节点，命令 [root@pbsslave /root/rpmbuild/RPMS/x86_64]$ yum install -y pbspro-execution-14.1.0-0.x86_64.rpm （或者 [root@pbsslave /root/rpmbuild/RPMS/x86_64]$ rpm -ivh pbspro-execution-14.1.0-0.x86_64.rpm ）安装作业调度系统，修改 /etc/pbs.conf 文件： 12PBS_SERVER=pbsmasterPBS_START_MOM=1 修改 /var/spool/pbs/mom_priv/config 文件： 12$clienthost pbsmaster$restrict_user_maxsysid 999 启动 pbs以命令 $ /etc/init.d/pbs start 分别在 pbsmaster 和 pbsslave 节点上启动 pbs，以命令 [root@pbsmaster ~]$ qmgr -c &#39;create node pbsslave&#39; 在 pbsmaster 主节点上将 pbsslave 节点加入集群。 PBS Pro 队列管理PBS 队列主要分为两种：路由队列（route）和执行队列（execution）。前者只用于向其他队列移动作业（move jobs）；后者用于运行作业。 以下示例中，以 pbsmaster 为 PBS 主节点。 创建队列以如下命令创建一个执行队列 exec_queue： 1234[root@pbsmaster ~]$ qmgr -c 'create queue exec_queue'[root@pbsmaster ~]$ qmgr -c 'set queue exec_queue queue_type = execution'[root@pbsmaster ~]$ qmgr -c 'set queue exec_queue enabled = True'[root@pbsmaster ~]$ qmgr -c 'set queue exec_queue started = True' 如果要创建一个路由队列，设置 queue_type = route 即可。另外，设置 enable = True 表示允许该队列接收作业，设置 started = True 表示允许该队列里的作业执行。 可以命令 [root@pbsmaster ~]$ qmgr -c &#39;delete queue exec_queue&#39; 删除已创建的队列 exec_queue。 创建节点以命令 [root@pbsmaster ~]$ qmgr -c &#39;create node vnode1&#39; 创建一个节点 vnode1。 以命令 [root@pbsmaster ~]$ qmgr -c &#39;delete node vnode1&#39; 删除已创建的节点 vnode1。 以命令 [root@pbsmaster ~]$ qmgr -c &#39;set node vnode1 queue = exec_queue&#39; 将已创建的节点 vnode1 添加到已创建的队列 exec_queue 中。 记录配置以如下命令将当前 PBS 配置导出到 /tmp/ 目录下： 12[root@pbsmaster ~]$ qmgr -c 'print server' &gt; /tmp/server.out[root@pbsmaster ~]$ qmgr -c 'print node @default' &gt; /tmp/nodes.out 可以如下命令从 /tmp/ 目录下读取并重新配置 PBS 队列： 12[root@pbsmaster ~]$ qmgr &lt; /tmp/server.out[root@pbsmaster ~]$ qmgr &lt; /tmp/nodes.out 安装并配置 InfiniBand事前准备首先，在官网下载系统对应版本的驱动安装包（ tgz 压缩包即可）。注意操作系统子版本号和机器架构的选择。在下载页面底部，勾选接受 EULA 协议之后方可开始下载。 再以命令 [root@A ~]$ lspci | grep Mellanox 验证主机是否已安装 Mellanox 网络适配器 HCA/NIC，若屏幕输出 102:00.0 Infiniband controller: Mellanox Technologies MT27800 Family [ConnectX-5] 类似内容即表示该网络适配器已正确安装。若此处验证失败，则后序启动子网管理器 opensmd 也将失败，且通过命令 ip address 亦不能看到名称为 ib0 的 InfiniBand 网络连接。InfiniBand 网卡未正确安装可能导致此处验证失败。 驱动安装解压 tgz 安装包后，在解压目录下，以命令 [root@A ~]$ ./mlnxofedinstall 开始安装驱动。 在安装过程中，程序首先会检查操作系统版本的一致性，若这里检查失败，可参考「常见问题」给出的解决方案。其次，程序还会检查软件依赖（包括 perl、gtk2、atk、cairo、gcc-gfortran、libxml2-python、tcsh、lsof、tcl 和 tk），并会自动给出所缺依赖的安装命令，根据提示安装依赖后再重新安装驱动即可。 待驱动安装完成后，以如下命令启动 openibd 并设为开机自启： 12[root@A ~]$ service openibd start[root@A ~]$ chkconfig openibd on 再以如下命令启动子网管理器 opensmd 并设为开机自启： 12[root@A ~]$ service opensmd start[root@A ~]$ chkconfig opensmd on 最后，以命令 [root@A ~]$ ibstat 检查 HCA 端口状态，若 State 栏为 Active 则表示驱动安装正常。主机与 InfiniBand 交换机连接不正常可能导致 State 栏为 Down。 网络 IPoIB 配置在 ibstat 驱动安装检查正常后方可进行网络配置。 首先以如下内容创建文件 /etc/sysconfig/network-scripts/ifcfg-ib0 ： 12345678910111213141516ONNECTED_MODE=noTYPE=InfiniBandPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=noneIPADDR=192.18.2.1NETMASK=255.255.255.0PREFIX=24DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV4_DNS_PRIORITY=100IPV6INIT=noNAME=ib0DEVICE=ib0HWADDR=20:00:07:D2:FE:80:00:00:00:00:00:00:98:03:9B:03:00:16:4C:46ONBOOT=yes 这里，为主机手动配置静态 InfiniBand IP。其中，IPADDR 项可自由指定，HWADDR 应设为主机的 InfiniBand Mac 地址。若意欲实现多个主机间的互连，需在不同主机上将 IPADDR 的前三个字段设置为相同值，且第四个字段不能为 0。以命令 [user@A ~]$ ip address 可查看主机的网络连接情况，在名称为 ib0 的连接中，link/infiniband 字段后面的以冒号连接的内容即主机的 InfiniBand Mac 地址。为不同主机配置网络时，只需修改这两项的内容即可。 配置完成后再以如下命令重启网络接口 ib0： 12[root@A ~]$ ifdown ib0[root@A ~]$ ifup ib0 至此，已完成所有安装配置工作，即可在 InfiniBand 内网中通过 InfiniBand IP 访问不同主机。 常见问题 在驱动安装过程中若操作系统一致性检查失败，并报错系统 kernel 版本不匹配，可在安装包解压目录以命令 [root@A ~/software/MLNX_OFED_LINUX-x.x-x.x.x.x-rhel7.3-x86_64]$ ./mlnx_add_kernel_support.sh -m ./ --make-tgz 重新生成主机系统 kernel 对应的安装包。新安装包自动生成在目录 /tmp/ 下。 若在启动 openibd 服务时，出现如下告警： 12345678Please close all isert sessions and unload 'ib_isert' module.Please make sure module 'rpcrdma' is not in use and unload it.Please make sure module 'ib_srpt' is not in use and unload it.Error: Cannot unload the Infiniband driver stack due to the above issue(s)!To unload the blocking modules, you can run:# modprobe -rv ib_isert rpcrdma ib_srpt 以如上所示命令 [root@A ~]$ modprobe -rv ib_isert rpcrdma ib_srpt 卸载 ib_isert、rpcrdma 和 ib_srpt 模块后再重新启动即可。 以命令 [root@A ~]$ /usr/sbin/ofed_uninstall.sh 即可卸载已完成安装的驱动。 安装 NVIDIA 显卡驱动及 cuda 库前期准备在 NVIDIA 官网分别下载 NVIDIA 显卡驱动和 cuda 库 安装程序 run 文件。对于 CentOS 7 系统，显卡驱动下载 Linux 64-bit 对应版本即可，若下载 Linux 64-bit RHEL 7 对应版本可能会安装失败。 可先行以命令 [root@A ~]$ yum install --enablerepo=epel dkms 安装 DKMS (Dynamic Kernel Module Support) 模块，它可在 kernel 更新后自动为我们重装驱动。 执行安装 在 /usr/lib/modprobe.d/dist-blacklist.conf 中以 # 注释掉原有内容行 blacklist nvidiafb ，添加新建内容行 blacklist nouveau，以禁用 Linux 自带显卡驱动 nouveau 。 以命令 [root@A ~]$ mv /boot/initramfs-$(uname -r).img /root/initramfs-$(uname -r).img.bak 备份原 initramfs 文件，再以命令 [root@A ~]$ dracut -v /boot/initramfs-$(uname -r).img $(uname -r) 更新 initramfs 文件。 关机重启后，以命令 [root@A ~]$ lsmod | grep nouveau 查看是否成功将 nouveau 禁用。 以命令 [root@A ~]$ yum install kernel-devel 安装与系统版本对应的 kernel source。若不能找到对应的安装版本，可在添加第三方软件源，执行 [root@A ~]$ yum update 进行更新后，从头开始重试。 在给下载的显卡驱动安装文件添加可执行权限后，即可以管理员权限运行安装。若报错 kernel source tree，可以在添加 --kernel-source-path=/usr/src/kernels/$(uname -r)/ 选项后运行。若报错 nvidia.ko，可以在添加 -k $(uname -r) 选项后运行。 在给下载的 cuda 库安装文件添加可执行权限后，即可以管理员权限运行安装。 安装字体查看系统字体以命令 [user@A ~]$ fc-list 查看所有已安装的系统字体；以命令 [user@A ~]$ fc-list :lang=zh 查看系统中的中文字体，注意冒号前面的空格。 安装额外的字体 以管理员身份将字体文件拷贝到 /usr/share/fonts/ 目录下； [root@A ~]$ cd /usr/share/fonts ； [root@A ~]$ mkfontscale （若找不到该命令，可以命令 [root@A ~] yum install mkfontscale 安装）； [root@A ~]$ mkfontdir 。 修改系统登录提示（欢迎）信息Linux 系统 SSH 的欢迎信息可以通过修改 /etc/motd 的内容来进行自定义。 但是 /etc/motd 只支持纯文本的欢迎信息。想要实现彩色效果，可以通过修改 /etc/profile.d/motd.sh 来实现，如： 12345678910111213141516171819202122#!/bin/bashecho "==================================================="# ATTENTION:echo -en "\033[01;31m"echo -e "ATTENTION:"# 1. submitting your job at: seislab1, seislab2echo -en "\033[00m"echo -en " 1. submitting your job at: "echo -en "\033[01;32m"echo -e "seislab1, seislab2"# 2. GPU test at: seislab0echo -en "\033[00m"echo -en " 2. GPU test at: "echo -en "\033[01;32m"echo -e "seislab0"#echo -e "\033[00m" ~/.bashrc、/etc/bashrc 和 /etc/profile ~/.bashrc 为用户终端环境设置，仅影响当前用户；/etc/bashrc 和 /etc/profile 为系统终端环境设置，影响所有用户。 系统登录时，/etc/profile 最先被加载，而后它调用了 /etc/bashrc 以及 ~/.bashrc。 /etc/profile 对所有 shell 生效，/etc/bashrc 和 ~/.bashrc 仅对 bash 生效。 创建、修改、删除及限制用户本节涉及到的命令的调用格式均为： 1[root@A ~]$ command [option] username 创建用户创建新用户时使用 useradd 或 adduser 命令，其常用选项有： -c “comment”：指定一段注释性描述； -d directory：指定用户 HOME 目录，若该目录不存在，可同时使用 -m 选项以创建之； -g group：指定用户所属用户组； -G group：为用户添加附加组，group 设置为 &quot;&quot; 即删除该用户所有附加组； -s shell：指定用户的默认登录 SHELL； -e YYYY-MM-DD：指定用户账号失效的绝对时间； -u userid：指定用户的用户 ID，可同时使用 -o 选项以重复使用其他用户的 ID 号。 修改用户修改用户账号时使用 usermod 或 groupmod 命令，常用选项与 useradd 命令一致。以下例中使用该命令修改旧用户名 test 为新用户名 love： 修改用户信息及 HOME 目录：[root@A ~]$ usermod -l love -d /home/love -m test 修改用户组信息：[root@A ~]$ groupmod -n love test 删除用户以命令 [root@A ~]$ userdel -rf test 删除用户 test 。 限制用户可以命令 passwd 限制用户账号的使用，其常用选项有： -l：锁定登录密码，即禁止账号使用； -u：解锁登录密码，即解禁账号使用； -d：删除登录密码，即无登录密码，在某些系统中可以直接登录； -f：强制下次登录时修改密码。 发送广播消息mesg 命令 语法：[root@A ~]$ mesg [ny] 功能：设置终端机的写入权限 参数：n/y 允许/不允许系统用户将信息直接显示在屏幕上 write 命令 语法：[user@A ~]$ write 用户名 [终端串口] 功能：向系统某一用户发送消息 wall 命令 语法：[root@A ~]$ wall &lt; 文件名 功能：向系统所有已登录用户发送文件内容 关机/重启shutdown 命令 语法：[root@A ~]$ shutdown [-t sec] [-hkr] time &quot;WARNING INFO.&quot; 参数： h: 停止所有系统服务后立即关机； k: 只发送警告信息，实际不执行关机操作； r: 停止所有系统服务后重新启动。 实例： shutdown -h now: 立即关机； shutdown -h 20:30: 在下一个 20:30 时刻关机； shutdown +5 &quot;System will shutdown after 5 minutes: 向所有登入用户发送警告，在 5 分钟后关机。 另外，可以命令 [root@A ~]$ shutdown -a 取消已经提交的定时关机命令。 reboot 命令 语法：[root@A ~]$ reboot [-w] 参数：w 仅做测试，执行一个重开机模拟，并不真正将系统重启。 pip 指定安装目录临时方法安装模块 modulename 到目录 /path/to/directory 可以使用命令：[user@A ~]$ pip install --target=/path/to/directory modulename 此方法会直接在目标目录创建 module 文件夹，因此调用前只需将该目录加入 PYTHONPATH 系统环境变量即可。 永久方法若经常需要安装一些额外的 python 函数包到目录 /path/to/directory，则可以修改用户 HOME 目录下 .pip/pip.conf（若不存在则创建），加入以下内容： 12[install]install-option=--prefix=/path/to/directory 此方法会根据安装 module 版本的不同，在目标目录下进一步创建其他子文件夹，最终在子文件夹下创建 module 文件夹，因此调用前需将子文件夹目录加入到 PYTHONPATH 系统环境变量中。 强制踢出已登录用户以下实现踢出已登录用户 user： 先使用 w 命令查看用户 user 登录的 TTY 端口号，此处假设端口号为 pts/4； 再使用命令 [root@A ~]$ pkill -kill -t pts/4 踢出。 最后使用命令 [root@A ~]$ pkill -u user 杀死该用户的所有进程。 查看系统信息 查看系统版本号：[user@A ~]$ cat /etc/centos-release 查看系统内核版本号：[user@A ~]$ uname -r 查看操作系统位数：[user@A ~]$ getconf LONG_BIT 查看系统日志：[root@A ~]$ vim /var/log/messages 查看系统字体：[user@A ~]$ fc-list 查看系统中文字体：[user@A ~]$ fc-list :lang=zh 查看系统网卡的 UUID：[user@A ~]$ nmcli con show 查看系统网络 Mac 地址：[user@A ~]$ nmcli device show 查看系统登录日志： 查看系统中所有用户的历史登录信息统计：[root@A ~]$ lastlog 查看近期系统用户成功登入的登录信息：[root@A ~]$ last 查看近期尝试登入失败的登录信息：[root@A ~]$ lastb 查看 CPU 温度以命令 [root@A ~]$ yum install lm_sensors.x86_64 安装 lm_sensors，以 [root@A ~]$ sh -c &quot;yes|sensors-detect&quot; 检测传感器后，即可以命令 [user@A ~]$ sensors 查看 CPU 温度了。 xz 压缩或解压使用 xz -z dir 命令压缩目录 dir，使用 xz -d file 命令解压文件 file。在解压以 .tar.xz 结尾的文件时，可以调用 tar -l xz -cxvf 命令。 rpm 查看系统安装包安装目录先用 rpm -qa | grep libname 命令查询 libname 安装包得到该包完整名字 libname-version.arch ，再用 rpm -ql libname-version.arch 命令查看该包安装位置。 查看已安装的软件包 以 rpm 包安装的：[root@A ~]$ rpm -qa | grep packagename 以 deb 包安装的：[root@A ~]$ dpkg -l | grep packagename 以 yum 命令安装的：[root@A ~]$ yum list installed | grep packagename 一次性定时任务 at安装启动以命令 [root@A ~]$ yum install at 安装 at 后台工具。 以命令 [root@A ~]$ service atd start 启动 atd 服务。 检查运行状态以命令 [user@A ~]$ service atd status 查看 at 的守护进程 atd 是否正在运行。若显示 “Active: active (running)” 则表示已成功启动。 黑白名单黑名单文件为 _/etc/at.deny_，白名单文件为 _/etc/at.allow_，并遵循如下规则： 当系统中存在白名单文件时，黑名单文件将被忽略，只有写入白名单的用户才可以运行 at 命令； 当系统中只有黑名单文件中，被写入名单的用户不能运行 at 命令，且黑名单对 root 无效； 如果两个文件都不存在时，只有 root 用户可以运行 at 命令。 at 命令以命令 [user@A ~]$ at &lt;time&gt; 启动 at 命令行，并输入要执行的任务命令集合，按 [ctrl + d] 结束输入，at 命令会提示该任务的系统编号为 ##；这里，&lt;time&gt; 格式可以为： HH:MM，如 02:30 HH:MM YYYY-MM-DD，如 08:00 2018-10-10 HH:MM [am | pm] [month] [date]，如 08:00 Oct 1 HH:MM [am | pm] + number [minutes | hours | days | weeks]，如 08:00 + 1 days now + number [minutes | hours | days | weeks]，如 now + 5 minutes 以命令 [user@A ~]$ at -l 查看所有等待执行的 at 任务； 以命令 [user@A ~]$ at -c ## 查看 ## 号 at 任务的任务详情； 以命令 [user@A ~]$ at -d ## 删除正在等待执行的 ## 号 at 任务。 磁盘分区管理工具 fdisk为例，以如下系列命令删除磁盘 /dev/sdb 的原有分区并创建一个新的分区： [root@A ~]$ fdisk /dev/sdb WARNING: fdisk GPT support is currently new, and therefore in an experimental phase. Use at your own discretion.Welcome to fdisk (util-linux 2.23.2). Changes will remain in memory only, until you decide to write them.Be careful before using the write command. Command (m for help): m Command action d delete a partition g create a new empty GPT partition table G create an IRIX (SGI) partition table l list known partition types m print this menu n add a new partition o create a new empty DOS partition table q quit without saving changes s create a new empty Sun disklabelw write table to disk and exit Command (m for help): dPartition number (1,2, default 2): 2Partition 2 is deleted Command (m for help): p Disk /dev/sdb: 4000.8 GB, 4000787030016 bytes, 7814037168 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: gpt # Start End Size Type Name1 34 32767 16M Microsoft reser Microsoft reserved partition Command (m for help): dSelected partition 1Partition 1 is deleted Command (m for help): p Disk /dev/sdb: 4000.8 GB, 4000787030016 bytes, 7814037168 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: gpt # Start End Size Type Name Command (m for help): nPartition number (1-128, default 1): 1First sector (34-7814037134, default 2048):Last sector, +sectors or +size{K,M,G,T,P} (2048-7814037134, default 7814037134):Created partition 1 Command (m for help): p Disk /dev/sdb: 4000.8 GB, 4000787030016 bytes, 7814037168 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: gpt # Start End Size Type Name 1 2048 7814037134 3.7T Linux filesyste Command (m for help): wThe partition table has been altered! Calling ioctl() to re-read partition table.Syncing disks. 软 RAID 磁盘管理RAID 简介RAID（即 Redundant Array of Independent Disks，独立磁盘冗余阵列）是一种磁盘管理技术，是由多个独立的高性能磁盘驱动器组成的磁盘系统，从而提供比单个磁盘更高的存储性能和数据冗余的技术。 RAID 主要利用镜像（即 Mirroring，将原始数据完整复制到多个磁盘上）、数据条带（即 Data stripping，将数据分片保存在不同磁盘上）和数据校验（即 Data parity，利用冗余数据进行数据错误检测和修复，冗余数据通常采用海明码或 XOR 操作等算法来计算获得）三大技术来获取高性能、可靠性、容错能力和扩展性。 由于所采用技术组合的不同，实际应用中存在着多种 RAID 等级，如 RAID0、RAID1、RAID3、RAID5、RAID6 和 RAID10 等。根据实现方法的不同，又可以分为软 RAID、硬 RAID 和混合 RAID 三种：软 RAID 由操作系统和 CPU 来完成，没有独立的 RAID 控制/处理芯片和 I/O 处理芯片，效率较低；硬 RAID 由完全由专门的 RAID 控制/处理芯片、I/O 处理芯片和阵列缓冲来实现，不占用 CPU 资源，但成本较高；混合 RAID 有 RAID 控制/处理芯片，但没有 I/O 处理芯片，同时也需要 CPU 和驱动程序来完成，性能和成本都介于软 RAID 和硬 RAID 之间。 创建软 RAID 阵列在 Linux 系统上，软 RAID 磁盘的管理可以借助 mdadm 命令来实现。以下利用 mdadm 工具以磁盘 /dev/sdf 为热备份磁盘，将磁盘 /dev/sdb、/dev/sdc、/dev/sdd 和 /dev/sde 按 RAID5 的方式组合为一个磁盘阵列： 以命令 [root@A ~]$ mdadm -C -v /dev/md5 -l5 -n4 /dev/sd[bcde] -x1 /dev/sdf 开始创建磁盘阵列，其中：-C 表示创建新的磁盘阵列，-v 表示列出相关信息，-l5 表示 RAID5 模式，-n4 表示采用 4 块磁盘制作阵列，-x1 表示采用 1 块磁盘作热备份； 以命令 [user@A ~]$ cat /proc/mdstat 查看磁盘阵列制作进程，待有进度条的输出内容行消失即表示创建完成； 以命令 [root@A ~]$ mdadm -D /dev/md5 即可查看新建磁盘阵列的详细信息； 以命令 [root@A ~]$ mdadm -Dvs &gt; /etc/mdadm.conf 命令保存当前阵列配置信息； 以命令 [root@A ~]$ mkfs.ext4 /dev/md5 对新建磁盘阵列进行格式化。 至此，磁盘阵列即已成功创建，再以 mount 命令挂载后即可使用。 软 RAID 日常管理以命令 [root@A ~]$ mdadm /dev/md5 -r /dev/sde 从 RAID 磁盘阵列 /dev/md5 中删除损坏的磁盘 /dev/sde。 以命令 [root@A ~]$ mdadm /dev/md5 -a /dev/sde 向 RAID 磁盘阵列 /dev/md5 中增加新的磁盘 /dev/sde，这里的新增磁盘会用作热备份磁盘。 以命令 [root@A ~]$ mdadm -G /dev/md5 -n4 设置使用 4 块工作磁盘，即将上述热备份磁盘 /dev/sde 转为工作磁盘。 以命令 [root@A ~]$ mdadm -S /dev/md5 停止 RAID 磁盘阵列 /dev/md5。 以命令 [root@A ~]$ mdadm -A /dev/md5 /dev/sdb /dev/sdc /dev/sdd /dev/sde /dev/sdf 重新装配 RAID 磁盘阵列 /dev/md5，或以命令 [root@A ~]$ mdadm -As 自动根据配置文件 /etc/mdadm.conf 装配阵列。 功能强大的 LD_PRELOAD 变量LD_PRELOAD 是 Linux 系统的一个环境变量，它可以定义一个程序运行前优先加载的动态链接库，主要是用来有选择性地载入不同动态链接库中的相同函数。 一般情况下，动态链接库的加载顺序为：LD_PRELOAD &gt; LD_LIBRARY_PATH &gt; /etc/ld.so.cache &gt; /lib &gt; /usr/lib。 为了实现某些功能，可以重定义第三方库中的一些函数，编译为动态链接库，并将 LD_PRELOAD 设置为此自定义动态链接库。此时，程序在运行时，会优先调用自定义库文件中覆写的第三方库同名函数。此处可见详细示例。 另外，在安装某些软件（如 anaconda）时，如需指定其他路径的第三方库而不使用自身提供的同名库（如 hdf5），可将 LD_PRELOAD 设置为需指定路径的库文件，即可强制安装程序调用指定路径的库文件。 创建新用户时的默认规则配置/etc/login.defs 配置文件通过该文件可以定义在创建新用户时的一些默认设置，其中： MAIL_DIR 字段：系统邮件文件存放位置； PASS_MAX_DAYS 字段：用户密码持续有效天数； PASS_MIN_DAYS 字段：用户密码允许修改的最短间隔天数； PASS_MIN_LEN 字段：允许设置的密码最小长度； PASS_WARN_AGE 字段：自系统给出提醒到密码完全失效的间隔天数； UID_MIN 字段：允许设置的最小用户 ID； UID_MAX 字段：允许设置的最大用户 ID； GID_MIN 字段：允许设置的最小用户组 ID； GID_MAX 字段：允许设置的最大值用户组 ID； CREATE_HOME 字段：是否创建用户 HOME 目录，yes 表示创建。 /etc/default/useradd 配置文件通过该文件可以定义在使用 useradd 或 adduser 命令创建新用户时的一系列创建规则，其中： HOME 字段：用户 HOME 目录的所在目录； INACTIVE 字段：是否启用账号过期停权，-1 表示不启用； EXPIRE 字段：账号失效日期，为空表示不启用； SHELL 字段：默认 SHELL 类型，需指明全路径； SKEL 字段：创建用户 HOME 目录时拷贝的初始启动文件的存放位置。 用户账号信息系统文件/etc/passwd 文件该文件记录了用户的一些基本属性，一行记录对应于一个用户，每行记录又以 : 分隔为 7 个字段，分别为： 用户名:登录密码:用户 ID :用户组 ID :注释性描述信息: HOME 目录:登录 SHELL “用户名”中不能有分隔符 : ，不宜超过 8 个字符，不宜包含字符 . ，不宜以字符 - 或 + 开头。 “登录密码”为密码加密字符串。出于安全考虑，在采用了 shadow 技术的现代 Linux 系统中，本文件中该字段一般设为字符 x 或 *。 “用户 ID”相同而用户名不同的多个用户，系统视为同一个用户，对系统中的文件拥有相同的访问权限，但可以有不同的登录密码、不同的 HOME 目录和不同的登录 SHELL 等。 “注释性描述信息”可以记录一些与用户相关的个人信息，没有实际用途。 “登录 SHELL”也可以指定为某特定的程序，即用户只能运行该指定程序，程序运行结束后自动退出登录。 另外，该文件中还记录了一些伪用户的信息，它们的登录 SHELL 为空，即不能登录。它们的存在主要是为了方便系统管理，满足相应的系统进程支文件所有者属性的要求。 /etc/shadow 文件该文件记录了与用户密码相关的信息，同样地，一行记录对应于一个用户，每行记录又以 : 分隔为 8 个字段，分别为： 用户名:登录密码:最后修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 “用户名”与 /etc/passwd 文件中保持一致，唯一地表征一个单独的用户。 “最后修改时间”为最后一次修改用户登录密码的时间，其值为自 1970 年 1 月 1 日起算的天数。 “最小时间间隔”指定两次修改登录密码的最小间隔天数。 “最大时间间隔”指定登录密码持续有效的最大天数。 “警告时间”指定自系统给出提醒到密码完全失效的间隔天数。 “不活动时间”指定账号保持有效的用户连续不登录的最大天数。 “失效时间”指定用户账号失效的时间，其值为自 1970 年 1 月 1 日起算的天数。 /etc/group 文件该文件记录了用户组的相关信息，一行记录对应于一个用户组，每行记录又以 : 分隔为 4 个字段，分别为： 用户组名:用户组密码:用户组 ID :组内用户列表 “用户组名”由字母或数字构成，不应重复。 “用户组密码”为密码加密字符串。出于安全考虑，在采用了 shadow 技术的现代 Linux 系统中，本文件中该字段一般设为字符 x 或 *。 “组内用户列表”中，多个用户以逗号 , 分隔。 批量创建用户准备文件先参照 /etc/passwd 文件的格式，创建一个文本用户文件 user.txt，如： 12user001::600:100:user:/home/user001:/bin/bashuser002::601:100:user:/home/user002:/bin/bash 再创建一个密码对照文件 passwd.txt，如： 12user001:明码密文user002:明码密文 创建用户 [root@A ~]$ newusers &lt; user.txt：从用户文件 user.txt 中导入数据，创建用户； [root@A ~]$ pwunconv：取消 shadow password 功能，将 /etc/shadow 中的用户密码写入 /etc/passwd 中，删除 /etc/shadow 文件，方便下一步的密码转换； [root@A ~]$ chpasswd &lt; passwd.txt：按照默认的加密方式，将用户密码加密后写入 /etc/passwd 的密码栏； [root@A ~]$ pwconv：重新启用 shadow password 功能，创建 /etc/shadow 文件，删除 /etc/passwd 中的用户密码。 CentOS 7 / Redhat 开放指定网络端口下文中以 55555/tcp 为例，即指定网络端口号为 55555，指定网络协议为 tcp。 查看已开放端口[root@A ~]$ firewall-cmd --zone=public --list-port 开放指定端口12[root@A ~]$ firewall-cmd --zone=public --add-port=55555/tcp --permanent[root@A ~]$ firewall-cmd --reload 关闭指定端口12[root@A ~]$ firewall-cmd --zone=public --remove-port=55555/tcp --permanent[root@A ~]$ firewall-cmd --reload 查看指定端口状态[root@A ~]$ firewall-cmd --zone=public --query-port=55555/tcp nginx 安装准备工作首先，以如下命令安装依赖： 12[root@A ~]$ yum install gcc-g++ autoconf automake libtool make cmake[root@A ~]$ yum install zlib openssl pcre-devel 然后，自官网下载源码安装包 nginx-1.xx.x （不带 Windows 的稳定版即可），并以命令 [root@A ~]$ tar -zpxvf nginx-1.xx.x.tar.gz 解压之。 最后，以如下命令创建 nginx 用户并修改该用户默认属性： 123[root@A ~]$ groupadd nginx[root@A ~]$ useradd -g nginx -M nginx[root@A ~]$ chsh -s /sbin/nologin nginx 编译安装在安装包的解压目录 nginx-1.xx.x 下，运行如下脚本将 nginx 安装至 /data/software/nginx 目录： 1234567891011121314#!/bin/bash./configure --prefix=/data/software/nginx \ --pid-path=/data/software/nginx/run/nginx.pid \ --with-http_ssl_module \ --user=nginx \ --group=nginx \ --with-pcre \ --without-mail_pop3_module \ --without-mail_imap_module \ --without-mail_smtp_modulemake -jmake install 管理测试可以命令 [root@A ~]$ /data/software/nginx/sbin/nginx -v 查看 nginx 的安装版本。 nginx 的配置文件为 /data/software/nginx/conf/nginx.conf，通过修改该文件相应内容，即可自定义配置 nginx（如修改默认监听端口，重启 nginx 服务方可生效）。 可以命令 [root@A ~]$ /data/software/nginx/sbin/nginx -t 验证 nginx 配置。 可以命令 [root@A ~]$ /data/software/nginx/sbin/nginx 首次启动 nginx 服务。 可以命令 [root@A ~]$ /data/software/nginx/sbin/nginx -s reload 重启 nginx 服务。 可以命令 [root@A ~]$ /data/software/nginx/sbin/nginx -s stop 停止 nginx 服务。 在启动 nginx 服务后，可以如下命令进行 localhost 测试（以默认端口号 80 为例）： 123456789101112131415161718192021222324252627[user@A ~]$ curl localhost:80&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;[user@A ~]$ 在目标服务器（以 IP 地址 192.18.1.101，端口号 80 为例）上启动 nginx 服务，并关闭 SELinux 和防火墙后，在其他可访问目标服务器的主机上，浏览器打开 http://192.18.1.101:80 即可访问目标服务器的 nginx 测试页面。 常见问题总结pbsnodes 工作异常在调用 pbsnodes 命令时出现异常，可能是由于某些 PBS 节点的 pbs 服务未正常启动，可登陆至该节点以命令 [root@A ~]$ service pbs start 重启 pbs 服务即可。 多用户组用户的组间切换多用户组用户在登录时默认登录到初始登录用户组，通过命令 [user@A ~]$ newgrp groupname 即可切换到附加用户组。 PGI 社区免费版 License 过期修改 PGI 社区免费版安装目录下的 license.dat 文件中 FEATURE 行的日期为将来的某一日期即可。 OpenMPI 提供的 mpirun 在运行时不同节点的运行环境变量不同使用「-x &lt;arg0&gt;」运行选项将当前主机的环境变量分发给其他主机，如 [user@A ~]$ mpirun -x LD_LIBRARY_PATH ... 。 安装 NVIDIA 高版本（Linux 418.43 以上）驱动后，nvprof 工具由于内部错误无法工作在安装 NVIDIA GPU 高版本（Windows 419.17 或 Linux 418.43 以上）驱动后，Cuda 并行代码分析工具 nvprof 或 nvvp 在分析代码性能时，出现由于内部错误引起的报错信息： ERR_NVGPUCTRPERM The user running &lt;tool_name/application_name&gt; does not have permission to access NVIDIA GPU Performance Counters on the target device. 这是由于 NVIDIA 公司提高了驱动的安全等级，默认禁止普通用户访问 NVIDIA GPU 性能工具，即不允许普通用户进行代码性能分析，root 用户可正常使用 nvprof 和 nvvp 等代码性能分析工具。 根据此处的官方提示，对于 Linux 系统，可在通过命令 [root@A ~]$ modprobe -r vidia_uvm nvidia_drm nvidia_modeset nvidia-vgpu-vfio nvidia 卸载依赖的 NVIDIA 模块（若警告提示未安装某模块时，可在 -r 选项后面的模块列表里去掉相应模块后重新尝试卸载）后，再通过命令 [root@A ~]$ modprobe nvidia NVreg_RestrictProfilingToAdminUsers=0 即可设置允许普通用户使用 NVIDIA GPU 性能工具。 上述设置仅在当次系统启动下生效，当系统发生重启时自动失效。 在文件 /etc/rc.d/rc.local 中追加行内容 modprobe -r vidia_uvm nvidia_drm nvidia_modeset nvidia-vgpu-vfio nvidia 即可使机器在重启时自动执行此命令，再在文件夹 /etc/modprobe.d/ 下创建文件 custom.conf 并写入行内容 options nvidia &quot;NVreg_RestrictProfilingToAdminUsers=0&quot; 即可默认设置允许普通用户使用 NVIDIA GPU 性能工具。如此设置则系统重启后仍有效。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动中值滤波边界问题]]></title>
    <url>%2F2018%2F07%2F21%2FBoundary-problem-of-Moving-Median-Filter%2F</url>
    <content type="text"><![CDATA[From Wikipedia, to handle missing window entries at the boundaries of the signal, there are some schemes that have different properties that might be preferred in particular circumstances: The first value is repeated, as with the last value, to obtain enough entries to fill the window. Avoid processing the boundaries, with or without cropping the signal boundaries afterwards. Shrinking the window near the boundaries, so that every window is full. Fetching entries from other places in the signal.]]></content>
      <categories>
        <category>Tricks</category>
      </categories>
      <tags>
        <tag>DSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Fortran 90 中使用 netCDF 数据格式简介]]></title>
    <url>%2F2018%2F07%2F20%2FFortran90-netCDF-Introduction%2F</url>
    <content type="text"><![CDATA[本文翻译自 Michael Thorne (michael.thorne@utah.edu) 所执笔的 Introduction to using the netCDF data format with Fortran 90（故而文中所有自称均指代原文作者），谨供学习在 Fortran 中使用 netCDF 数据格式之用。 引言netCDF（即 network Common Data Form）为存储多维数据而产生的一种基于数组的数据结构。一个 netCDF 文件采用 ASCII 头书写，以二进制格式存储数据。因为我们不必担心字节序的问题，以二进制文件来保存数据具有明显的优势。字节交换可以通过调用 netCDF 库来实现，netCDF 文件可以在任何平台上读取。与使用 netCDF 数据格式相关的特性如下： 坐标系：支持 N 维坐标系。 X 坐标（如，纬度） Y 坐标（如，经度） Z 坐标（如，高程） 时间维度 其他维度 变量：支持多重变量。 如，S 波速度，P 波速度，密度，应力分量…… 空间几何：支持多种网格类型（隐式或显式）。 规则网格（隐式） 不规则网格 数据点 自我描述：数据集可以包括数据定义信息。 单位（如，km，m/sec……） 注释（如，标题，调用约定，变量名（如，P 波速度），坐标单位（如，km/sec），……） 关于数据格式的更全的文档在： netCDF 主页 netCDF 文档 F90 接口指导 文件名约定：netCDF 文件通常以 .nc 为扩展名。文件约定：有很多 netCDF 数据风格和约定。在地震学中，人们对 .grd 文件（GMT 软件生成）最熟悉。为了符合 GMT 的要求，采用 COARDS (Cooperative Ocean/Atmosphere Research Data Service) 数据约定书写 netCDF 文件。我开始使用 netCDF 文件的原因之一是，网格信息也可以随数据一同保存下来。因此，在使用类似 GMT 的软件时我不必显式地书写 xyz2grd 命令对数据成图和记忆正在成图的数据文件的范围（GMT 中的 -R 选项）以及网格增量（-I 选项）是多少。然而，只能在直角坐标系统下使用 COARDS 约定。坐标可以不等间距，但必须单调递增或单调递减。很不幸，在不使用类似 blockmean 的命令对数据进行预处理时，GMT 是不能对不等间距网格进行操作的。可视化：使用 netCDF 格式还有一个明显的优势，即有多种数据查看器。另外，几乎所有的我熟悉的可视化包都可以读取 netCDF 格式。这里有一些常用的免费查看器或可视化包： Ncview Data Explorer (OpenDX) 文件结构netCDF 文件包含如下结构： netCDF 文件结构 作用 全局属性 描述文件内容 维度 描述数据结构（如，时间，深度，纬度，经度） 变量 按照维度存储数据的数组 变量属性 描述每个变量的内容 另参见 博文]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>netCDF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim 配置、技巧及其周边]]></title>
    <url>%2F2018%2F07%2F20%2FTips-of-Vim%2F</url>
    <content type="text"><![CDATA[常用配置函数Vim 有一些配置函数，利用这些函数，我们可以通过修改配置文件让我们的 Vim 发挥出更强大的功能。 line(expr) The result is a Number , which is the line number of the file position given with expr .The accepted positions are: “.” the cursor position; “$” the last line in the current buffer; x position of mark “x” (if the mark is not set, 0 is returned). 返回值是一个整数。这个函数功能时返回一个行号。如果你后面的参数 expr 是 “.” 的话，则返回当前光标所在的位置。如果 expr 是 “$” 则返回当前缓冲区最后一行的行号。如果 expr 的值是一个标签名，则返回你对应的标签所在的行号。例如：call line(“.”) 得到当前光标所在的行号。 col({expr})返回指定位置的列号，列号从1开始算起。例如：echo col(“.”) 返回光标所在的列号。echo col(“$”) 返回光标所在的行的长度+1。echo col([2,’$’]) 返回第2行的长度+1。（之所以是长度+1是因为，其实每行的最后有一个不可打印的换行符） setpos({expr})移动光标到指定的行和列。例如：let pos=[0, 25, 15, 0]; call setpos(“.”, pos) 移动光标到 25 行 15 列的位置。 setline ({lnum}, {text}) Set line {lnum} of the current buffer to {text}.If this succeeds, 0 is returned. If this fails (most likely lnum is invalid) 1 is returned.When {lnum} is just below the last line the {text} will be added as a new line. 这个函数就是将第 lnum 行的内容替换成 text 中的内容。如果这个 lunm 行是最后一行的下面一行，那么将新建一行，然后将 text 的内容存放到这一行。如果不是最后一行的下一行，则要满足的条件是行号为 lnum 的行必须是存在的。例如：call setline(1, “/*********************/“) 在文件的开头添加上面的一行，主要是用于 .c/.cpp 文件注释的。 getline({lnum}, {end}) Without the {end},the result is a String, which is line {lnum} from the current buffer.When {end} is given the result is a List where each item is a line from the current buffer in the range {lnum} to {end}, including line {end}. 返回值是一个字符串。当 end 参数存在的时候，函数返回行号为 lnum 的内容，否则函数将返回行 lnum 到行 end 的所有内容（包括第 end 行）。例如：let lines=getline(2, 5); call append(6, lines) 取得 2-5 行的内容，然后从第六行的下一行开始添加，保持原来的格式不变。 append(lnum, string) Append the text string after line lnum in the current buffer. lnum can be zero, to insert a line before the first one. Returns 1 for failure (lnum out of range) or 0 for success. 这个函数就是将 string 这个字符串，插入到行号为 lnum 的下一行。成功则返回 0，否则返回 1 。 expand(expr [, flag]) Expand the file wildcards in expr . The result is a String .When the result of expr starts with% , # or &lt; , the expansion is done like for the cmdline- special variables with their associated modifiers. There cannot be a white space between the variables and the following modifier. When the current or alternate file name is not defined, % or # use an empty string. Using %:p in a buffer with no name results in the current directory, with a “/ ”added.When {expr} starts with ‘%’, ‘#’ or ‘&lt;’, the expansion is done like for the |cmdline-special| variables with their associated modifiers. Here is a short overview:“%” current file name;“#“ alternate file name;“#n” alternate file name n.Modifiers::p expand to full path;:h head (last path component removed);:t tail (last path component only);:r root (one extension removed);:e extension only. 函数的返回值是一个字符串。功能就是将参数 expr 这个通配符进行扩展。各个通配符的含义上面列出来了。例如：call append(2, “File Name: “.expand(“%”)) 在文件的第三行写入这句话 “File Name: ${filename}”，这边%表示当前文件的名称，通过函数expand（”%”）将其还原成了文件名字符串。let sourcefilepath=expand(“%:p”) 获取到当前文件的完全路径（绝对路径）。 配置函数应用举例在用 Vim 打开文件后，在命令模式下，输入命令 1:echo col(".") 即返回光标所在的列号。在「$HOME/.vimrc」文件中添加如下语句 123if has("autocmd") au BufReadPost * if line("'.") &gt; 0 &amp;&amp; line("'.") &lt;= line("$") | exe "normal! `." | endifendif 此设置即在文件打开时，如果文件上次编辑的位置存在（即不在 1 行和最大行数以外），自动跳转至上次编辑的位置。此外，可以使用 1au BufReadPost * if line("'\"") &gt; 1 &amp;&amp; line("'\"") &lt;= line("$") | exe "normal! '\"" | endif 跳转至上次离开的行首。或使用 1au BufReadPost * if line("'\"") &gt; 0 &amp;&amp; line("'\"") &lt;= line("$") | exe "normal! `\"" | endif 跳转至上次离开的位置。 Vim 配置收录以下： 配置 功能 set hlsearch 搜索时高亮反白匹配字符串 set autoindent 自动缩排 set ruler 底边显示状态栏 set showmode 左下角显示模式状态 set nu 行首显示行号 set bg=dark 设置底色色调 syntax on 开启语法检查 set nocompatible 不使用兼容模式 set textwidth=0 或 set tw=0 设置行宽，为 0 时即不自动换行 set backup 开启自动备份 set bdir=~/.vim 设置备份目录 set history=50 设置命令历史长度 set tabstop=4 或 set ts=4 设置制表符 tab 长度 set shiftwidth=2 或 set sw=2 设置自动缩进空格数 set showcmd 显示命令 set showmatch 显示匹配 set ignorecase 忽略大小写 set incsearch 输入搜索命令时显示当前匹配 set autowrite 执行外部命令时自动保存 set nolist 不显示不可见字符 set mouse=a 鼠标可用 set nowrap 不自动折行 set expandtab 采用空格代替制表符 tab 缩进 set cursorline 高亮当前行 set cursorcolumn 高亮当前列 set relativenumber 显示相对行号 set colorcolumn=80 设置高亮某列 highlight ColorColumn ctermfg=9 ctermbg=242 设置列高亮背景色 imap tt &lt;esc&gt; 用 tt 连续按键代替 ESC 键 set encoding=utf-8 fileencodings=ucs-bom,utf-8,cp936,gb2312 解决部分字符乱码问题 注：本表持续更新中 将以上配置写入「$HOME/.vimrc」文件，即可对所有文件打开生效。如果想要对某些文件采用不同的打开初始配置，可在相应的文件末尾加入类似如下语句 1# vim:ft=make:sw=4:wrap 该文件为一个 makefile 文件，第一个字符 “#” 为 makefile 文件的注释符，不同的文件可以采用各自相应的注释符。”ft=make” 即指文件格式为 makefile 文件，Vim 自动按 makefile 语法高亮文本，”sw=4” 即设置自动缩进空格数为 4，”wrap” 即设置自动折行，在这里，省去配置语句中的 set，不同的配置语句间用 “:” 隔开。 Vim 命令技巧收录以下： 命令 作用 :se cuc 垂直竖杠（即 set cursorcolum） :Sex 浏览目录 :helpgrep ColorColumn 查找与 ColorColumn 相关的帮助 :hi 查看 highlight 的系统配色方案 注：本表持续更新中 vim-plug 管理插件vim-plug 是一款轻量的 Vim 插件管理器，通过如下一条命令即可完成安装： 12$ curl -fLo ~/.vim/autoload/plug.vim --create-dirs \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 之后再在 ~/.vimrc 文件中加入类似如下内容即可启用： 1234call plug#begin('~/.vim/plugged') Plug 'SirVer/ultisnips' Plug 'lervag/vimtex'call plug#end() 上例中直接加载了 SirVer/ultisnips 和 lervag/vimtex 插件，Plug 起始行可根据自己的需要加载不同的第三方插件。 保存上述修改之后，重新打开 Vim，在命令模式下执行 :PlugInstall 即可安装上述加载的插件，再次重启 Vim 正确加载插件后，根据自己的需要在 ~/.vimrc 中设置不同的环境变量以更改插件的默认设置。 常用插件推荐配置SirVer/ultisnipsSirVer/ultisnips 是一款代码片段模板自动补全插件。推荐配置如下： 1234let g:UltiSnipsExpandTrigger = '&lt;tab&gt;'let g:UltiSnipsJumpForwardTrigger = '&lt;tab&gt;'let g:UltiSnipsJumpBackwardTrigger = '&lt;s-tab&gt;'let g:UltiSnipsEditSplit = 'vertical' 在 Vim 命令模式下执行 :h UltiSnips 即可查看该插件的帮助文档。 lervag/vimtexlervag/vimtex 是一款对 LaTeX 文件（以 .tex 为文件名后缀）提供实时编译功能的插件。推荐配置如下： 123456let g:vimtex_compiler_method = 'latexmk'let g:vimtex_compiler_latexmk = &#123;'backend' : 'jobs'&#125;set conceallevel=1let g:tex_conceal = 'abdmg'let g:vimtex_indent_enabled = 0let g:vimtex_quickfix_latexlog = &#123;'default' : 0&#125; 在 Vim 命令模式下执行 :h vimtex 即可查看该插件的帮助文档。 airblade/vim-gitgutterairblade/vim-gitgutter 是一款在编辑文件时实时显示 git 差异（与 git diff 结果类似）的插件。推荐配置如下： 12345set updatetime=100highlight GitGutterAdd ctermfg=2highlight GitGutterChange ctermfg=3highlight GitGutterDelete ctermfg=1highlight GitGutterChangeDelete ctermfg=4 在 Vim 命令模式下执行 :h gitgutter 即可查看该插件的帮助文档。 jiangmiao/auto-pairsjiangmiao/auto-pairs 是一款在插入左括号时自动补全右括号的插件。推荐配置如下： 12let g:AutoPairsFlyMode = 1let g:AutoPairsMapCR = 0 该插件的帮助文档见 README.md。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My First Blog Attemp]]></title>
    <url>%2F2018%2F07%2F18%2FMy-first-blog-attemp%2F</url>
    <content type="text"><![CDATA[Welcome but enter password to read 8497f8e6f3980b46b37d162a82dd5730577ee93241a64af0283703ce4ce36a395678e1d9e87f074a2cdc02952255990f7e8bf4a61334fd813243c6e25ab332da8924ac57c705cf820617d4404e60b770cf7913671a4796e3ff6027d6cb0851812b721fa4369a4f8119e58379c3059e4e32e479369937c882534d4750a73b91046b65f9dd745ce413f633658ae1eefea727e15959e9764cc8116d748a46ca2867d278cc6421b2b98b9795439432a1ec837d95a8da8c07ac40cd1cfb74147a39f384459a6fd15f5a36ad2fb103b34ef29ba744e900a3ac3303171f7b20f239e7bc82ff253fba99ca6ddb9c93de1fdf386b40084b2b2a54a54cbb886e5303f85b1c28e38f4c46ada0863741ee146229655792a4baafb66cd41357e5429f034140fcb4e3a34cb3a8a3d21c0406a646f5d2a83d9f67f6a1d6470b18d423c721229c73739fbc20b8b6d0ac3df9833bbaf5f670db8f88cd4e6798909c1c74e26c2e4af20f02ef1e7d845dfa9c4fa74d3d82c750491fe31d1f690cbbc5e54112c91f3d944611614db23fa6e4ef47dbddb8d89323ee10e2085f3edb6b8c9ab7c4f42b784bd821b87cb87f2532ba5d41fcdc294944299e28a9460be1334709c60b218e49586a2ee636b58ea1558ad31236a9057167fa98b069edbf8e369f53c2b6ed53575f4726608d7cde18050916df40a3d6771e9ec0bb29c413750e5fbdb11bddedd6e0ceac43da063a2c106138179ec8c96f5317d978bafd9bf7749fb1a6e61a9a30f7f1e08928a582bf73b6782b4345b77a29229fed696b5af6d9582bd46479778fc14c384e3edc6a2e7263a5c2825be4c2920296517814f8b60e63b316d5f214a2b8a5a5906e7ae12e4499557c19695491e0b67fc979c7ec0515ad1f42faeda892b146576d5c279e64621cc042b4b12d2bd2e48eac61da8869b30658f477d9d8bc6d70903568add639b7856e9f5aec8ef480b7b92e64cdc1bb4fb9894d5c1cefea388fa9ac07829a34bd7e834a39b3c1be3e7baad479953579ed9580d6f24100f23e9b48eefa6dfa1e7246ca641737ecd24850d660b575f403073906b5419453ccaa6db9cbe2858dc936f706cdea1910ac2440eb7a1475456b399f443b39339fb983c70e54079769b0e3c16c8376669706609b853d67001cb9035a441a5e9e9c1cc32de927fc02f5f8d45381be6f443fda54c9a815793a48294f5dcf1ccf88efd0c01cce23abb4b7f7a57a914e37f3a3892e98494be08cc093ae0fddaac35993c5b6b95290b091b95ebc7c007b77ea2138c5132c97a51bfdaff101a46fbf4a422869b90a089d632efee0a1575c4fda67fd4a7f6533796dd87d0b409eaaa5448819c178eb9f51a9934d1fc9cc3affcd7de5ca1b79fe7562e9728df207eca80dbb1b7f13c4510a629e3fbfdc0c11bcdcc4d14882b535c3991577fb862d7db6d522b55a91d7be523c56af6c6cec68ab9588849cdf30667cb206b2d1dfb30ef7a86635afbd786e16381589b4a61060cbec17f603678ece437a87df34b2d3ed0085b3705f20fb0491d54a9ed0b0b2c3b1d05977c1bfa2c8f1df12b77837767d748132ce9e2c0d4e81755b61007ec07f39c0e6ff4635491baf480db573d9f8e70670a7a2c07968d85da31361fe5634477cdecaf47638f244352b24ce96b13fa9a2490a97466b8dcc261ea85419848920ab84f530c593f68c32396e2911881217e6a0803b812a8e1c6604dc9d1223415ee9d1cdea3dbd26d58ab42a7f3fb19e5eacc85a6b83355bf9d8eb7a7c4a2082fced2e4badc5f32d618f097ad747cc2b6cc590718aa42b7349e65785a09b3184d44c7305b3a6510d54cfb3a1733d23ef3224239a744e8270d56149643684d3f69f3c7c0f71c1797ff72df013a36d7df860a1cf801a9052cf89080187b9ba5b603be8082db46548591ab0957711244862477b2e50343a61a0b60ea0fb7fb755281a8d22000e2bceac9b8e2f97114ca803a53b0f49c255b390b2c5a13a152dae37a0f52f22704027f0ef1538df005f64f00c87273d7676fa0688b4ac47a49dcc71d44ecad2c47e2f99b874b903476d14c2e38791bfe39a70ad2e8f9b79f29cfb9f8c9ba8f01cc0b2ec165d54e9d9c2945f83f170357d80f4bb277f533acbf9e9884b23cb59dd360f4cdfb3e4be19f80e59ed8b3adae3b034d16bcd7df31ddbb3e00ef6158e862a8e2b4fa4a61140980857a727edbcf4116086d49dfccfdcbf120e837e7a217dea98565ad0d615357b23c16c4a2b930e9f2ee2e14727fe8980e26703a16cf705692be6b3bffa1cdd2656d0df33a1e6e464824c35bcdac207cb19f10584ad8a5577a497a4b161819aacafc7704603badd38ac7038c56fd54f23ab81d817aed9a49a76bd8f65a016daaabc8c2933786cb816433b1fef07fef214a85d5426fd439697f51f9ca814fc0560187afaf2043f484699345e74848561b3734dc5afb65c7f701570042b3294a4c1a1c75826a0adda46e686412267cfae58edc0a14ad44a6a385e343af42060a3af031f5d0468a352836efa3f70175f7d81273b5c2b91900534]]></content>
      <categories>
        <category>NOpen</category>
      </categories>
      <tags>
        <tag>WillDelete</tag>
      </tags>
  </entry>
</search>
